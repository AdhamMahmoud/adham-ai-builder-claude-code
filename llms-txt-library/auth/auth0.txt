# Use AI Tools
Source: https://auth0.com/ai/docs/build-with-ai/using-ai-tools

Use AI tools to integrate Auth0 for AI Agents into your application.

## Introduction

Building with AI tools that have information and context about Auth0 for AI Agents enables you to accelerate your development workflows. By providing these tools with the right information, you can get instant, context-aware answers and even delegate tasks to AI agents.

This allows you to:

* Ask questions in natural language to get up-to-date answers on how to set up and integrate with Auth0 for AI Agents.
* Generate accurate code snippets and get direct links to relevant documentation to help you implement changes faster.
* Have AI agents read documentation to understand complex requirements and apply them to your codebase.

## How it works

### LLM context files

You can provide your AI with targeted information from raw text files (`llms.txt`), individual markdown pages, or URLs to help it perform a specific task. To enable your AI tools to index and search the documentation, use the following files:

* For a high-level overview, the **llms.txt** file at `https://auth0.com/ai/docs/llms.txt` offers concise summaries of all our documentation pages.
* If you need the complete content, you can use the **llms-full.txt** file at `https://auth0.com/ai/docs/llms-full.txt`, which contains the full content of our documentation in a single file.
* Additionally, you can get a **markdown** version of any individual page. Click **Copy page** at the top of the page or append `.md` to any page URL.

We recommend using the Auth0 for AI Agents MCP Server over context files to ensure your AI tools always have access to the most up-to-date information.

### MCP servers

A more powerful method is connecting your tool to an MCP server. These servers act like a specialized API for your AI, allowing them to search for and read documents or perform actions on your behalf.

### Auth0 MCP Server

The Auth0 MCP Server allows authenticated AI agents to perform actions in your Auth0 tenant, such as creating applications, configuring connections, and more. To learn how to connect your AI tool to the Auth0 MCP Server, read the [Auth0 MCP Server documentation.](https://auth0.com/docs/get-started/auth0-mcp-server)

### Auth0 for AI Agents MCP Server

The Auth0 for AI Agents MCP Server provides read-only access to our complete documentation. Use this server to ask questions and get context-aware answers about integrating with Auth0 for AI Agents. This MCP server helps your AI tools implement the Auth0 for AI Agents functionality.

The Auth0 for AI Agents MCP Server has the following endpoint metadata:

* **Server Name:** Auth0 for AI Agents
* **Server URL:** `https://auth0.com/ai/docs/mcp`
* **Transport Type:** HTTP

You can also connect your AI tool to the Auth0 for AI Agents MCP Server by following one of our guides.

<Tabs>
  <Tab title="VS Code">
    <Tip>To automatically connect VS Code to the Auth0 for AI Agents MCP Server, click the down arrow icon next to **Copy page** and select **Connect to VS Code**.</Tip>

    Or create a `.vscode/mcp.json` file and add:

    ```json theme={null}
    {
      "servers": {
        "Auth0 for AI Agents": {
          "type": "http",
          "url": "https://auth0.com/ai/docs/mcp"
        }
      }
    }
    ```

    To learn more, read the [VS Code documentation](https://code.visualstudio.com/docs/copilot/chat/mcp-servers).
  </Tab>

  <Tab title="Cursor">
    <Tip>To automatically connect Cursor to the Auth0 for AI Agents MCP Server, click the down arrow icon next to **Copy page** and select **Connect to Cursor**.</Tip>

    Or follow these steps to connect the MCP server:

    <Steps>
      <Step title="Open MCP settings">
        1. Use <kbd>Command</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> (<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> on Windows) to open the command palette.
        2. Search for "Open MCP settings".
        3. Select **Add custom MCP**. This will open the `mcp.json` file.
      </Step>

      <Step title="Configure the Auth0 for AI Agents MCP Server">
        In `mcp.json`, add:

        ```json theme={null}
        {
          "mcpServers": {
            "Auth0 for AI Agents": {
              "url": "https://auth0.com/ai/docs/mcp"
            }
          }
        }
        ```
      </Step>

      <Step title="Test the connection">
        In Cursor's chat, ask "What tools do you have available?" Cursor should show the Auth0 for AI Agents MCP Server as an available tool.
      </Step>
    </Steps>

    To learn more, read [Installing MCP servers](https://docs.cursor.com/en/context/mcp#installing-mcp-servers).
  </Tab>

  <Tab title="Claude Code">
    Connect to Claude Code using the following command:

    ```bash theme={null}
    claude mcp add --transport http "Auth0 for AI Agents" https://auth0.com/ai/docs/mcp
    ```

    Test the connection by running:

    ```bash theme={null}
    claude mcp list
    ```

    To learn more, read [Installing MCP servers](https://docs.anthropic.com/en/docs/claude-code/mcp#installing-mcp-servers).
  </Tab>

  <Tab title="Claude">
    To use the Auth0 for AI Agents MCP Server with Claude:

    <Steps>
      <Step title="Add the Auth0 for AI Agents MCP Server to Claude">
        1. Navigate to the [Connectors](https://claude.ai/settings/connectors) page in the Claude settings.
        2. Select **Add custom connector**.
        3. Add the Auth0 for AI Agents MCP Server:

        * Name: `Auth0 for AI Agents`
        * URL: `https://auth0.com/ai/docs/mcp`

        4. Select **Add**.
      </Step>

      <Step title="Access the MCP server in your chat">
        1. Use the attachments button (**+**) to add files to your Claude prompt.
        2. Select the Auth0 for AI Agents MCP Server.
        3. Ask Claude a question about Auth0 for AI Agents.
      </Step>
    </Steps>

    To learn more, read the [Model Context Protocol documentation](https://modelcontextprotocol.io/docs/tutorials/use-remote-mcp-server#connecting-to-a-remote-mcp-server).
  </Tab>
</Tabs>

## How to use the Auth0 for AI Agents Docs MCP server

After adding the MCP server to your AI tool, you can ask it questions about how to set up, configure, or integrate with Auth0 for AI Agents. AI coding agents will be able to automatically retrieve the matching documentation for steps, references, and examples when applying code changes.

### Sample prompts

Use these sample prompts to get a quick response, start building a new app, or integrate functionality into your existing app:

* Use the Auth0 for AI Agents MCP server to tell me about accessing 3rd party APIs using a user's credentials.
* Add a tool call to my AI agent that will access the user's Google calendar and answer questions about their schedule and meetings. Use the Auth0 for AI Agents MCP Server to find and follow the instructions on using Auth0 to securely call the Google API using the user's credentials.
* Build me a Next.js AI chatbot app that uses Langgraph to make tool calls to Google Calendar. Use Auth0 for user login and to secure the tool calls to the user's calendar. Use the Auth0 for AI Agents MCP Server for instructions.

<Note>Even with access to the most up-to-date documentation, AI tools can make mistakes. Always review AI-generated code for accuracy.</Note>


# Product Updates
Source: https://auth0.com/ai/docs/changelog/product-updates

Product updates changelog and release notes

<Update label="Sept 19, 2025">
  Added support for new Integrations. AI Agents can now connect to:

  * Basecamp
  * DigitalOcean
  * Salesforce
  * Tumblr
  * Twitch
  * X (Twitter)

  [View all supported Integrations here.](/integrations/overview)
</Update>

<Update label="Sept 17, 2025">
  Added support for new Integrations. AI Agents can now connect to:

  * Amazon
  * Bitbucket
  * DropBox
  * Fitbit
  * Hugging Face
  * PayPal

  [View all supported Integrations here.](/integrations/overview)
</Update>

<Update label="Aug 25, 2025">
  New Token Vault support for exchanging the user's access token for an external API access token such as the Google Calendar API. This allows Token Vault to be used with Single Page Apps (SPAs) that only have an access token for the logged in user and no refresh token.
  Check it out with our new [quickstart using Vercel AI and a React SPA.](/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-react-spa)
</Update>


# Asynchronous Authorization
Source: https://auth0.com/ai/docs/get-started/asynchronous-authorization

Learn how Auth0 for AI Agents enables AI agents to asynchronously authorize users.

Auth0 for AI Agents enables AI agents to asynchronously authorize users using the [Client-Initiated Backchannel Authentication Flow (CIBA)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow). AI agents can work in the background, only notifying the user when needed for critical actions.

When you add secure [human-in-the-loop approvals](https://sdk.vercel.ai/cookbook/next/human-in-the-loop) to your AI agent workflows, you can use Auth0 to request the user's permission to complete an authorization request. The AI agent can render [rich authorization data](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow/user-authorization-with-ciba) in the consent prompt so the user knows exactly what they're authorizing.

By the end of this quickstart, you should have an AI agent integrated with the [Auth0 AI SDK](https://github.com/auth0/auth0-ai-js) that can request to buy products from an online shop on the user's behalf.

## Pick your tech stack

<Tabs>
  <Tab title="LangGraph.js + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    ### Install dependencies

    In the root directory of your project, install the following dependencies:

    * `@auth0/ai-langchain`: [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-langchain) built for AI agents powered by LangChain.
    * `@langchain/langgraph`: For building stateful, multi-actor applications with LLMs.
    * `langchain`: The LangChain library.
    * `@langchain/core`: LangChain core libraries.
    * `@langchain/openai`: OpenAI provider for LangChain.
    * `langgraph-nextjs-api-passthrough`: API passthrough for LangGraph.

    ```bash wrap lines theme={null}
    npm install @auth0/ai-langchain@4 @langchain/core@0.3.77 @langchain/langgraph@0.4.9 @langchain/openai@0.6.13 langchain@0.3.33 langgraph-nextjs-api-passthrough@0.1.4
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env.local` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Set up Human-in-the-Loop approvals

    Integrate the Auth0 AI SDK into your application to secure your async AI agent workflow. For this quickstart, we will use a blocking request flow. In real use cases, often an asynchronous flow is preferred.

    #### Configure the Auth0 AI SDK

    To require asynchronous authorization for your tool, the tool needs to be wrapped with the Async authorizer, `withAsyncAuthorization()`. Let's create a helper function to wrap the tool with the Async authorizer.

    Create a file at `src/lib/auth0-ai.ts` and instantiate a new Auth0 AI SDK client:

    ```tsx src/lib/auth0-ai.ts wrap lines theme={null}
    import { Auth0AI } from "@auth0/ai-langchain";
    import { AccessDeniedInterrupt } from "@auth0/ai/interrupts";

    const auth0AI = new Auth0AI();

    // Async Authorization flow for user confirmation
    export const withAsyncAuthorization = auth0AI.withAsyncAuthorization({
      userID: async (_params, config) => {
        return config.configurable?.langgraph_auth_user?.sub;
      },
      bindingMessage: async ({ product, qty }) =>
        `Do you want to buy ${qty} ${product}`,
      scopes: ["openid", "product:buy"], // add any scopes you want to use with your API
      audience: process.env["SHOP_API_AUDIENCE"]!,

      /**
       * Controls how long the authorization request is valid for.
       */
      // requestedExpiry: 301,

      /**
       * The behavior when the authorization request is made.
       *
       * - `block`: The tool execution is blocked until the user completes the authorization.
       * - `interrupt`: The tool execution is interrupted until the user completes the authorization.
       * - a callback: Same as "block" but give access to the auth request and executing logic.
       *
       * Defaults to `interrupt`.
       *
       * When this flag is set to `block`, the execution of the tool awaits
       * until the user approves or rejects the request.
       * Given the asynchronous nature of the CIBA flow, this mode
       * is only useful during development.
       *
       * In practice, the process that is awaiting the user confirmation
       * could crash or timeout before the user approves the request.
       */
      onAuthorizationRequest: async (authReq, creds) => {
        console.log(`An authorization request was sent to your mobile device.`);
        await creds;
        console.log(`Thanks for approving the order.`);
      },

      onUnauthorized: async (e: Error) => {
        if (e instanceof AccessDeniedInterrupt) {
          return "The user has denied the request";
        }
        return e.message;
      },
    });
    ```

    This will intercept the tool call to initiate a Async Authorization request:

    * The Async Authorization request includes the user ID that will approve the request.
    * Auth0 sends the user a mobile push notification. The AI agent polls the `/token` endpoint for a user response.
    * The mobile application retrieves the `bindingMessage` containing the consent details, in this case, the details of the product to purchase.
    * The user responds to the request:
      * If the request is approved, the tool execution will continue.
      * If the request is rejected, the tool execution will not continue.

    <Frame>
      <img alt="CIBA sequence diagram" />
    </Frame>

    #### Pass credentials to the tools

    Next, add the following code to `src/lib/auth0.ts`:

    ```tsx src/lib/auth0.ts wrap lines highlight={12-20} theme={null}
    //... existing code
    export const auth0 = new Auth0Client({
      authorizationParameters: {
        // In v4, the AUTH0_SCOPE and AUTH0_AUDIENCE environment variables are no longer automatically picked up by the SDK.
        // Instead, we need to provide the values explicitly.
        scope: process.env.AUTH0_SCOPE,
        audience: process.env.AUTH0_AUDIENCE,
      },
    });

    // Get the Access token from Auth0 session
    export const getAccessToken = async () => {
      const tokenResult = await auth0.getAccessToken();

      if(!tokenResult || !tokenResult.token) {
        throw new Error("No access token found in Auth0 session");
      }

      return tokenResult.token;
    };
    ```

    Update the `/src/app/api/chat/[..._path]/route.ts` file with the following code. The access token will be passed to your LangGraph agent so we can use it from the Auth0 AI SDK to get the current user.

    ```ts src/app/api/chat/[..._path]/route.ts wrap lines highlight={3,9-13} theme={null}
    import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";

    import { getAccessToken } from "@/lib/auth0";

    export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
      initApiPassthrough({
        apiUrl: process.env.LANGGRAPH_API_URL,
        baseRoute: "chat/",
        headers: async () => {
          const accessToken = await getAccessToken();
          return {
            Authorization: `Bearer ${accessToken}`,
          };
      });
    ```

    ### Add Custom Authentication

    <Info>
      For more information on how to add custom authentication for your LangGraph Platform application, read the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
    </Info>

    In your `langgraph.json`, add the path to your auth file:

    ```typescript langgraph.json wrap lines highlight={8} theme={null}
    {
      "node_version": "20",
      "graphs": {
        "agent": "./src/lib/agent.ts:agent"
      },
      "env": ".env",
      "auth": {
        "path": "./src/lib/auth.ts:authHandler"
      }
    }
    ```

    Then, in your auth.ts file, add your auth logic:

    ```typescript src/lib/auth.ts wrap lines theme={null}
    import { createRemoteJWKSet, jwtVerify } from "jose";

    const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

    const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
    const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

    // JWKS endpoint for Auth0
    const JWKS = createRemoteJWKSet(
      new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
    );

    // Create the Auth instance
    const auth = new Auth();
    // Register the authentication handler
    auth.authenticate(async (request: Request) => {
      const authHeader = request.headers.get("Authorization");
      const xApiKeyHeader = request.headers.get("x-api-key");
        /**
         * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
         * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
         *
         * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
         * or when running locally.
         */
        // This header is required in Langgraph Cloud.
        if (!authHeader && !xApiKeyHeader) {
          throw new HTTPException(401, {
            message: "Invalid auth header provided.",
          });
        }

        // prefer the xApiKeyHeader first
        let token = xApiKeyHeader || authHeader;

        // Remove "Bearer " prefix if present
        if (token && token.startsWith("Bearer ")) {
          token = token.substring(7);
        }

        // Validate Auth0 Access Token using common JWKS endpoint
        if (!token) {
          throw new HTTPException(401, {
            message:
              "Authorization header format must be of the form: Bearer <token>",
          });
        }

        if (token) {
          try {
            // Verify the JWT using Auth0 JWKS
            const { payload } = await jwtVerify(token, JWKS, {
              issuer: `https://${AUTH0_DOMAIN}/`,
              audience: AUTH0_AUDIENCE,
            });

            console.log("✅ Auth0 JWT payload resolved!", payload);

            // Return the verified payload - this becomes available in graph nodes
            return {
              identity: payload.sub!,
              email: payload.email as string,
              permissions:
                typeof payload.scope === "string" ? payload.scope.split(" ") : [],
              auth_type: "auth0",
              // include the access token for use with Auth0 Token Vault exchanges by tools
              getRawAccessToken: () => token,
              // Add any other claims you need
              ...payload,
            };
          } catch (jwtError) {
            console.log(
              "Auth0 JWT validation failed:",
              jwtError instanceof Error ? jwtError.message : "Unknown error"
            );
            throw new HTTPException(401, {
              message: "Invalid Authorization token provided.",
            });
          }
        }
    });

    export { auth as authHandler };
    ```

    #### Create a tool to call your API

    In this example, we use a tool that buys products on the user's behalf. When the user approves the transaction, the Auth0 AI SDK retrieves an access token to call the shop's API. Upon completing the Async Authorization flow, the AI agent responds with a message confirming the purchase. The Auth0 AI SDK returns an error response if the user denies the transaction.

    Now, create a file `src/lib/tools/shop-online.ts` and add the following code:

    ```ts src/lib/tools/shop-online.ts wrap lines theme={null}
    import { tool } from "@langchain/core/tools";
    import { z } from "zod";

    import { getAsyncAuthorizationCredentials } from "@auth0/ai-langchain";

    export const shopOnlineTool = tool(
      async ({ product, qty, priceLimit }) => {
        console.log(`Ordering ${qty} ${product} with price limit ${priceLimit}`);

        const apiUrl = process.env["SHOP_API_URL"]!;

        if (!apiUrl) {
          // No API set, mock a response
          return `Ordered ${qty} ${product}`;
        }

        const headers = {
          "Content-Type": "application/json",
          Authorization: "",
        };
        const body = {
          product,
          qty,
          priceLimit,
        };

        const credentials = getAsyncAuthorizationCredentials();
        const accessToken = credentials?.accessToken;

        if (accessToken) {
          headers["Authorization"] = "Bearer " + accessToken;
        }

        const response = await fetch(apiUrl, {
          method: "POST",
          headers: headers,
          body: JSON.stringify(body),
        });

        return response.statusText;
      },
      {
        name: "shop_online",
        description: "Tool to buy products online",
        schema: z.object({
          product: z.string(),
          qty: z.number(),
          priceLimit: z.number().optional(),
        }),
      }
    );
    ```

    ### Update environment variables

    You need to [obtain an API Key from OpenAI](https://platform.openai.com/api-keys) or another provider to use an LLM.

    If you want to use an API, it must be [registered with Auth0](https://auth0.com/docs/get-started/apis) and have a valid audience.

    Update the `.env.local` file with the following variables:

    ```bash .env.local wrap lines theme={null}
    # ... existing variables
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY="YOUR_API_KEY"

    # API
    SHOP_API_URL=<your-shop-api-url>
    SHOP_API_AUDIENCE=sample-shop-api
    ```

    ### Require async authorization for your tool

    Call the tool from your AI app to make purchases. Update the `src/lib/agent.ts` file with the following code:

    ```ts src/lib/agent.ts wrap lines highlight={2,3,9} theme={null}
    //...
    import { withAsyncAuthorization } from "./auth0-ai";
    import { shopOnlineTool } from "./tools/shop-online";

    //... existing code

    const tools = [
      //... existing tools
      withAsyncAuthorization(shopOnlineTool),
    ];

    //... existing code
    ```

    ### Test the application

    Start the application with `npm run all:dev`. Then, navigate to `http://localhost:3000`.

    <Note>
      This will open the LangGraph Studio in a new tab. You can close it as we won't
      require it for testing the application.
    </Note>

    You can ask the AI agent to buy a product, for example, "Buy an XYZ phone." Now, look for a push notification from the [Auth0 Guardian app](https://auth0.com/docs/mfa/auth0-guardian/user-enrollment) or your custom app integrated with the [Auth0 Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian) on your mobile device. Once you approve the notification, you should see the tool being executed and a response from the agent.

    Explore the [example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/asynchronous-authorization/langchain-next-js).
  </Tab>

  <Tab title="Vercel AI + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    ### Install dependencies

    In the root directory of your project, install the following dependencies:

    * `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents powered by the Vercel AI SDK.
    * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module that interacts with various AI model providers.
    * `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider for the Vercel AI SDK.
    * `@ai-sdk/react`: [React](https://react.dev/) UI components for the Vercel AI SDK.
    * `zod`: TypeScript-first schema validation library.

    ```bash wrap lines theme={null}
    npm install @auth0/ai-vercel@4 ai@5.0.33 @ai-sdk/openai@2.0.24 @ai-sdk/react@2.0.33 zod@3.25.76
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env.local` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Set up Human-in-the-Loop approvals

    Integrate the Auth0 AI SDK into your application to secure your async AI agent workflow. For this quickstart, we will use a blocking request flow. In real use cases, often an asynchronous flow is preferred.

    #### Configure the Auth0 AI SDK

    To require asynchronous authorization for your tool, the tool needs to be wrapped with the Async authorizer, `withAsyncAuthorization()`. Let's create a helper function to wrap the tool with the Async authorizer.

    Create a file at `src/lib/auth0-ai.ts` and instantiate a new Auth0 AI SDK client:

    ```tsx src/lib/auth0-ai.ts wrap lines theme={null}
    import { Auth0AI } from "@auth0/ai-vercel";
    import { AccessDeniedInterrupt } from "@auth0/ai/interrupts";

    import { getUser } from "./auth0";

    const auth0AI = new Auth0AI();

    // Async Authorization flow for user confirmation
    export const withAsyncAuthorization = auth0AI.withAsyncAuthorization({
      userID: async () => {
        const user = await getUser();
        return user?.sub as string;
      },
      bindingMessage: async ({ product, qty }) =>
        `Do you want to buy ${qty} ${product}`,
      scopes: ["openid", "product:buy"], // add any scopes you want to use with your API
      audience: process.env["SHOP_API_AUDIENCE"]!,

      /**
       * Controls how long the authorization request is valid for.
       */
      // requestedExpiry: 301,

      /**
       * The behavior when the authorization request is made.
       *
       * - `block`: The tool execution is blocked until the user completes the authorization.
       * - `interrupt`: The tool execution is interrupted until the user completes the authorization.
       * - a callback: Same as "block" but give access to the auth request and executing logic.
       *
       * Defaults to `interrupt`.
       *
       * When this flag is set to `block`, the execution of the tool awaits
       * until the user approves or rejects the request.
       * Given the asynchronous nature of the CIBA flow, this mode
       * is only useful during development.
       *
       * In practice, the process that is awaiting the user confirmation
       * could crash or timeout before the user approves the request.
       */
      onAuthorizationRequest: async (authReq, creds) => {
        console.log(`An authorization request was sent to your mobile device.`);
        await creds;
        console.log(`Thanks for approving the order.`);
      },

      onUnauthorized: async (e: Error) => {
        if (e instanceof AccessDeniedInterrupt) {
          return "The user has denied the request";
        }
        return e.message;
      },
    });
    ```

    This will intercept the tool call to initiate a CIBA request:

    * The CIBA request includes the user ID that will approve the request.
    * Auth0 sends the user a mobile push notification. The AI agent polls the `/token` endpoint for a user response.
    * The mobile application retrieves the `bindingMessage` containing the consent details, in this case, the details of the product to purchase.
    * The user responds to the request:
      * If the request is approved, the tool execution will continue.
      * If the request is rejected, the tool execution will not continue.

    <Frame>
      <img alt="CIBA sequence diagram" />
    </Frame>

    Next, add the following code to `src/lib/auth0.ts`:

    ```tsx src/lib/auth0.ts wrap lines highlight={2-5} theme={null}
    //... existing code
    export const getUser = async () => {
      const session = await auth0.getSession();
      return session?.user;
    };
    ```

    #### Require async authorization for your tool

    In this example, we wrap a tool that buys products on the user's behalf. When the user approves the transaction, the Auth0 AI SDK retrieves an access token to call the shop's API. Upon completing the CIBA flow, the AI agent responds with a message confirming the purchase.

    The Auth0 AI SDK returns an error response if the user denies the transaction.

    Now, create and wrap the tool with the Async authorizer. Create a file `src/lib/tools/shop-online.ts` and add the following code:

    ```ts src/lib/tools/shop-online.ts wrap lines theme={null}
    import { tool } from "ai";
    import { z } from "zod";

    import { getAsyncAuthorizationCredentials } from "@auth0/ai-vercel";
    import { withAsyncAuthorization } from "../auth0-ai";

    export const shopOnlineTool = withAsyncAuthorization(
      tool({
        description: "Tool to buy products online",
        parameters: z.object({
          product: z.string(),
          qty: z.number(),
          priceLimit: z.number().optional(),
        }),
        execute: async ({ product, qty, priceLimit }) => {
          console.log(`Ordering ${qty} ${product} with price limit ${priceLimit}`);

          const apiUrl = process.env["SHOP_API_URL"]!;

          if (!apiUrl) {
            // No API set, mock a response or return error
            return `Ordered ${qty} ${product}`;
          }

          const headers = {
            "Content-Type": "application/json",
            Authorization: "",
          };
          const body = {
            product,
            qty,
            priceLimit,
          };

          const credentials = getAsyncAuthorizationCredentials();
          const accessToken = credentials?.accessToken;

          if (accessToken) {
            headers["Authorization"] = "Bearer " + accessToken;
          }

          const response = await fetch(apiUrl, {
            method: "POST",
            headers: headers,
            body: JSON.stringify(body),
          });

          return response.statusText;
        },
      })
    );
    ```

    ### Update environment variables

    You need to [obtain an API Key from OpenAI](https://platform.openai.com/api-keys) or another provider to use an LLM.

    If you want to use an API, it must be [registered with Auth0](https://auth0.com/docs/get-started/apis) and have a valid audience.

    Update the `.env.local` file with the following variables:

    ```bash .env.local wrap lines theme={null}
    # ... existing variables
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY="YOUR_API_KEY"

    # API (OPTIONAL)
    SHOP_API_URL=<your-shop-api-url>
    SHOP_API_AUDIENCE=sample-shop-api
    ```

    ### Integrate the tool into an AI agent

    Call the tool from your AI app to make purchases. Update the `src/app/api/chat/route.ts` file with the following code:

    ```ts src/app/api/chat/route.ts wrap lines highlight={2,3,11,13} theme={null}
    //...
    import { setAIContext } from "@auth0/ai-vercel";
    import { shopOnlineTool } from "@/lib/tools/shop-online";

    //...
    export async function POST(req: NextRequest) {
      const { id, messages }: { id: string; messages: Array<UIMessage> } = await req.json();

      const tools = { shopOnlineTool };

      setAIContext({ threadID: id });

      const stream = createUIMessageStream({
        async execute({ writer }) {
          const result = streamText({
            model: openai.chat('gpt-4o-mini'),
            system: AGENT_SYSTEM_TEMPLATE,
            messages: convertToModelMessages(messages),
            tools,
          });

          writer.merge(
            result.toUIMessageStream({
              sendReasoning: true,
            }),
          );
        },
      });

      return createUIMessageStreamResponse({ stream });
    }
    //...
    ```

    ### Test the application

    Start the application with `npm run dev`. Then, navigate to `http://localhost:3000`.

    You can ask the AI agent to buy a product, for example, "Buy an XYZ phone." Now, look for a push notification from the [Auth0 Guardian app](https://auth0.com/docs/mfa/auth0-guardian/user-enrollment) or your custom app integrated with the [Auth0 Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian) on your mobile device. Once you approve the notification, you should see the tool being executed and a response from the agent.

    Explore the [example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/asynchronous-authorization/vercel-ai-next-js).
  </Tab>

  <Tab title="LangGraph + FastAPI" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    The project is divided into two parts:

    * `backend/`: contains the backend code for the Web app and API written in Python using FastAPI and the LangGraph agent.
    * `frontend/`: contains the frontend code for the Web app written in React as a Vite SPA.

    ### Install dependencies

    In the `backend` directory of your project, install the following dependencies:

    * `auth0-ai-langchain`: [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-python/tree/main/packages/auth0-ai-langchain) built for AI agents powered by LangChain.
    * `langgraph`: [LangGraph](https://pypi.org/project/langgraph/) for building stateful, multi-factor applications with LLMs.
    * `langchain-openai`: LangChain integrations for OpenAI.
    * `langgraph-cli`: LangGraph CLI for running a local LangGraph server.

    Make sure you have [uv](https://docs.astral.sh/uv/) installed and run the following command to install the dependencies:

    ```bash wrap lines theme={null}
    cd backend
    uv sync
    uv add "auth0-ai-langchain>=1.0.0b5" "langgraph>=0.5.4" langchain-openai "langgraph-cli[inmem]>=0.3.6" --prerelease=allow
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Set up Human-in-the-Loop approvals

    Integrate the Auth0 AI SDK into your application to secure your async AI agent workflow. For this quickstart, we will use a blocking request flow. In real use cases, often an asynchronous flow is preferred.

    #### Configure the Auth0 AI SDK

    To require asynchronous authorization for your tool, the tool needs to be wrapped with the Async authorizer, `with_async_authorization()`. Let's create a helper function to wrap the tool with the Async authorizer.

    Create a file at `app/core/auth0_ai.py` and instantiate a new Auth0 AI SDK client:

    ```python app/core/auth0_ai.py wrap lines theme={null}
    from auth0_ai.authorizers.types import Auth0ClientParams
    from auth0_ai_langchain.auth0_ai import Auth0AI
    from langchain_core.runnables import ensure_config

    from app.core.config import settings

    auth0_ai = Auth0AI(
        Auth0ClientParams(
            {
                "domain": settings.AUTH0_DOMAIN,
                "client_id": settings.AUTH0_CLIENT_ID,
                "client_secret": settings.AUTH0_CLIENT_SECRET,
            }
        )
    )

    with_async_authorization = auth0_ai.with_async_authorization(
        audience=settings.SHOP_API_AUDIENCE,
        # param: scopes
        # add any scopes you want to use with your API
        scopes=["openid", "product:buy"],
        binding_message=lambda product, quantity: f"Do you want to buy {quantity} {product}",
        user_id=lambda *_, **__: ensure_config()
        .get("configurable")
        .get("_credentials")
        .get("user")
        .get("sub"),
        # param: requested_expiry
        # Controls how long the authorization request is valid.
        # requested_expiry=301,

        # param: on_authorization_request
        # When this flag is set to `block`, the execution of the tool awaits
        # until the user approves or rejects the request.
        #
        # Given the asynchronous nature of the CIBA flow, this mode
        # is only useful during development.
        #
        # In practice, the process that is awaiting the user confirmation
        # could crash or timeout before the user approves the request.
        on_authorization_request="block",

        # requested_expiry=301,
    )
    ```

    This will intercept the tool call to initiate an Async Authorization request:

    * The Async Authorization request includes the user ID that will approve the request.
    * Auth0 sends the user a mobile push notification. The AI agent polls the `/token` endpoint for a user response.
    * The mobile application retrieves the `bindingMessage` containing the consent details, in this case, the details of the product to purchase.
    * The user responds to the request:
      * If the request is approved, the tool execution will continue.
      * If the request is rejected, the tool execution will not continue.

    <Frame>
      <img alt="CIBA sequence diagram" />
    </Frame>

    #### Pass credentials to the tools

    Update the API route to pass the user session data to the agent in `app/api/routes/chat.py`:

    ```python app/api/routes/chat.py wrap lines highlight={2,9,21} theme={null}
    # ...
    from app.core.auth import auth_client
    # ...

    @agent_router.api_route(
        "/{full_path:path}", methods=["GET", "POST", "DELETE", "PATCH", "PUT", "OPTIONS"]
    )
    async def api_route(
        request: Request, full_path: str, auth_session=Depends(auth_client.require_session)
    ):
        try:
            # ... existing code

            # Prepare body
            body = await request.body()
            if request.method in ("POST", "PUT", "PATCH") and body:
                content = await request.json()
                content["config"] = {
                    "configurable": {
                        "_credentials": {
                            "user": auth_session.get("user"),
                        }
                    }
                }
                body = json.dumps(content).encode("utf-8")

                # ... existing code
    ```

    #### Create a tool to call your API

    In this example, we use a tool that buys products on the user's behalf. When the user approves the transaction, the Auth0 AI SDK retrieves an access token to call the shop's API. Upon completing the Async Authorization flow, the AI agent responds with a message confirming the purchase. The Auth0 AI SDK returns an error response if the user denies the transaction.

    Now, create a file `app/agents/tools/shop_online.py` and add the following code:

    ```python app/agents/tools/shop_online.py wrap lines theme={null}
    import httpx
    from langchain_core.tools import StructuredTool
    from auth0_ai_langchain.async_authorization import get_async_authorization_credentials
    from pydantic import BaseModel

    from app.core.auth0_ai import with_async_authorization
    from app.core.config import settings


    class BuyOnlineSchema(BaseModel):
        product: str
        quantity: int


    async def shop_online_fn(product: str, quantity: int):
        """Tool to buy products online."""

        api_url = settings.SHOP_API_URL

        if not api_url.strip():
            # No API set, mock a response
            return f"Ordered {quantity} {product}"

        credentials = get_async_authorization_credentials()

        if not credentials:
            raise ValueError("Async Authorization credentials not found")

        headers = {
            "Authorization": f"Bearer {credentials['access_token']}",
            "Content-Type": "application/json",
        }

        data = {
            "product": product,
            "quantity": quantity,
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    api_url,
                    headers=headers,
                    json=data,
                )

            if response.status_code != 200:
                raise ValueError(f"Failed to buy product: {response.text}")

            return response.json()

        except httpx.HTTPError as e:
            return {
                "success": False,
                "error": f"Failed to buy product: {str(e)}",
            }


    shop_online = with_async_authorization(
        StructuredTool(
            name="shop_online",
            description="Tool to buy products online.",
            args_schema=BuyOnlineSchema,
            coroutine=shop_online_fn,
        )
    )
    ```

    ### Update environment variables

    You need to [obtain an API Key from OpenAI](https://platform.openai.com/api-keys) to use an LLM.

    If you want to use an API, it must be [registered with Auth0](https://auth0.com/docs/get-started/apis) and have a valid audience.

    Update the `.env` file with the following variables:

    ```bash .env wrap lines theme={null}
    # ... existing variables
    # OpenAI API configuration
    OPENAI_API_KEY="YOUR_API_KEY"

    # Shop API configuration
    SHOP_API_URL=<your-shop-api-url>
    SHOP_API_AUDIENCE="https://api.shop-online-demo.com"
    ```

    Update your `app/core/config.py` to include the shop audience:

    ```python app/core/config.py wrap lines highlight={4,5} theme={null}
    # ...
    class Settings(BaseSettings):
        # ... existing code
        SHOP_API_URL: str = ""
        SHOP_API_AUDIENCE: str = ""
        # ... existing code
    ```

    ### Require async authorization for your tool

    Call the tool from your AI app to make purchases. Update the `app/agents/assistant0.py` file with the following code:

    ```python app/agents/assistant0.py wrap lines highlight={2,4} theme={null}
    # ...
    from app.agents.tools.shop_online import shop_online

    tools = [shop_online]

    llm = ChatOpenAI(model="gpt-4.1-mini")

    # ... existing code
    agent = create_react_agent(
        llm,
        tools=ToolNode(tools, handle_tool_errors=False),
        prompt=get_prompt(),
    )
    ```

    ### Test your application

    To test the application, start the FastAPI backend, LangGraph server, and the frontend:

    1. In a new terminal, start the FastAPI backend:

    ```bash wrap lines theme={null}
    cd backend
    source .venv/bin/activate
    fastapi dev app/main.py
    ```

    2. In another terminal, start the LangGraph server:

    ```bash wrap lines theme={null}
    cd backend
    source .venv/bin/activate
    uv pip install -U langgraph-api
    langgraph dev --port 54367 --allow-blocking
    ```

    <Note>
      This will open the LangGraph Studio in a new tab. You can close it as we won't
      require it for testing the application.
    </Note>

    3. In another terminal, start the frontend:

    ```bash wrap lines theme={null}
    cd frontend
    cp .env.example .env # Copy the `.env.example` file to `.env`.
    npm install
    npm run dev
    ```

    Visit the URL `http://localhost:5173` in your browser and interact with the AI agent.

    You can ask the AI agent to buy a product, for example, "Buy an XYZ phone." Now, look for a push notification from the [Auth0 Guardian app](https://auth0.com/docs/mfa/auth0-guardian/user-enrollment) or your custom app integrated with the [Auth0 Guardian SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian) on your mobile device. Once you approve the notification, you should see the tool being executed and a response from the agent.

    That's it! You've successfully integrated asynchronous authorization into your LangGraph FastAPI project.

    Explore the [example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/asynchronous-authorization/langchain-fastapi-py).
  </Tab>

  <Tab title="Vercel AI + Node.js" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
    <Prerequisites />

    ### Install dependencies

    Install the following dependencies:

    * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module that interacts with various AI model providers.
    * `zod`: TypeScript-first schema validation library.
    * `dotenv`: A module that loads environment variables from a `.env` file.
    * `auth0`: [Auth0 Node.js](https://github.com/auth0/node-auth0) library.
    * `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider for the [Vercel AI SDK](https://sdk.vercel.ai/docs).
    * `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents powered by the Vercel AI SDK.

    ```bash Create a new Node.js project wrap lines theme={null}
    npm init -y
    npm i auth0@5 @auth0/ai-vercel@4 zod@3.25.76 ai@5.0.33 @ai-sdk/openai@2.0.24 dotenv@16
    ```

    Add the below to `package.json`:

    ```json package.json wrap lines theme={null}
    "main": "index.js",
    "x-type": "module",
    "scripts": {
      "start": "npx tsx src/index.ts"
    },
    ```

    ### Integrate Auth0 AI SDK

    Integrate the [Auth0 AI SDK](https://github.com/auth0/auth0-ai-js) into your application to secure your async AI agent workflow.

    #### 1. Create your environment file

    In the root directory of your project, create the `.env` file and add the following variables. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ```bash .env wrap lines theme={null}
    AUTH0_DOMAIN='<your-auth0-domain>'
    AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
    AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY="YOUR_API_KEY"

    # API
    STOCK_API_URL=<your-stock-api-url>
    STOCK_API_AUDIENCE=sample-stock-api
    ```

    #### 2. Require async authorization for your tool

    To require asynchronous authorization for your tool wrap the tool with the Async authorizer, `withAsyncAuthorization()`.

    Wrap the tool with the Async authorizer in `src/lib/tools/buy.ts`. This will intercept the tool call to initiate an Async Authorization request:

    * The Async Authorization request includes the user ID that will approve the request.
    * Auth0 sends the user a mobile push notification. The AI agent polls the `/token` endpoint for a user response.
    * The mobile application retrieves the `binding_message` containing the consent details, in this case, the quantity of stock to purchase for a stock ticker.
    * The user responds to the request:
      * If the request is approved, the tool execution will continue.
      * If the request is rejected, the tool execution will not continue.

    <Frame>
      <img alt="CIBA sequence diagram" />
    </Frame>

    In our example, we wrap a tool that buys shares for a given stock picker on the user’s behalf. When the user approves the transaction, the Auth0 AI SDK retrieves an access token to call the stock’s API. Upon completing the CIBA flow, the AI agent responds with a message confirming the purchase.

    The Auth0 AI SDK returns an error response if the user denies the transaction.

    Now, create and wrap the tool with the Async authorizer. Create a file `src/lib/tools/buy.ts` and add the following code:

    ```ts src/lib/tools/buy.ts wrap lines theme={null}
    import "dotenv/config";

    import { tool } from "ai";
    import { z } from "zod";

    import { Auth0AI, getAsyncAuthorizationCredentials } from "@auth0/ai-vercel";
    import { AccessDeniedInterrupt } from "@auth0/ai/interrupts";
    export type Context = {
      userId: string;
    };

    const auth0AI = new Auth0AI();

    export const buy = (context: Context) => {
      // highlight-next-line
      const withAsyncAuthorization = auth0AI.withAsyncAuthorization({
        // highlight-next-line
        userID: context.userId,
        // highlight-next-line
        bindingMessage: async ({ ticker, qty }) =>
          // highlight-next-line
          `Do you want to buy ${qty} shares of ${ticker}`,
        scopes: ["openid", "stock:trade"],
        audience: process.env["STOCK_API_AUDIENCE"]!,

        /**
         * Controls how long the authorization request is valid for.
         */
        // requestedExpiry: 301,

        /**
         * The behavior when the authorization request is made.
         *
         * - `block`: The tool execution is blocked until the user completes the authorization.
         * - `interrupt`: The tool execution is interrupted until the user completes the authorization.
         * - a callback: Same as "block" but give access to the auth request and executing logic.
         *
         * Defaults to `interrupt`.
         *
         * When this flag is set to `block`, the execution of the tool awaits
         * until the user approves or rejects the request.
         * Given the asynchronous nature of the CIBA flow, this mode
         * is only useful during development.
         *
         * In practice, the process that is awaiting the user confirmation
         * could crash or timeout before the user approves the request.
         */
        onAuthorizationRequest: async (_authReq, creds) => {
          console.log(
            `An authorization request was sent to your mobile device.`
          );
          await creds;
          console.log(`Thanks for approving the order.`);
        },

        onUnauthorized: async (e: Error) => {
          if (e instanceof AccessDeniedInterrupt) {
            return "The user has deny the request";
          }
          return e.message;
        },
      });

      return withAsyncAuthorization(
        tool({
          description: "Use this function to buy stock",
          inputSchema: z.object({
            ticker: z.string(),
            qty: z.number(),
          }),
          execute: async ({ ticker, qty }) => {
            const headers = {
              "Content-Type": "application/json",
            };
            const body = {
              ticker: ticker,
              qty: qty,
            };
            // highlight-next-line
            const credentials = getAsyncAuthorizationCredentials();
            const accessToken = credentials?.accessToken?.value;

            if (accessToken) {
              headers["Authorization"] = "Bearer " + accessToken;
            }

            console.log("Executing request to buy stock");

            const response = await fetch(process.env["STOCK_API_URL"]!, {
              method: "POST",
              headers: headers,
              body: JSON.stringify(body),
            });

            return response.statusText;
          },
        })
      );
    };
    ```

    #### 3. Integrate the tool into an AI agent

    Create a file at `src/index.ts` and add tool calling to the Vercel AI agent using the `generateText()` or `streamText()` functions:

    ```ts src/index.ts wrap lines theme={null}
    import { setAIContext } from "@auth0/ai-vercel";
    import crypto from "node:crypto";
    import { generateText, stepCountIs } from "ai";
    import { openai } from "@ai-sdk/openai";

    import { buy } from "./lib/tools/buy";

    async function main() {
      const threadID = crypto.randomUUID();
      setAIContext({ threadID });

      const userPrompt = "Use the buy tool to purchase 3 shares of Google (GOOGL) stock";

      const { text } = await generateText({
        model: openai("gpt-4o-mini"),
        system: "You are an assistant. Invoke the tool if needed, then respond with a past-tense confirmation.",
        prompt: userPrompt,
        // pass an Auth0 user id. For example, 'auth0|100000000000000000000' or 'google-oauth2|100000000000000000000'
        tools: { buy: buy({ userId: "<authenticated-user-id>" }) },
        stopWhen: stepCountIs(3), // tool call + result + final assistant message
      });

      console.log("Final response:", (text && text.trim()) || "<empty>");
    }

    main().catch(console.error);
    ```

    You should now have a CLI app that allows you to interact with the AI agent.

    ### Test the application

    To test the CLI app, set a prompt, such as "Buy 3 stocks of Google," and pass it the user ID of the user approving or declining the transaction. You can get the user ID from the [Auth0 Dashboard](https://manage.auth0.com/).

    To get the user ID, navigate to **User Management** > **Users** and click on a user. The ID should look like `auth0|123456789`.

    Now, run `npm start` and look for a push notification from the Auth0 Guardian app or your [custom app integrated with the Auth0 Guardian SDK](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow/user-authorization-with-ciba) on your mobile device. Once you approve the notification, you should see the tool being executed on your console.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/asynchronous-authorization/vercel-ai-node-js).
  </Tab>
</Tabs>

## Next steps

You have successfully added an authorization step to protect tool calling in asynchronous AI agents. For next steps:

* [Asynchronous Authorization docs](/intro/asynchronous-authorization).
* Learn more about the [Client-Initiated Backchannel Authentication Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow).
* Learn how to [Configure Rich Authorization Requests](https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests).
* Learn more about [Auth0 Guardian Android SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-android-sdk).
* Learn more about [Auth0 Guardian iOS SDK](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian/guardian-for-ios-sdk).


# Authorization for RAG
Source: https://auth0.com/ai/docs/get-started/authorization-for-rag

Learn how Auth0 for AI Agents enables AI agents to implement fine-grained authorization for Retrieval Augmented Generation (RAG).

Auth0 for AI Agents leverages [Auth0 FGA](https://auth0.com/fine-grained-authorization) to provide fine-grained authorization control for AI agents. As a result, when AI agents use Retrieval Augmented Generation (RAG) to provide sophisticated, relevant responses to user queries, they only have access to authorized data.

By the end of this quickstart, you should have an AI application that can:

1. Retrieve authorized data as context for a RAG pipeline.
2. Use Auth0 FGA to determine if the user has authorization for the data.

## Pick your tech stack

<Tabs>
  <Tab title="LangGraph.js + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    ### Install dependencies

    In the root directory of your project, install the following dependencies:

    * `@auth0/ai-langchain`: [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-langchain) built for AI agents powered by LangChain.
    * `@langchain/langgraph`: For building stateful, multi-actor applications with LLMs.
    * `langchain`: The LangChain library.
    * `@langchain/core`: Core LangChain dependencies.
    * `@langchain/openai`: [OpenAI](https://js.langchain.com/docs/integrations/chat/openai) provider for LangChain.
    * `zod`: TypeScript-first schema validation library.
    * `langgraph-nextjs-api-passthrough`: API passthrough for LangGraph.

    ```bash wrap lines theme={null}
    npm install @auth0/ai-langchain@4 @langchain/core@0.3.77 @langchain/langgraph@0.4.4 @langchain/openai@0.6.13 langchain@0.3.12 langgraph-nextjs-api-passthrough@0.1.4
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env.local` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Set up an FGA Store

    In the [Auth0 FGA dashboard](https://dashboard.fga.dev/):

    <Steps>
      <Step>
        Navigate to **Settings**. In the **Authorized Clients** section, click **+
        Create Client**.
      </Step>

      <Step>
        Give your client a name and mark all the client permissions that are
        required for your use case. For the quickstart, you'll only need **Read and
        query**.
      </Step>

      <Step>
        Click **Create**.

        <Frame>
          <img alt="Set up FGA Store" />
        </Frame>
      </Step>
    </Steps>

    Once your client is created, you'll see a modal containing Store ID, Client ID, and Client Secret. Add or update an `.env.local` file with the following content to the root directory of the project. Click **Continue** to see the `FGA_API_URL` and `FGA_API_AUDIENCE.`

    The confirmation dialog will provide you with all the information that you need for your environment file.

    ```bash .env.local wrap lines theme={null}
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY=<your-openai-api-key>

    # Auth0 FGA
    FGA_STORE_ID=<your-fga-store-id>
    FGA_CLIENT_ID=<your-fga-store-client-id>
    FGA_CLIENT_SECRET=<your-fga-store-client-secret>
    FGA_API_URL=https://api.xxx.fga.dev
    FGA_API_AUDIENCE=https://api.xxx.fga.dev/
    ```

    Next, navigate to **Model Explorer**. You'll need to update the model information with this:

    ```bash wrap lines theme={null}
    model
      schema 1.1

    type user

    type doc
      relations
        define owner: [user]
        define viewer: [user, user:*]
    ```

    Remember to click **Save**.

    ### Secure the RAG Tool

    After configuring your FGA Store, secure the RAG tool using Auth0 FGA and Auth0 AI SDK.

    The starter application is already configured to handle documents and embeddings.

    **Document Upload and Storage**

    * You can upload documents through the UI (`src/app/documents/page.tsx`).
    * Uploaded documents are processed by the API route (`src/app/api/documents/upload/route.ts`).
    * APIs for uploading and retrieving documents are defined in (`src/lib/actions/documents.ts`).
    * Database is defined in `src/lib/db`.
    * FGA helpers are defined in `src/lib/fga`.
    * Documents are stored as embeddings in a vector database for efficient retrieval (`src/lib/rag/embedding.ts`).

    **Access Control with Auth0 FGA**

    * When a document is uploaded, the app automatically creates [FGA tuples](https://docs.fga.dev/fga-concepts#what-is-a-relationship-tuple) to define which users can access which documents. A tuple signifies a user's relation to a given object. For example, the below tuple implies that all users can view the `<document name>` object.
    * Navigate to the **Tuple Management** section to see the tuples being added. If you want to add a tuple manually for a document, click **+ Add Tuple**. Fill in the following information:
      * **User**: `user:*`
      * **Object**: select doc and add `<document name>` in the ID field
      * **Relation**: `viewer`

    #### Create a RAG tool

    Define a RAG tool that uses the `FGAFilter` to filter authorized data from the vector database:

    ```tsx src/lib/tools/context-docs.ts wrap lines theme={null}
    import { tool } from "@langchain/core/tools";
    import { z } from "zod";
    import { FGARetriever } from "@auth0/ai-langchain/RAG";

    import { getVectorStore } from "@/lib/rag/embedding";

    export const getContextDocumentsTool = tool(
      async ({ question }, config) => {
        const user = config?.configurable?._credentials?.user;

        if (!user) {
          return "There is no user logged in.";
        }

        const vectorStore = await getVectorStore();

        if (!vectorStore) {
          return "There is no vector store.";
        }

        const retriever = FGARetriever.create({
          retriever: vectorStore.asRetriever(),
          buildQuery: (doc) => ({
            user: `user:${user?.email}`,
            object: `doc:${doc.metadata.documentId}`,
            relation: "can_view",
          }),
        });

        // filter docs based on FGA authorization
        const documents = await retriever.invoke(question);
        return documents.map((doc) => doc.pageContent).join("\n\n");
      },
      {
        name: "get_context_documents",
        description:
          "Use the tool when user asks for documents or projects or anything that is stored in the knowledge base.",
        schema: z.object({
          question: z.string().describe("the users question"),
        }),
      }
    );
    ```

    #### Use the RAG tool from AI agent

    Call the tool from your AI agent to get data from documents. First, update the `/src/app/api/chat/[..._path]/route.ts` file with the following code to pass the user credentials to your agent:

    ```ts src/app/api/chat/[..._path]/route.ts wrap lines highlight={3,19,31} theme={null}
    import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";

    import { getUser, getAccessToken } from "@/lib/auth0";

    export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
      initApiPassthrough({
        apiUrl: process.env.LANGGRAPH_API_URL,
        baseRoute: "chat/",
        bodyParameters: async (req, body) => {
          if (
            req.nextUrl.pathname.endsWith("/runs/stream") &&
            req.method === "POST"
          ) {
            return {
              ...body,
              config: {
                configurable: {
                  _credentials: {
                    user: await getUser(),
                  },
                },
              },
            };
          }

          return body;
        },
        headers: async () => {
          const accessToken = await getAccessToken();
          return {
            Authorization: `Bearer ${accessToken}`,
          };
        },
      });
    ```

    Next, add the following code to `src/lib/auth0.ts`:

    ```tsx src/lib/auth0.ts wrap lines highlight={13-21,23-26} theme={null}
    import { Auth0Client } from '@auth0/nextjs-auth0/server';

    export const auth0 = new Auth0Client({
      authorizationParameters: {
        // In v4, the AUTH0_SCOPE and AUTH0_AUDIENCE environment variables are no longer automatically picked up by the SDK.
        // Instead, we need to provide the values explicitly.
        scope: process.env.AUTH0_SCOPE,
        audience: process.env.AUTH0_AUDIENCE,
      },
    });

    // Get the Access token from Auth0 session
    export const getAccessToken = async () => {
      const tokenResult = await auth0.getAccessToken();

      if(!tokenResult || !tokenResult.token) {
        throw new Error("No access token found in Auth0 session");
      }

      return tokenResult.token;
    };

    export const getUser = async () => {
      const session = await auth0.getSession();
      return session?.user;
    };
    ```

    ### Add Custom Authentication

    <Info>
      For more information on how to add custom authentication for your LangGraph Platform application, read the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
    </Info>

    In your `langgraph.json`, add the path to your auth file:

    ```typescript langgraph.json wrap lines highlight={8} theme={null}
    {
      "node_version": "20",
      "graphs": {
        "agent": "./src/lib/agent.ts:agent"
      },
      "env": ".env",
      "auth": {
        "path": "./src/lib/auth.ts:authHandler"
      }
    }
    ```

    Then, in your `auth.ts` file, add your auth logic:

    ```typescript src/lib/auth.ts wrap lines theme={null}
    import { createRemoteJWKSet, jwtVerify } from "jose";

    const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

    const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
    const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

    // JWKS endpoint for Auth0
    const JWKS = createRemoteJWKSet(
      new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
    );

    // Create the Auth instance
    const auth = new Auth();
    // Register the authentication handler
    auth.authenticate(async (request: Request) => {
      const authHeader = request.headers.get("Authorization");
      const xApiKeyHeader = request.headers.get("x-api-key");
        /**
         * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
         * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
         *
         * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
         * or when running locally.
         */
        // This header is required in Langgraph Cloud.
        if (!authHeader && !xApiKeyHeader) {
          throw new HTTPException(401, {
            message: "Invalid auth header provided.",
          });
        }

        // prefer the xApiKeyHeader first
        let token = xApiKeyHeader || authHeader;

        // Remove "Bearer " prefix if present
        if (token && token.startsWith("Bearer ")) {
          token = token.substring(7);
        }

        // Validate Auth0 Access Token using common JWKS endpoint
        if (!token) {
          throw new HTTPException(401, {
            message:
              "Authorization header format must be of the form: Bearer <token>",
          });
        }

        if (token) {
          try {
            // Verify the JWT using Auth0 JWKS
            const { payload } = await jwtVerify(token, JWKS, {
              issuer: `https://${AUTH0_DOMAIN}/`,
              audience: AUTH0_AUDIENCE,
            });

            console.log("✅ Auth0 JWT payload resolved!", payload);

            // Return the verified payload - this becomes available in graph nodes
            return {
              identity: payload.sub!,
              email: payload.email as string,
              permissions:
                typeof payload.scope === "string" ? payload.scope.split(" ") : [],
              auth_type: "auth0",
              // include the access token for use with Auth0 Token Vault exchanges by tools
              getRawAccessToken: () => token,
              // Add any other claims you need
              ...payload,
            };
          } catch (jwtError) {
            console.log(
              "Auth0 JWT validation failed:",
              jwtError instanceof Error ? jwtError.message : "Unknown error"
            );
            throw new HTTPException(401, {
              message: "Invalid Authorization token provided.",
            });
          }
        }
    });

    export { auth as authHandler };
    ```

    Now, update the `src/lib/agent.ts` file with the following code to add the tool to your agent:

    ```ts src/lib/agent.ts wrap lines highlight={1,7} theme={null}
    import { getContextDocumentsTool } from "./tools/context-docs";

    //... existing code

    const tools = [
      //... existing tools
      getContextDocumentsTool,
    ];
    //... existing code
    ```

    ### Test your application

    Start the database and create required tables:

    ```bash wrap lines theme={null}
    # start the postgres database
    docker compose up -d
    # create the database schema
    npm run db:migrate
    ```

    Start the application with `npm run all:dev`. Then, navigate to `http://localhost:3000`.

    <Note>
      This will open the LangGraph Studio in a new tab. You can close it as we won't
      require it for testing the application.
    </Note>

    Upload a document from the documents tab and ask your AI agent a question about the document. You should get a response with the relevant information.

    Go to an incognito window, log in as a different user, and ask it the same question. You should not get a response.

    Share the document from the documents page to the second user and try again. You should see the information now.

    That's it! You successfully integrated RAG protected by Auth0 FGA into your project.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/authorization-for-rag/langchain-next-js).
  </Tab>

  <Tab title="Vercel AI + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    ### Install dependencies

    In the root directory of your project, install the following dependencies:

    * `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents powered by the Vercel AI SDK.
    * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module that interacts with various AI model providers.
    * `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider for the Vercel AI SDK.
    * `@ai-sdk/react`: [React](https://react.dev/) UI components for the Vercel AI SDK.
    * `zod`: TypeScript-first schema validation library.

    ```bash wrap lines theme={null}
    npm install @auth0/ai-vercel@4 ai@5.0.33 @ai-sdk/openai@2.0.24 @ai-sdk/react@2.0.33 zod@3.25.76
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env.local` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Set up an FGA Store

    In the [Auth0 FGA dashboard](https://dashboard.fga.dev/):

    <Steps>
      <Step>
        Navigate to **Settings**. In the **Authorized Clients** section, click **+
        Create Client**.
      </Step>

      <Step>
        Give your client a name and mark all the client permissions that are
        required for your use case. For the quickstart, you'll only need **Read and
        query**.
      </Step>

      <Step>
        Click **Create**.

        <Frame>
          <img alt="Set up FGA Store" />
        </Frame>
      </Step>
    </Steps>

    Once your client is created, you'll see a modal containing Store ID, Client ID, and Client Secret. Add or update an `.env.local` file with the following content to the root directory of the project. Click **Continue** to see the `FGA_API_URL` and `FGA_API_AUDIENCE.`

    The confirmation dialog will provide you with all the information that you need for your environment file.

    ```bash .env.local wrap lines theme={null}
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY=<your-openai-api-key>

    # Auth0 FGA
    FGA_STORE_ID=<your-fga-store-id>
    FGA_CLIENT_ID=<your-fga-store-client-id>
    FGA_CLIENT_SECRET=<your-fga-store-client-secret>
    FGA_API_URL=https://api.xxx.fga.dev
    FGA_API_AUDIENCE=https://api.xxx.fga.dev/
    ```

    Next, navigate to **Model Explorer**. You'll need to update the model information with this:

    ```bash wrap lines theme={null}
    model
      schema 1.1

    type user

    type doc
      relations
        define owner: [user]
        define viewer: [user, user:*]
    ```

    Remember to click **Save**.

    ### Secure the RAG Tool

    After configuring your FGA Store, secure the RAG tool using Auth0 FGA and Auth0 AI SDK.

    The starter application is already configured to handle documents and embeddings.

    **Document Upload and Storage**

    * You can upload documents through the UI (`src/app/documents/page.tsx`).
    * Uploaded documents are processed by the API route (`src/app/api/documents/upload/route.ts`).
    * APIs for uploading and retrieving documents are defined in (`src/lib/actions/documents.ts`).
    * Database is defined in `src/lib/db`.
    * FGA helpers are defined in `src/lib/fga`.
    * Documents are stored as embeddings in a vector database for efficient retrieval (`src/lib/rag/embedding.ts`).

    **Access Control with Auth0 FGA**

    * When a document is uploaded, the app automatically creates [FGA tuples](https://docs.fga.dev/fga-concepts#what-is-a-relationship-tuple) to define which users can access which documents. A tuple signifies a user's relation to a given object. For example, the below tuple implies that all users can view the `<document name>` object.
    * Navigate to the **Tuple Management** section to see the tuples being added. If you want to add a tuple manually for a document, click **+ Add Tuple**. Fill in the following information:
      * **User**: `user:*`
      * **Object**: select doc and add `<document name>` in the ID field
      * **Relation**: `viewer`

    #### Create a RAG tool

    Define a RAG tool that uses the `FGAFilter` to filter authorized data from the vector database:

    ```tsx src/lib/tools/context-docs.ts wrap lines theme={null}
    import { tool } from "ai";
    import { z } from "zod";
    import { FGAFilter } from "@auth0/ai";

    import { findRelevantContent } from "@/lib/rag/embedding";
    import { auth0 } from "../auth0";

    export type DocumentWithScore = {
      content: string;
      documentId: string;
      similarity: number;
    };

    export const getContextDocumentsTool = tool({
      description:
        "Use the tool when user asks for documents or projects or anything that is stored in the knowledge base.",
      parameters: z.object({
        question: z.string().describe("the users question"),
      }),
      execute: async ({ question }) => {
        const session = await auth0.getSession();
        const user = session?.user;

        if (!user) {
          return "There is no user logged in.";
        }

        const retriever = FGAFilter.create({
          buildQuery: (doc: DocumentWithScore) => ({
            user: `user:${user?.email}`,
            object: `doc:${doc.documentId}`,
            relation: "can_view",
          }),
        });

        const documents = await findRelevantContent(question, 25);
        // filter docs based on FGA authorization
        const context = await retriever.filter(documents);
        return context;
      },
    });
    ```

    #### Use the RAG tool from AI agent

    Call the tool from your AI agent to get data from documents. Update the `/src/app/api/chat/route.ts` file with the following code:

    ```ts src/app/api/chat/route.ts wrap lines highlight={2,8} theme={null}
    //...
    import { getContextDocumentsTool } from "@/lib/tools/context-docs";

    //... existing code
    export async function POST(req: NextRequest) {
      //... existing code
      const tools = {
        getContextDocumentsTool,
      };

      return createDataStreamResponse({
        execute: async (dataStream: DataStreamWriter) => {
          const result = streamText({
            model: openai("gpt-4o-mini"),
            system: AGENT_SYSTEM_TEMPLATE,
            messages,
            maxSteps: 5,
            tools,
          });

          result.mergeIntoDataStream(dataStream, {
            sendReasoning: true,
          });
        },
        onError: (err: any) => {
          console.log(err);
          return `An error occurred! ${err.message}`;
        },
      });
    }
    ```

    ### Test your application

    Start the database and create required tables:

    ```bash wrap lines theme={null}
    # start the postgres database
    docker compose up -d
    # create the database schema
    npm run db:migrate
    ```

    Start the application with `npm run dev`. Then, navigate to `http://localhost:3000`.
    Upload a document from the documents tab and ask your AI Agent a question about the document. You should get a response with the relevant information.

    Go to an incognito window, log in as a different user, and ask it the same question. You should not get a response.

    Share the document from the documents page to the second user and try again. You should see the information now.

    That's it! You successfully integrated RAG protected by Auth0 FGA into your project.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/authorization-for-rag/vercel-ai-next-js).
  </Tab>

  <Tab title="LangGraph + FastAPI" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    The project is divided into two parts:

    * `backend/`: contains the backend code for the Web app and API written in Python using FastAPI and the LangGraph agent.
    * `frontend/`: contains the frontend code for the Web app written in React as a Vite SPA.

    ### Install dependencies

    In the `backend` directory of your project, install the following dependencies:

    * `auth0-ai-langchain`: [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-python/tree/main/packages/auth0-ai-langchain) built for AI agents powered by LangChain.
    * `langgraph`: [LangGraph](https://pypi.org/project/langgraph/) for building stateful, multi-actor applications with LLMs.
    * `langchain-openai`: [OpenAI](https://python.langchain.com/docs/integrations/chat/openai) provider for LangChain.
    * `langgraph-cli`: LangGraph CLI for running a local LangGraph server.
    * `openfga-sdk`: OpenFGA SDK for Fine-Grained Authorization.

    Make sure you have [uv](https://docs.astral.sh/uv/) installed and run the following command to install the dependencies:

    ```bash wrap lines theme={null}
    cd backend
    uv sync
    uv add "auth0-ai-langchain>=1.0.0b5" openfga-sdk langgraph langchain-openai "langgraph-cli[inmem]" --prerelease=allow
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Set up an FGA Store

    In the [Auth0 FGA dashboard](https://dashboard.fga.dev/):

    <Steps>
      <Step>
        Navigate to **Settings**. In the **Authorized Clients** section, click **+
        Create Client**.
      </Step>

      <Step>
        Give your client a name and mark all the client permissions that are
        required for your use case. For the quickstart, you'll only need **Read and
        query**.
      </Step>

      <Step>
        Click **Create**.

        <Frame>
          <img alt="Set up FGA Store" />
        </Frame>
      </Step>
    </Steps>

    Once your client is created, you'll see a modal containing Store ID, Client ID, and Client Secret. Add or update an `.env.local` file with the following content to the root directory of the project. Click **Continue** to see the `FGA_API_URL` and `FGA_API_AUDIENCE.`

    The confirmation dialog will provide you with all the information that you need for your environment file.

    ```bash .env.local wrap lines theme={null}
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY=<your-openai-api-key>

    # Auth0 FGA
    FGA_STORE_ID=<your-fga-store-id>
    FGA_CLIENT_ID=<your-fga-store-client-id>
    FGA_CLIENT_SECRET=<your-fga-store-client-secret>
    FGA_API_URL=https://api.xxx.fga.dev
    FGA_API_AUDIENCE=https://api.xxx.fga.dev/
    ```

    Next, navigate to **Model Explorer**. You'll need to update the model information with this:

    ```bash wrap lines theme={null}
    model
      schema 1.1

    type user

    type doc
      relations
        define owner: [user]
        define viewer: [user, user:*]
    ```

    Remember to click **Save**.

    ### Secure the RAG tool

    After configuring your FGA Store, secure the RAG tool using Auth0 FGA and Auth0 AI SDK.

    The starter application is already configured to handle documents and embeddings.

    **Document Upload and Storage**

    * You can upload documents through the API endpoints (`backend/app/api/routes/documents.py`).
    * Uploaded documents are processed and stored with embeddings for efficient retrieval.
    * APIs for uploading and retrieving documents are defined in the application routes.
    * Database models are defined in `backend/app/models`.
    * FGA helpers are implemented in `backend/app/core/fga.py`.
    * Documents are stored as embeddings in a PostgreSQL vector database (`backend/app/core/rag.py`).

    **Access Control with Auth0 FGA**

    * When a document is uploaded, the app automatically creates [FGA tuples](https://docs.fga.dev/fga-concepts#what-is-a-relationship-tuple) to define which users can access which documents. A tuple signifies a user's relation to a given object. For example, the below tuple implies that all users can view the `<document name>` object.
    * Navigate to the **Tuple Management** section to see the tuples being added. If you want to manually add a tuple for a document, click **+ Add Tuple**. Fill in the following information:
      * **User**: `user:*`
      * **Object**: select doc and add `<document name>` in the ID field
      * **Relation**: `viewer`

    #### Create a RAG tool

    Define a RAG tool that uses the `FGARetriever` to filter authorized data from the vector database:

    ```python backend/app/agents/tools/context_docs.py wrap lines theme={null}
    from langchain_core.runnables import RunnableConfig
    from langchain_core.tools import StructuredTool
    from auth0_ai_langchain import FGARetriever
    from openfga_sdk.client.models import ClientBatchCheckItem
    from pydantic import BaseModel

    from app.core.rag import get_vector_store

    class GetContextDocsSchema(BaseModel):
        question: str


    async def get_context_docs_fn(question: str, config: RunnableConfig):
        """Use the tool when user asks for documents or projects or anything that is stored in the knowledge base"""

        if "configurable" not in config or "_credentials" not in config["configurable"]:
            return "There is no user logged in."

        credentials = config["configurable"]["_credentials"]
        user = credentials.get("user")

        if not user:
            return "There is no user logged in."

        user_email = user.get("email")
        vector_store = await get_vector_store()

        if not vector_store:
            return "There is no vector store."

        retriever = FGARetriever(
            retriever=vector_store.as_retriever(),
            build_query=lambda doc: ClientBatchCheckItem(
                user=f"user:{user_email}",
                object=f"doc:{doc.metadata.get('document_id')}",
                relation="can_view",
            ),
        )

        documents = retriever.invoke(question)
        return "\n\n".join([document.page_content for document in documents])


    get_context_docs = StructuredTool(
        name="get_context_docs",
        description="Use the tool when user asks for documents or projects or anything that is stored in the knowledge base",
        args_schema=GetContextDocsSchema,
        coroutine=get_context_docs_fn,
    )
    ```

    #### Use the RAG tool from AI agent

    Call the tool from your AI agent to get data from documents. First, update the `backend/app/api/routes/chat.py` file with the following code to pass the user credentials to your agent:

    ```python backend/app/api/routes/chat.py wrap lines highlight={2,9,21} theme={null}
    # ...
    from app.core.auth import auth_client
    # ...

    @agent_router.api_route(
        "/{full_path:path}", methods=["GET", "POST", "DELETE", "PATCH", "PUT", "OPTIONS"]
    )
    async def api_route(
        request: Request, full_path: str, auth_session=Depends(auth_client.require_session)
    ):
        try:
            # ... existing code

            # Prepare body
            body = await request.body()
            if request.method in ("POST", "PUT", "PATCH") and body:
                content = await request.json()
                content["config"] = {
                    "configurable": {
                        "_credentials": {
                            "user": auth_session.get("user"),
                        }
                    }
                }
                body = json.dumps(content).encode("utf-8")

                # ... existing code
    ```

    Now, update the `backend/app/agents/assistant0.py` file with the following code to add the tool to your agent:

    ```python backend/app/agents/assistant0.py wrap lines highlight={2,4} theme={null}
    # ...
    from app.agents.tools.context_docs import get_context_docs

    tools = [get_context_docs]

    llm = ChatOpenAI(model="gpt-4.1-mini")

    # ... existing code
    agent = create_react_agent(
        llm,
        tools=ToolNode(tools, handle_tool_errors=False),
        prompt=get_prompt(),
    )
    ```

    ### Test your application

    To test the application, start the database, FastAPI backend, LangGraph server, and the frontend:

    1. Start the FastAPI backend:

    ```bash wrap lines theme={null}
    cd backend
    # start the postgres database
    docker compose up -d
    # start the FastAPI backend
    source .venv/bin/activate
    fastapi dev app/main.py
    ```

    2. In another terminal, start the LangGraph server:

    ```bash wrap lines theme={null}
    cd backend
    source .venv/bin/activate
    uv pip install -U langgraph-api
    langgraph dev --port 54367 --allow-blocking
    ```

    <Note>
      This will open the LangGraph Studio in a new tab. You can close it as we won't
      require it for testing the application.
    </Note>

    3. In another terminal, start the frontend:

    ```bash wrap lines theme={null}
    cd frontend
    cp .env.example .env # Copy the `.env.example` file to `.env`.
    npm install
    npm run dev
    ```

    Visit the URL `http://localhost:5173` in your browser.
    Upload a document from the documents tab and ask your AI agent a question about the document. You should get a response with the relevant information.

    Go to an incognito window, log in as a different user, and ask it the same question. You should not get a response.

    Share the document from the documents page to the second user and try again. You should see the information now.

    That's it! You successfully integrated RAG protected by Auth0 FGA into your project.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/authorization-for-rag/langchain-fastapi-py).
  </Tab>

  <Tab title="LangGraph.js + Node.js" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Install dependencies

    As a first step, let's get all dependencies installed:

    ```bash Create a new Node.js project wrap lines theme={null}
    npm init -y
    npm install langchain@0.3 @langchain/langgraph@0.2 @auth0/ai-langchain@4 dotenv@16
    ```

    ### Set up an FGA Store

    In the [Auth0 FGA dashboard](https://dashboard.fga.dev/):

    <Steps>
      <Step>
        Navigate to **Settings**. In the **Authorized Clients** section, click **+
        Create Client**.
      </Step>

      <Step>
        Give your client a name and mark all the client permissions that are
        required for your use case. For the quickstart, you'll only need **Read and
        query**.
      </Step>

      <Step>
        Click **Create**.

        <Frame>
          <img alt="Set up FGA Store" />
        </Frame>
      </Step>
    </Steps>

    Once your client is created, you'll see a modal containing Store ID, Client ID, and Client Secret. Add or update an `.env.local` file with the following content to the root directory of the project. Click **Continue** to see the `FGA_API_URL` and `FGA_API_AUDIENCE.`

    The confirmation dialog will provide you with all the information that you need for your environment file.

    ```bash .env.local wrap lines theme={null}
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY=<your-openai-api-key>

    # Auth0 FGA
    FGA_STORE_ID=<your-fga-store-id>
    FGA_CLIENT_ID=<your-fga-store-client-id>
    FGA_CLIENT_SECRET=<your-fga-store-client-secret>
    FGA_API_URL=https://api.xxx.fga.dev
    FGA_API_AUDIENCE=https://api.xxx.fga.dev/
    ```

    Next, navigate to **Model Explorer**. You'll need to update the model information with this:

    ```bash wrap lines theme={null}
    model
      schema 1.1

    type user

    type doc
      relations
        define owner: [user]
        define viewer: [user, user:*]
    ```

    Remember to click **Save**.

    Now, to access public information, you'll need to add a tuple on FGA. Navigate to the **Tuple Management** section and click **+ Add Tuple**. Fill in the following information:

    * **User**: `user:*`
    * **Object**: select doc and add `public-doc` in the ID field
    * **Relation**: `viewer`

    A tuple signifies a user's relation to a given object. For example, the above tuple implies that all users can view the `public-doc` object.

    ### Secure the RAG Tool

    After configuring your FGA Store, let’s get back to our node.js project. There you’ll secure the RAG tool using [Auth0 FGA](https://auth0.com/fine-grained-authorization) and [Auth0 AI SDK](https://github.com/auth0/auth0-ai-python).

    ### Get the Assets

    Create an `assets` folder and download the below files into the folder:

    * [`public-doc.md`](https://raw.githubusercontent.com/auth0-samples/auth0-ai-samples/refs/heads/main/authorization-for-rag/langgraph-agentic-js/assets/docs/public-doc.md)
    * [`private-doc.md`](https://raw.githubusercontent.com/auth0-samples/auth0-ai-samples/refs/heads/main/authorization-for-rag/langgraph-agentic-js/assets/docs/private-doc.md)

    ### Create helper functions

    Create a LangGraph agent and other helper functions that are needed to load documents.

    The first helper will create an in-memory vector store using `faiss` and `OpenAIEmbeddings`. You can replace this module with your own store, as long as it follows the LangChain retriever specification.

    ```ts helpers.ts wrap lines theme={null}
    import fs from "node:fs/promises";
    import { StructuredToolInterface } from "@langchain/core/tools";
    import { createReactAgent } from "@langchain/langgraph/prebuilt";
    import { ChatOpenAI } from "@langchain/openai";
    import { Document } from "@langchain/core/documents";

    export class RetrievalAgent {
      private agent;

      private constructor(agent) {
        this.agent = agent;
      }

      // Create a retrieval agent with a retriever tool and a language model
      static create(tools: StructuredToolInterface[]) {
        // Create a retrieval agent that has access to the retrieval tool.
        const retrievalAgent = createReactAgent({
          llm: new ChatOpenAI({ temperature: 0, model: "gpt-4o-mini" }),
          tools,
          stateModifier: [
            "Answer the user's question only based on context retrieved from provided tools.",
            "Only use the information provided by the tools.",
            "If you need more information, ask for it.",
          ].join(" "),
        });

        return new RetrievalAgent(retrievalAgent);
      }

      // Query the retrieval agent with a user question
      async query(query: string) {
        const { messages } = await this.agent.invoke({
          messages: [
            {
              role: "user",
              content: query,
            },
          ],
        });

        return messages.at(-1)?.content;
      }
    }

    async function readDoc(path: string) {
      return await fs.readFile(path, "utf-8");
    }

    /* Reads documents from the assets folder and converts them to langChain Documents */
    export async function readDocuments() {
      const folderPath = "./assets";
      const files = await fs.readdir(folderPath);
      const documents: Document[] = [];

      for (const file of files) {
        documents.push(
          new Document({
            pageContent: await readDoc(`${folderPath}/${file}`),
            metadata: { id: file.slice(0, file.lastIndexOf(".")) },
          })
        );
      }

      return documents;
    }
    ```

    ### Create a RAG Pipeline

    Define a RAG tool that uses the `FGARetriever` to filter authorized data from an in-memory vector database.

    In the first step, we will define a new RAG tool. The agent calls the tool when needed.

    ```ts index.ts wrap lines theme={null}
    import "dotenv/config";

    import { OpenAIEmbeddings } from "@langchain/openai";
    import { MemoryVectorStore } from "langchain/vectorstores/memory";
    import { FGARetriever } from "@auth0/ai-langchain/RAG";

    import { readDocuments, RetrievalAgent } from "./helpers";

    async function main() {
      console.info(
        "\n..:: LangGraph Agents Example: Agentic Retrieval with Auth0 FGA \n\n"
      );

      const user = "user1";
      // 1. Read and load documents from the assets folder
      const documents = await readDocuments();
      // 2. Create an in-memory vector store from the documents for OpenAI models.
      const vectorStore = await MemoryVectorStore.fromDocuments(
        documents,
        new OpenAIEmbeddings({ model: "text-embedding-3-small" })
      );
      // 3. Create a retriever that uses FGA to gate fetching documents on permissions.
      const retriever = FGARetriever.create({
        retriever: vectorStore.asRetriever(),
        // FGA tuple to query for the user's permissions
        buildQuery: (doc) => ({
          user: `user:${user}`,
          object: `doc:${doc.metadata.id}`,
          relation: "viewer",
        }),
      });
      // 4. Convert the retriever into a tool for an agent.
      const fgaTool = retriever.asJoinedStringTool();
      // 5. The agent will call the tool, rephrasing the original question and
      // populating the "query" argument, until it can answer the user's question.
      const retrievalAgent = RetrievalAgent.create([fgaTool]);
      // 6. Query the retrieval agent with a prompt
      const answer = await retrievalAgent.query("Show me forecast for ZEKO?");

      console.info(answer);
    }

    main().catch(console.error);
    ```

    ### Run the application

    To run the application, add the below to `package.json`:

    ```json package.json wrap lines theme={null}
    "x-type": "module",
    "main": "index.js",
    "scripts": {
      "start": "npx tsx index.ts"
    },
    ```

    Run the application using `npm start`, and the agent will respond that it cannot find the required information.

    The application can retrieve the information if you change the query to something available in the public document.

    Now, to access the private information, you’ll need to update your tuple list. Go back to the Okta FGA dashboard in the **Tuple Management** section and click **+ Add Tuple**. Fill in the following information:

    * **User**: `user:user1`
    * **Object**: select doc and add `private-doc` in the ID field
    * **Relation**: `viewer`

    Now, click **Add Tuple** and then run `npm start` again. This time, you should see a response containing the forecast information since you added a tuple that defines the `viewer` relation for `user1` to the `private-doc` object.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/authorization-for-rag/langgraph-agentic-js).
  </Tab>

  <Tab title="LangGraph + Python" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Install dependencies

    Please use [Python version >=3.11 and \<4.0](https://www.python.org/downloads/).

    As a first step, let's create a virtual environment and install the dependencies:

    ```bash wrap lines theme={null}
    # Create a virtual env
    python -m venv venv
    # Activate the virtual env
    source ./venv/bin/activate
    # Install dependencies
    pip install langgraph langchain-openai python-dotenv faiss-cpu langchain-community auth0-ai-langchain langgraph-prebuilt
    ```

    ### Set up an FGA Store

    In the [Auth0 FGA dashboard](https://dashboard.fga.dev/):

    <Steps>
      <Step>
        Navigate to **Settings**. In the **Authorized Clients** section, click **+
        Create Client**.
      </Step>

      <Step>
        Give your client a name and mark all the client permissions that are
        required for your use case. For the quickstart, you'll only need **Read and
        query**.
      </Step>

      <Step>
        Click **Create**.

        <Frame>
          <img alt="Set up FGA Store" />
        </Frame>
      </Step>
    </Steps>

    Once your client is created, you'll see a modal containing Store ID, Client ID, and Client Secret. Add or update an `.env.local` file with the following content to the root directory of the project. Click **Continue** to see the `FGA_API_URL` and `FGA_API_AUDIENCE.`

    The confirmation dialog will provide you with all the information that you need for your environment file.

    ```bash .env.local wrap lines theme={null}
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY=<your-openai-api-key>

    # Auth0 FGA
    FGA_STORE_ID=<your-fga-store-id>
    FGA_CLIENT_ID=<your-fga-store-client-id>
    FGA_CLIENT_SECRET=<your-fga-store-client-secret>
    FGA_API_URL=https://api.xxx.fga.dev
    FGA_API_AUDIENCE=https://api.xxx.fga.dev/
    ```

    Next, navigate to **Model Explorer**. You'll need to update the model information with this:

    ```bash wrap lines theme={null}
    model
      schema 1.1

    type user

    type doc
      relations
        define owner: [user]
        define viewer: [user, user:*]
    ```

    Remember to click **Save**.

    Now, to access public information, you'll need to add a tuple on FGA. Navigate to the **Tuple Management** section and click **+ Add Tuple**. Fill in the following information:

    * **User**: `user:*`
    * **Object**: select doc and add `public-doc` in the ID field
    * **Relation**: `viewer`

    A tuple signifies a user's relation to a given object. For example, the above tuple implies that all users can view the `public-doc` object.

    ### Secure the RAG Tool

    After all this configuration, let's get back to our node.js project. There you'll secure the RAG tool using [Auth0 FGA](https://auth0.com/fine-grained-authorization) and [Auth0 AI SDK](https://github.com/auth0/auth0-ai-python).

    ### Get the assets

    Create an `assets` folder and download the below files into the folder:

    * [`public-doc.md`](https://raw.githubusercontent.com/auth0-samples/auth0-ai-samples/refs/heads/main/authorization-for-rag/langgraph-agentic-js/assets/docs/public-doc.md)
    * [`private-doc.md`](https://raw.githubusercontent.com/auth0-samples/auth0-ai-samples/refs/heads/main/authorization-for-rag/langgraph-agentic-js/assets/docs/private-doc.md)

    ### Create helper functions

    Create a LangGraph agent and other helper functions that are needed to load documents.

    The first helper will create an in-memory vector store using `faiss` and `OpenAIEmbeddings`. You can replace this module with your own store, as long as it follows the LangChain retriever specification.

    ```py helpers/memory_store.py wrap lines theme={null}
    import faiss

    from langchain_openai import OpenAIEmbeddings
    from langchain_community.docstore import InMemoryDocstore
    from langchain_community.vectorstores import FAISS

    class MemoryStore:
        def __init__(self, store):
            self.store = store

        @classmethod
        def from_documents(cls, documents):
            embedding_model = OpenAIEmbeddings(model="text-embedding-ada-002")
            index = faiss.IndexFlatL2(1536)
            docstore = InMemoryDocstore({})
            index_to_docstore_id = {}
            vector_store = FAISS(embedding_model, index, docstore, index_to_docstore_id)

            vector_store.add_documents(documents)

            return cls(vector_store)

        def as_retriever(self):
            return self.store.as_retriever()
    ```

    The second helper will load the documents from the assets folder into the store.

    ```py helpers/read_documents.py wrap lines theme={null}
    import os

    from langchain_core.documents import Document

    def read_documents():
        current_dir = os.path.dirname(__file__)
        public_doc_path = os.path.join(current_dir, "../docs/public-doc.md")
        private_doc_path = os.path.join(current_dir, "../docs/private-doc.md")

        with open(public_doc_path, "r", encoding="utf-8") as file:
            public_doc_content = file.read()

        with open(private_doc_path, "r", encoding="utf-8") as file:
            private_doc_content = file.read()

        documents = [
            Document(
                page_content=public_doc_content,
                metadata={"id": "public-doc", "access": "public"},
            ),
            Document(
                page_content=private_doc_content,
                metadata={"id": "private-doc", "access": "private"},
            ),
        ]

        return documents
    ```

    ### Create a RAG Pipeline

    Define a RAG tool that uses the `FGARetriever` to filter authorized data from an in-memory vector database.

    In the first step, we will define a new RAG tool. The agent will call up the tool when needed.

    ```py main.py wrap lines theme={null}
    @tool
    def agent_retrieve_context_tool(query: str):
        """Call to get information about a company, e.g., What is the financial outlook for ZEKO?"""
        documents = read_documents()
        vector_store = MemoryStore.from_documents(documents)

        user_id = "admin"

        retriever = FGARetriever(
            retriever=vector_store.as_retriever(),
            build_query=lambda doc: ClientBatchCheckItem(
                user=f"user:{user_id}",
                object=f"doc:{doc.metadata.get('id')}",
                relation="viewer",
            ),
        )

        relevant_docs = retriever.invoke(query)

        if len(relevant_docs) > 0:
            return "\n\n".join([doc.page_content for doc in relevant_docs])

        return "I don't have any information on that."

    tools = [agent_retrieve_context_tool]
    ```

    The `FGARetriever` defined in the `retrieve` node is designed to abstract the base retriever from the FGA query logic. In this case, the `build_query` argument lets us specify how to query our FGA model by asking if the user is a viewer of the document.

    ```py main.py wrap lines theme={null}
    # ...

    build_query=lambda doc: ClientBatchCheckItem(
        user=f"user:{user_id}",
        object=f"doc:{doc.metadata.get('id')}",
        relation="viewer",
    ),
    ```

    Next, we define the reactive agent nodes, as seen in the file below. Please refer to the comments to see explanations of the steps:

    ```py main.py wrap lines theme={null}
    # ...

    def agent_node(state: State):
        """
        Generate the response from the agent.
        """
        llm_response = llm.invoke(state["messages"])
        return {"messages": [llm_response]}

    def agent_should_continue(state: State):
        """
        Determines whether the conversation should continue based on the user input.
        """
        last_message = state["messages"][-1]
        if last_message.tool_calls:
            return "tools"

        return END

    def generate_response_node(state: State):
        """
        Generate the response from the agent based on the result of the RAG tool.
        """
        prompt = PromptTemplate(
            template="""You are an assistant for question-answering tasks. Use the following pieces of retrieved-context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise. Question: {question}. Context: {context}. Answer:""",
            input_variables=["question", "context"],
        )

        question = state["messages"][0].content
        context = state["messages"][-1].content

        chain = prompt | llm

        llm_response = chain.invoke(
            {"question": question, "context": context}, prompt=prompt
        )

        return {"messages": [llm_response]}
    ```

    And finally, we build the graph.

    ```py main.py wrap lines theme={null}
    # ...

    # Create the OpenAI chat tool
    llm = ChatOpenAI(model="gpt-4o-mini").bind_tools(tools)

    # Build the graph
    graph_builder = StateGraph(State)
    tool_node = ToolNode(tools)

    # Define the nodes
    graph_builder.add_node("agent", agent_node)
    graph_builder.add_node("tools", tool_node)
    graph_builder.add_node("generate_response", generate_response_node)

    # Run the graph
    result = graph.invoke(
        {"messages": [("human", "What is the financial outlook for ZEKO?")]}
    )
    print(result["messages"][-1].content)
    ```

    ### Run the application

    To run the application, simply run the Python script as follows:

    ```bash wrap lines theme={null}
    python main.py
    ```

    The application can retrieve the information if you change the query to something available in the public document. Now, to access the private information, you'll need to update your tuple list. Go back to the Auth0 FGA dashboard in the **Tuple Management** section and click **+ Add Tuple**. Fill in the following information:

    * **User**: `user:user1`
    * **Object**: select doc and add `private-doc` in the ID field
    * **Relation**: `viewer`

    Now, click **Add Tuple** and then run `npm start` again. This time, you should see a response containing the forecast information since you added a tuple that defines the `viewer` relation for `user1` to the `private-doc` object.
  </Tab>
</Tabs>

## Next steps

* [Authorization for RAG docs](/intro/authorization-for-rag)
* Learn how to use [Auth0 FGA](https://auth0.com/fine-grained-authorization) to create a Relationship-Based Access Control (ReBAC) authorization model.
* Learn more about [OpenFGA](https://openfga.dev/docs/fga).


# Call Others' APIs on Users' Behalf
Source: https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf

Learn how Auth0 for AI Agents enables AI agents to call other's APIs on the user's behalf.

Use Auth0 SDKs to fetch access tokens for social and enterprise identity providers from Auth0's [Token Vault](https://auth0.com/docs/secure/tokens/token-vault). Using these access tokens, AI agents integrated with the application can call third-party APIs to perform tasks on the user's behalf.

By the end of this quickstart, you should have an AI application integrated with Auth0 that can:

1. Initiate a Connected Accounts flow that will allow the user to connect their Google account and grant access to the AI agent.
2. Retrieve access tokens for a Google social connection.
3. Integrate with an AI agent to call Google APIs.

## Pick your tech stack

<Tabs>
  <Tab title="LangGraph.js + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    <Tabs>
      <Tab title="Use sample app (recommended)">
        ### Download sample app

        Start by downloading and extracting the sample app. Then open in your preferred IDE.

        <DownloadQuickstartButton />

        ### Create your environment file

        In the root directory of your project, create a new `.env.local` file and add the following content:

        ```bash .env.local wrap lines theme={null}
        # Auth0 configuration
        APP_BASE_URL='http://localhost:3000'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

        AUTH0_AUDIENCE="https://your.domain.us.langgraph.app"
        AUTH0_SCOPE="openid profile email offline_access"
        AUTH0_CUSTOM_API_CLIENT_ID="{yourCustomApiClientId}"
        AUTH0_CUSTOM_API_CLIENT_SECRET="{yourCustomApiClientSecret}"

        # OpenAI API Key or any provider supported by the Vercel AI SDK
        OPENAI_API_KEY="YOUR_API_KEY"

        # LANGGRAPH
        LANGGRAPH_API_URL=http://localhost:54367
        LANGCHAIN_CALLBACKS_BACKGROUND=false
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your Regular Web application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        To get your API's `AUTH0_AUDIENCE`, navigate to <strong>[Applications > APIs](https://manage.auth0.com/#/apis)</strong> in the Auth0 Dashboard and select your API. You'll find the identifier in the **General Settings** section at the top.

        To get your Custom API Client's `AUTH0_CUSTOM_API_CLIENT_ID`, and `AUTH0_CUSTOM_API_CLIENT_SECRET` navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your Custom API Client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field:

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        Lastly, set your OpenAI API key or use any provider supported by the Vercel AI SDK:

        ```bash .env.local wrap lines theme={null}
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        ### Install packages

        Ensure you have `npm` installed or follow the instructions to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) in its documentation.
        In the root directory of your project, run the following command to install the required packages:

        ```bash wrap lines theme={null}
        npm install
        ```

        ### Test your application

        Start the application with `npm run all:dev`. Then, navigate to `http://localhost:3000`.

        <Note>
          This opens LangGraph Studio in a new tab. You can safely close it.
        </Note>

        If you are already logged in, make sure to log out and log back in using Google. Then, ask your AI agent to fetch emails from your Gmail account!

        That's it! You successfully called a third-party API using Token Vault.
      </Tab>

      <Tab title="Integrate into your app">
        ### Install packages

        In the root directory of your project, install the following packages:

        * `@auth0/ai-langchain`: [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-langchain) built for AI agents powered by LangChain.
        * `@langchain/langgraph`: For building stateful, multi-actor applications with LLMs.
        * `langchain`: The LangChain library.
        * `@langchain/core`: LangChain core libraries.
        * `@langchain/openai`: OpenAI provider for LangChain.
        * `@langchain/community`: LangChain community integrations.
        * `langgraph-nextjs-api-passthrough`: API passthrough for LangGraph.

        ```bash wrap lines theme={null}
        npm install @auth0/ai-langchain@4 @langchain/community@0.3.53 @langchain/core@0.3.77 @langchain/langgraph@0.4.4 @langchain/openai@0.6.13 langchain@0.3.12 langgraph-nextjs-api-passthrough@0.1.4
        ```

        ### Update your environment file

        Add to your environment file the following variables:

        ```bash .env.local wrap lines theme={null}
        # Auth0 configuration
        APP_BASE_URL='http://localhost:3000'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

        AUTH0_AUDIENCE="https://your.domain.us.langgraph.app"
        AUTH0_CUSTOM_API_CLIENT_ID="{yourCustomApiClientId}"
        AUTH0_CUSTOM_API_CLIENT_SECRET="{yourCustomApiClientSecret}"

        # OpenAI API Key or any provider supported by the Vercel AI SDK
        OPENAI_API_KEY="YOUR_API_KEY"

        # LANGGRAPH
        LANGGRAPH_API_URL=http://localhost:54367
        LANGCHAIN_CALLBACKS_BACKGROUND=false
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your Regular Web application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        To get your API's `AUTH0_AUDIENCE`, navigate to <strong>[Applications > APIs](https://manage.auth0.com/#/apis)</strong> in the Auth0 Dashboard and select your API. You'll find the identifier in the **General Settings** section at the top.

        To get your Custom API Client's `AUTH0_CUSTOM_API_CLIENT_ID`, and `AUTH0_CUSTOM_API_CLIENT_SECRET` navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your Custom API Client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field:

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        Lastly, set your OpenAI API key or use any provider supported by the Vercel AI SDK:

        ```bash .env.local wrap lines theme={null}
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        ### Set up Token Vault for Google social connection

        Use the [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-langchain) to get an access token for the [Google Social Connection](/integrations/google) using [Token Vault](https://auth0.com/docs/secure/tokens/token-vault):

        * `connection`: pass in the name of the connection you want to access.
        * `scopes`: pass in the scopes to be authorized for this connection.

        Create a file `src/lib/auth0-ai.ts` to instantiate the Auth0 AI SDK client:

        ```tsx src/lib/auth0-ai.ts wrap lines highlight={17} theme={null}
        import { Auth0AI } from '@auth0/ai-langchain';
        import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";

        const auth0AI = new Auth0AI({
          auth0: {
            domain: process.env.AUTH0_DOMAIN!,
            clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!,
            clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!,
          },
        });

        const withAccessTokenForConnection = (connection: string, scopes: string[]) =>
          auth0AI.withTokenVault({
            connection,
            scopes,
            accessToken: async (_, config) => {
              return config.configurable?.langgraph_auth_user?.getRawAccessToken();
            },
            subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
          });

        // Connection for Google services
        export const withGmailSearch = withAccessTokenForConnection(
          'google-oauth2',
          ['openid', 'https://www.googleapis.com/auth/gmail.readonly'],
        );
        ```

        ### Pass credentials to the tools

        Create a file `/src/lib/auth0.ts` file with the following code:

        ```tsx src/lib/auth0.ts wrap lines theme={null}
        import { Auth0Client } from '@auth0/nextjs-auth0/server';

        export const auth0 = new Auth0Client({
          authorizationParameters: {
            scope: process.env.AUTH0_SCOPE,
            audience: process.env.AUTH0_AUDIENCE,
          },
          enableConnectAccountEndpoint: true,
        });

        export const getAccessToken = async () => {
          const tokenResult = await auth0.getAccessToken();

          if(!tokenResult || !tokenResult.token) {
            throw new Error("No access token found in Auth0 session");
          }

          return tokenResult.token;
        };
        ```

        Update your chat route, typically at `/src/app/api/chat/[..._path]/route.ts` to pass the `accessToken` to your LangGraph agent to use the Auth0 AI SDK to get the Google access token from the server.

        ```ts src/app/api/chat/[..._path]/route.ts wrap lines highlight={3,10} theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";

        import { getAccessToken } from "@/lib/auth0";

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            baseRoute: "chat/",
            headers: async () => {
              const accessToken = await getAccessToken();
              return {
                Authorization: `Bearer ${accessToken}`,
              };
          });
        ```

        ### Add Custom Authentication

        <Info>
          For more information on how to add custom authentication for your LangGraph Platform application, read the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
        </Info>

        In your `langgraph.json`, add the path to your auth file:

        ```typescript langgraph.json wrap lines highlight={8} theme={null}
        {
          "node_version": "20",
          "graphs": {
            "agent": "./src/lib/agent.ts:agent"
          },
          "env": ".env",
          "auth": {
            "path": "./src/lib/auth.ts:authHandler"
          }
        }
        ```

        Then, in your `auth.ts` file, add your auth logic:

        ```typescript src/lib/auth.ts wrap lines theme={null}
        import { createRemoteJWKSet, jwtVerify } from "jose";

        const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

        const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
        const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

        // JWKS endpoint for Auth0
        const JWKS = createRemoteJWKSet(
          new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
        );

        // Create the Auth instance
        const auth = new Auth();
        // Register the authentication handler
        auth.authenticate(async (request: Request) => {
          const authHeader = request.headers.get("Authorization");
          const xApiKeyHeader = request.headers.get("x-api-key");
            /**
             * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
             * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
             *
             * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
             * or when running locally.
             */
            // This header is required in Langgraph Cloud.
            if (!authHeader && !xApiKeyHeader) {
              throw new HTTPException(401, {
                message: "Invalid auth header provided.",
              });
            }

            // prefer the xApiKeyHeader first
            let token = xApiKeyHeader || authHeader;

            // Remove "Bearer " prefix if present
            if (token && token.startsWith("Bearer ")) {
              token = token.substring(7);
            }

            // Validate Auth0 Access Token using common JWKS endpoint
            if (!token) {
              throw new HTTPException(401, {
                message:
                  "Authorization header format must be of the form: Bearer <token>",
              });
            }

            if (token) {
              try {
                // Verify the JWT using Auth0 JWKS
                const { payload } = await jwtVerify(token, JWKS, {
                  issuer: `https://${AUTH0_DOMAIN}/`,
                  audience: AUTH0_AUDIENCE,
                });

                console.log("✅ Auth0 JWT payload resolved!", payload);

                // Return the verified payload - this becomes available in graph nodes
                return {
                  identity: payload.sub!,
                  email: payload.email as string,
                  permissions:
                    typeof payload.scope === "string" ? payload.scope.split(" ") : [],
                  auth_type: "auth0",
                  // include the access token for use with Auth0 Token Vault exchanges by tools
                  getRawAccessToken: () => token,
                  // Add any other claims you need
                  ...payload,
                };
              } catch (jwtError) {
                console.log(
                  "Auth0 JWT validation failed:",
                  jwtError instanceof Error ? jwtError.message : "Unknown error"
                );
                throw new HTTPException(401, {
                  message: "Invalid Authorization token provided.",
                });
              }
            }
        });

        export { auth as authHandler };
        ```

        ### Use access token to call APIs from a tool

        Once the user is authenticated, you can fetch an access token from Token Vault using the Auth0 AI SDK. In this example, we fetch an access token for a Google social connection.
        Once you've obtained the access token for a connection, you can use it with an AI agent to fetch data during a tool call and provide contextual data in its response.
        This example uses `GmailSearch` from the `@langchain/community` tools. This tool will use the access token provided by Token Vault to query for emails.

        ```ts src/lib/tools/gmail-seatch.ts wrap lines highlight={10} theme={null}
        //...
        import { getAccessTokenFromTokenVault } from "@auth0/ai-langchain";
        import { GmailSearch } from "@langchain/community/tools/gmail";

        import { withGmailSearch } from "../../lib/auth0-ai";

        export const gmailSearchTool = withGmailSearch(
          new GmailSearch({
            credentials: {
              accessToken: async () => getAccessTokenFromTokenVault(),
            },
          })
        );
        ```

        Update your tool call to request an access token, as shown in the following example:

        ```ts src/lib/agent.ts wrap lines highlight={2,10-13} theme={null}
        //...
        import { gmailSearchTool } from './tools/gmail-search';

        //... existing code

        const tools = [gmailSearchTool];
        //... existing code
        export const agent = createReactAgent({
          llm,
          tools: new ToolNode(tools, {
            // Error handler must be disabled in order to trigger interruptions from within tools.
            handleToolErrors: false,
          }),
          // Modify the stock prompt in the prebuilt agent.
          prompt: AGENT_SYSTEM_TEMPLATE,
          store,
          checkpointer,
        });
        ```

        ### Add step-up authorization

        When you try to use the tool, the application requests any additional Google scopes that are required but not yet authorized. This process is called step-up authorization.

        To implement, install the Auth0 AI Components for Next.js SDK to get the required UI components:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Add a new file, `src/components/TokenVaultInterruptHandler.tsx`, with the following code:

        ```tsx src/components/TokenVaultInterruptHandler.tsx wrap lines theme={null}
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import type { Interrupt } from "@langchain/langgraph-sdk";

        import { TokenVaultConsent } from "@/components/auth0-ai/TokenVault";

        interface TokenVaultInterruptHandlerProps {
          interrupt: Interrupt | undefined | null;
          onFinish: () => void;
        }

        export function TokenVaultInterruptHandler({
          interrupt,
          onFinish,
        }: TokenVaultInterruptHandlerProps) {
          if (
            !interrupt ||
            !TokenVaultInterrupt.isInterrupt(interrupt.value)
          ) {
            return null;
          }

          return (
            <div key={interrupt.ns?.join("")} className="whitespace-pre-wrap">
              <TokenVaultConsent
                mode="popup"
                interrupt={interrupt.value}
                onFinish={onFinish}
                connectWidget={{
                  title: "Authorization Required.",
                  description: interrupt.value.message,
                  action: { label: "Authorize" },
                }}
              />
            </div>
          );
        }
        ```

        Now, update your chat window code to include the `TokenVaultInterruptHandler` component, for example:

        ```tsx src/components/chat-window.tsx wrap lines highlight={2,3,8-19,36-38} theme={null}
        //...
        import { TokenVaultInterruptHandler } from '@/components/TokenVaultInterruptHandler';

        //... existing code
        export function ChatWindow(props: {
          //... existing code
        }) {
          const [threadId, setThreadId] = useQueryState('threadId');
          const [input, setInput] = useState('');
          const chat = useStream({
            apiUrl: props.endpoint,
            assistantId: 'agent',
            threadId,
            onThreadId: setThreadId,
            onError: (e: any) => {
              console.error('Error: ', e);
              toast.error(`Error while processing your request`, { description: e.message });
            },
          });
          //... existing code
          return (
            <StickToBottom>
              <StickyToBottomContent
                className="absolute inset-0"
                contentClassName="py-8 px-2"
                content={
                  chat.messages.length === 0 ? (
                    <div>{props.emptyStateComponent}</div>
                  ) : (
                    <>
                      <ChatMessages
                        aiEmoji={props.emoji}
                        messages={chat.messages}
                        emptyStateComponent={props.emptyStateComponent}
                      />
                      <div className="flex flex-col max-w-[768px] mx-auto pb-12 w-full">
                        <TokenVaultInterruptHandler interrupt={chat.interrupt} onFinish={() => chat.submit(null)} />
                      </div>
                    </>
                  )
                }
                {/* ... existing code */}
              ></StickyToBottomContent>
            </StickToBottom>
          );
        }
        ```

        Now when step-up authorization is required, the user will see a prompt in the chat window asking them to authorize.

        ### Test your application

        Start your application. If you are already logged in, make sure to log out and log back in using Google. Then, ask your AI agent to fetch emails from your Gmail account!

        That's it! You successfully integrated third-party API access using Token Vault into your app.

        ### View a complete example

        Want to see how it all comes together? Explore or clone the fully implemented sample application on [GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/others-api/langchain-next-js).
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Vercel AI + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
    <Prerequisites />

    <Tabs>
      <Tab title="Use sample app (recommended)">
        ### Download sample app

        Start by downloading and extracting the sample app. Then open in your preferred IDE.

        <DownloadQuickstartButton />

        ### Create your environment file

        In the root directory of your project, create an `.env.local` file and add the following content:

        ```bash .env.local wrap lines theme={null}
        # Auth0 configuration
        APP_BASE_URL='http://localhost:3000'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

        # OpenAI API Key or any provider supported by the Vercel AI SDK
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications) </strong> in the Auth0 Dashboard and select your client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field:

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        Lastly, set your OpenAI API key or use any provider supported by the Vercel AI SDK:

        ```bash .env.local wrap lines theme={null}
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        ### Install packages

        Ensure you have `npm` installed or follow the instructions here to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
        In the root directory of your project, run the following command to install the required packages:

        ```bash wrap lines theme={null}
        npm install
        ```

        ### Test your application

        Start the application with `npm run dev`. Then, navigate to `http://localhost:3000`.

        If you are already logged in, make sure to log out and log back in using Google. Then, ask your AI agent about your Google calendar.

        That's it! You successfully called a third-party API using Token Vault.
      </Tab>

      <Tab title="Integrate into your app">
        ### Install packages

        In the root directory of your project, install the following packages:

        * `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents powered by the Vercel AI SDK.
        * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module that interacts with various AI model providers.
        * `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider for the Vercel AI SDK.
        * `@ai-sdk/react`: [React](https://react.dev/) UI components for the Vercel AI SDK.
        * `zod`: TypeScript-first schema validation library.
        * `googleapis`: Node.js client for Google APIs that supports authentication and authorization with OAuth 2.0.

        ```bash wrap lines theme={null}
        npm install @auth0/ai-vercel@4 ai@5.0.33 @ai-sdk/openai@2.0.24 @ai-sdk/react@2.0.33 zod@3.25.76 googleapis@161
        ```

        ### Update your environment file

        Add the following variables to your environment file:

        ```bash .env.local wrap lines theme={null}
        # Auth0 configuration
        APP_BASE_URL='http://localhost:3000'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

        # OpenAI API Key or any provider supported by the Vercel AI SDK
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field:

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        Lastly, set your OpenAI API key or use any provider supported by the Vercel AI SDK:

        ### Set up Token Vault for Google social connection

        Use the [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) to get an access token for the [Google Social Connection](/integrations/google) using [Token Vault](https://auth0.com/docs/secure/tokens/token-vault):

        * `connection`: pass in the name of the connection you want to access.
        * `scopes`: pass in the scopes to be authorized for this connection.
        * `refreshToken`: pass in the function to get the refresh token from the current session.

        Create a file at `src/lib/auth0-ai.ts` to instantiate the Auth0 AI SDK client:

        ```tsx src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI, getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { getRefreshToken } from "./auth0";

        // Get the access token for a connection via Auth0
        export const getAccessToken = async () => getAccessTokenFromTokenVault();

        const auth0AI = new Auth0AI();

        // Connection for Google services
        export const withGoogleConnection = auth0AI.withTokenVault({
          connection: "google-oauth2",
          scopes: ["openid", "https://www.googleapis.com/auth/calendar.events"],
          refreshToken: getRefreshToken,
        });
        ```

        ### Pass credentials to the tools

        Create a file at `/src/lib/auth0.ts` file with the following code:

        ```tsx src/lib/auth0.ts wrap lines theme={null}
        import { Auth0Client } from '@auth0/nextjs-auth0/server';

        // Create an Auth0 Client.
        export const auth0 = new Auth0Client({
          enableConnectAccountEndpoint: true,
        });

        // Get the refresh token from Auth0 session
        export const getRefreshToken = async () => {
          const session = await auth0.getSession();
          return session?.tokenSet?.refreshToken;
        };
        ```

        #### Use access token to call APIs from a tool

        Once the user is authenticated, you can fetch an access token from the Token Vault using the Auth0 AI SDK. In this example, we fetch an access token for a Google social connection.
        Once you've obtained the access token for a social connection, you can use it with an AI agent to fetch data during a tool call and provide contextual data in its response.

        In this example, we define a tool call, `getCalendarEventsTool`, that uses the access token with the Google Calendar API to query for calendar events on a specific date.
        Update your tool call to request an access token similar to this example:

        ```ts src/lib/tools/google-calendar.ts wrap lines theme={null}
        import { tool } from 'ai';
        import { endOfDay, formatISO, startOfDay } from 'date-fns';
        import { GaxiosError } from 'gaxios';
        import { google } from 'googleapis';
        import { z } from 'zod';
        import { TokenVaultError } from '@auth0/ai/interrupts';

        import { getAccessToken, withGoogleConnection } from '../auth0-ai';

        export const getCalendarEventsTool = withGoogleConnection(
          tool({
            description: `Get calendar events for a given date from the user's Google Calendar`,
            inputSchema: z.object({
              date: z.coerce.date(),
            }),
            execute: async ({ date }) => {
              // Get the access token from Auth0 AI
              const accessToken = await getAccessToken();

              // Google SDK
              try {
                const calendar = google.calendar('v3');
                const auth = new google.auth.OAuth2();

                auth.setCredentials({
                  access_token: accessToken,
                });

                // Get events for the entire day
                const response = await calendar.events.list({
                  auth,
                  calendarId: 'primary',
                  timeMin: formatISO(startOfDay(date)),
                  timeMax: formatISO(endOfDay(date)),
                  singleEvents: true,
                  orderBy: 'startTime',
                  maxResults: 50,
                });

                const events = response.data.items || [];

                return {
                  date: formatISO(date, { representation: 'date' }),
                  eventsCount: events.length,
                  events: events.map((event) => ({
                    id: event.id,
                    summary: event.summary || 'No title',
                    description: event.description,
                    startTime: event.start?.dateTime || event.start?.date,
                    endTime: event.end?.dateTime || event.end?.date,
                    location: event.location,
                    attendees:
                      event.attendees?.map((attendee) => ({
                        email: attendee.email,
                        name: attendee.displayName,
                        responseStatus: attendee.responseStatus,
                      })) || [],
                    status: event.status,
                    htmlLink: event.htmlLink,
                  })),
                };
              } catch (error) {
                if (error instanceof GaxiosError) {
                  if (error.status === 401) {
                    throw new TokenVaultError(`Authorization required to access the Token Vault connection`);
                  }
                }

                throw error;
              }
            },
          }),
        );
        ```

        ### Add step up authorization

        When you try to use the tool, the application requests any additional Google scopes that are required but not yet authorized. This process is called step-up authorization.

        To implement, install the Auth0 AI Components for Next.js SDK to get the required UI components:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Add a new file, `src/components/TokenVaultInterruptHandler.tsx` with the following code:

        ```tsx src/components/TokenVaultInterruptHandler.tsx wrap lines theme={null}
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import type { Auth0InterruptionUI } from "@auth0/ai-vercel/react";

        import { TokenVaultConsent } from "@/components/auth0-ai/TokenVault";

        interface TokenVaultInterruptHandlerProps {
          interrupt: Auth0InterruptionUI | null;
          onFinish?: () => void;
        }

        export function TokenVaultInterruptHandler({
          interrupt,
          onFinish,
        }: TokenVaultInterruptHandlerProps) {
          if (!TokenVaultInterrupt.isInterrupt(interrupt)) {
            return null;
          }

          return (
            <div key={interrupt.name} className="whitespace-pre-wrap">
              <TokenVaultConsent
                mode="popup"
                interrupt={interrupt}
                onFinish={onFinish}
                connectWidget={{
                  title: "Authorization Required.",
                  description: interrupt.message,
                  action: { label: "Authorize" },
                }}
              />
            </div>
          );
        }
        ```

        Now, update your chat window code to include the `TokenVaultInterruptHandler` component, for example:

        ```tsx src/components/chat-window.tsx wrap lines highlight={2,3,10-18,36-38} theme={null}
        //...
        import { useInterruptions } from '@auth0/ai-vercel/react';
        import { TokenVaultInterruptHandler } from '@/components/TokenVaultInterruptHandler';


        //... existing code
        export function ChatWindow(props: {
          //... existing code
        }) {
          const chat = useInterruptions((handler) =>
            useChat({
              api: props.endpoint,
              onError: handler((e: Error) => {
                console.error('Error: ', e);
                toast.error(`Error while processing your request`, { description: e.message });
              }),
            }),
          );

          //... existing code
          return (
            <StickToBottom>
              <StickyToBottomContent
                className="absolute inset-0"
                contentClassName="py-8 px-2"
                content={
                  chat.messages.length === 0 ? (
                    <div>{props.emptyStateComponent}</div>
                  ) : (
                    <>
                      <ChatMessages
                        aiEmoji={props.emoji}
                        messages={chat.messages}
                        emptyStateComponent={props.emptyStateComponent}
                      />
                      <div className="flex flex-col max-w-[768px] mx-auto pb-12 w-full">
                        <TokenVaultInterruptHandler interrupt={chat.toolInterrupt} />
                      </div>
                    </>
                  )
                }
                {/* ... existing code */}
              ></StickyToBottomContent>
            </StickToBottom>
          );
        }
        ```

        Now when step-up authorization is required, the user will see a prompt in the chat window asking them to authorize.

        ### Add the tool to the AI agent

        Handle the interrupts from the AI agent and call the tool from your AI app to get calendar events. Update your chat route, typically at `/src/app/api/chat/route.ts`, as shown in the following example:

        ```ts src/app/api/chat/route.ts wrap lines theme={null}
        //...
        import { setAIContext } from "@auth0/ai-vercel";
        import {
          errorSerializer,
          withInterruptions,
        } from "@auth0/ai-vercel/interrupts";
        import { getCalendarEventsTool } from "@/lib/tools/google-calendar";
        //... existing code

        export async function POST(req: NextRequest) {
          const request = await req.json();
          const messages = sanitizeMessages(request.messages);

          setAIContext({ threadID: request.id });

          const tools = {
            getCalendarEventsTool,
          };

           const modelMessages = convertToModelMessages(messages);

          const stream = createUIMessageStream({
            originalMessages: messages,
            execute: withInterruptions(
              async ({ writer }) => {
                const result = streamText({
                  model: openai('gpt-4o-mini'),
                  system: AGENT_SYSTEM_TEMPLATE,
                  messages: modelMessages,
                  tools,

                  onFinish: (output) => {
                    if (output.finishReason === 'tool-calls') {
                      const lastMessage = output.content[output.content.length - 1];
                      if (lastMessage?.type === 'tool-error') {
                        const { toolName, toolCallId, error, input } = lastMessage;
                        const serializableError = {
                          cause: error,
                          toolCallId: toolCallId,
                          toolName: toolName,
                          toolArgs: input,
                        };

                        throw serializableError;
                      }
                    }
                  },
                });
                writer.merge(
                  result.toUIMessageStream({
                    sendReasoning: true,
                  }),
                );
              },
              {
                messages: messages,
                tools,
              },
            ),
            onError: errorSerializer((err) => {
              console.error('ai-sdk route: stream error', err);
              return 'Oops, an error occured!';
            }),
          });

          return createUIMessageStreamResponse({ stream });
        }
        ```

        ### Test your application

        Start your application. If you are already logged in, make sure to log out and log back in using Google. Then, ask your AI agent about your Google calendar!

        That's it! You successfully integrated third-party API access using Token Vault into your app.

        ### View a complete example

        Want to see how it all comes together? Explore or clone the fully implemented sample application [here on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/others-api/vercel-ai-next-js).
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="LangGraph + FastAPI" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    <Tabs>
      <Tab title="Use sample app (recommended)">
        ### Download sample app

        Start by downloading and extracting the sample app. Then open in your preferred IDE.

        <DownloadQuickstartButton />

        The project is divided into two parts:

        * `backend/`: contains the backend code for the web app, an API written in Python using FastAPI and the LangGraph agent.
        * `frontend/`: contains the frontend code for the web app, written in React as a Vite SPA.

        ### Install backend packages

        In the `backend` directory of your project, install the required packages using your preferred package manager, such as `uv`. You can find the instructions on how to [install uv](https://docs.astral.sh/uv/getting-started/installation/) in its documentation.

        ```bash wrap lines theme={null}
        cd backend
        uv sync
        ```

        ### Create your environment file

        In the `backend` directory of your project, create a new file and name it `.env` and add the following content:

        ```bash .env wrap lines theme={null}
        # Auth0 configuration
        APP_BASE_URL='http://localhost:5173'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

        # OpenAI API Key or any provider supported by the LangGraph SDK
        OPENAI_API_KEY="YOUR_API_KEY"

        # LANGGRAPH
        LANGGRAPH_API_URL=http://localhost:54367
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field:

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        Lastly, set your OpenAI API key or use any provider supported by the LangGraph SDK:

        ```bash .env wrap lines theme={null}
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        In the `frontend` directory of your project, copy the `.env.example` file to `.env`. No further customization required.

        ### Install frontend packages

        Ensure you have `npm` installed or follow the instructions to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) in its documentation.
        Navigate to the `frontend` directory of your project and install the required packages:

        ```bash wrap lines theme={null}
        cd frontend
        npm install
        ```

        ### Run your application

        To run your application, start the FastAPI backend, LangGraph server, and the frontend in three terminals:

        1. In one terminal, start the FastAPI backend:

        ```bash wrap lines theme={null}
        cd backend
        source .venv/bin/activate
        uv pip install auth0_fastapi
        fastapi dev app/main.py
        ```

        2. In a second new terminal, start the LangGraph server:

        ```bash wrap lines theme={null}
        cd backend
        source .venv/bin/activate
        uv pip install -U langgraph-api
        langgraph dev --port 54367 --allow-blocking
        ```

        <Note>
          This opens LangGraph Studio in a new tab. You can safely close it.
        </Note>

        3. In a third new terminal, start the frontend:

        ```bash wrap lines theme={null}
        cd frontend
        npm run dev
        ```

        Visit the URL `http://localhost:5173` in your browser. If you are already logged in, make sure to log out and log back in using Google. Now ask your AI agent to list the upcoming events in your Google Calendar!

        That's it! You successfully called a third-party API using Token Vault.
      </Tab>

      <Tab title="Integrate into your app">
        ### Install packages

        In the `backend` directory of your project, install the following dependencies:

        * `auth0-ai-langchain`: [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-python/tree/main/packages/auth0-ai-langchain) built for AI agents powered by LangChain.
        * `langgraph`: [LangGraph](https://pypi.org/project/langgraph/) for building stateful, multi-actor applications with LLMs.
        * `langchain-openai`: LangChain integrations for OpenAI.
        * `langgraph-cli`: LangGraph CLI for running a local LangGraph server.
        * `google-api-python-client`: Google API client library for Python.

        Make sure you have [uv](https://docs.astral.sh/uv/) installed and run the following command to install the dependencies:

        ```bash wrap lines theme={null}
        cd backend
        uv sync
        uv add "auth0-ai-langchain>=1.0.0b5" "langgraph>=0.5.4" langchain-openai "langgraph-cli[inmem]>=0.3.6" google-api-python-client --prerelease=allow
        ```

        ### Update your environment file

        In the `backend` directory of your project, add the following variables to your environment file:

        ```bash .env wrap lines theme={null}
        # Auth0 configuration
        APP_BASE_URL='http://localhost:5173'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'

        # OpenAI API Key or any provider supported by the Vercel AI SDK
        OPENAI_API_KEY="YOUR_API_KEY"

        # LANGGRAPH
        LANGGRAPH_API_URL=http://localhost:54367
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field.

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        Lastly, set your OpenAI API key or use any provider supported by the LangGraph SDK.

        ### Set up Token Vault for Google social connection

        Use the [Auth0 AI SDK for LangChain](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-langchain) to get an access token for the [Google Social Connection](/integrations/google) using [Token Vault](https://auth0.com/docs/secure/tokens/token-vault):

        * `connection`: pass in the name of the connection you want to access.
        * `scopes`: pass in the scopes to be authorized for this connection.

        Create a file at `app/core/auth0_ai.py` to instantiate the Auth0 AI SDK client:

        ```python app/core/auth0_ai.py wrap lines theme={null}
        from auth0_ai.authorizers.types import Auth0ClientParams
        from auth0_ai_langchain.auth0_ai import Auth0AI

        from app.core.config import settings

        auth0_ai = Auth0AI(
            Auth0ClientParams(
                {
                    "domain": settings.AUTH0_DOMAIN,
                    "client_id": settings.AUTH0_CLIENT_ID,
                    "client_secret": settings.AUTH0_CLIENT_SECRET,
                }
            )
        )

        with_calendar_access = auth0_ai.with_token_vault(
            connection="google-oauth2",
            scopes=["openid", "https://www.googleapis.com/auth/calendar.events"],
            # Optional: authorization_params={"login_hint": "user@example.com", "ui_locales": "en"}
        )
        ```

        ### Pass credentials to the AI agent

        Update your API route to pass the user session data and an external provider's access token to the AI agent, for example, in `app/api/routes/chat.py`:

        ```python app/api/routes/chat.py wrap lines highlight={2,9,21} theme={null}
        # ...
        from app.core.auth import auth_client
        # ...

        @agent_router.api_route(
            "/{full_path:path}", methods=["GET", "POST", "DELETE", "PATCH", "PUT", "OPTIONS"]
        )
        async def api_route(
            request: Request, full_path: str, auth_session=Depends(auth_client.require_session)
        ):
            try:
                # ... existing code

                # Prepare body
                body = await request.body()
                if request.method in ("POST", "PUT", "PATCH") and body:
                    content = await request.json()
                    content["config"] = {
                        "configurable": {
                            "_credentials": {
                                "refresh_token": auth_session.get("refresh_token"),
                            }
                        }
                    }
                    body = json.dumps(content).encode("utf-8")

                    # ... existing code
        ```

        ### Use access token to call APIs from a tool

        Once the user is authenticated, you can fetch an access token from Token Vault using the Auth0 AI SDK. In this example, we fetch an access token for a Google social connection.
        Once you've obtained the access token for a connection, you can use it with an AI agent to fetch data during a tool call and provide contextual data in its response.

        Create or update a tool similar to this example that creates a Google Calendar query tool:

        ```python app/agents/tools/google_calendar.py wrap lines theme={null}
        from langchain_core.tools import StructuredTool
        from google.oauth2.credentials import Credentials
        from googleapiclient.discovery import build
        from pydantic import BaseModel
        from auth0_ai_langchain.token_vault import (
            get_access_token_from_token_vault,
        )
        import datetime
        import json

        from app.core.auth0_ai import with_calendar_access

        async def list_upcoming_events_fn():
            """List upcoming events from the user's Google Calendar"""
            google_access_token = get_access_token_from_token_vault()
            if not google_access_token:
                raise ValueError(
                    "Authorization required to access the Google Calendar API"
                )

            calendar_service = build(
                "calendar",
                "v3",
                credentials=Credentials(google_access_token),
            )

            events = (
                calendar_service.events()
                .list(
                    calendarId="primary",
                    timeMin=datetime.datetime.now().isoformat() + "Z",
                    timeMax=(datetime.datetime.now() + datetime.timedelta(days=7)).isoformat()
                    + "Z",
                    maxResults=5,
                    singleEvents=True,
                    orderBy="startTime",
                )
                .execute()
                .get("items", [])
            )

            return json.dumps(
                [
                    {
                        "summary": event["summary"],
                        "start": event["start"].get("dateTime", event["start"].get("date")),
                    }
                    for event in events
                ]
            )

        list_upcoming_events = with_calendar_access(
            StructuredTool(
                name="list_upcoming_events",
                description="List upcoming events from the user's Google Calendar",
                args_schema=BaseModel,
                coroutine=list_upcoming_events_fn,
            )
        )
        ```

        ### Add the tool to the AI agent

        If you created a new tool, ensure it's added to the list of tools used by your AI agent. For example:

        ```python app/agents/assistant0.py wrap lines highlight={2,4} theme={null}
        # ...
        from app.agents.tools.google_calendar import list_upcoming_events

        tools = [list_upcoming_events]

        llm = ChatOpenAI(model="gpt-4.1-mini")

        # ... existing code
        agent = create_react_agent(
            llm,
            tools=ToolNode(tools, handle_tool_errors=False),
            prompt=get_prompt(),
        )
        ```

        ### Add step-up authorization

        When you try to use the tool, the application requests any additional Google scopes that are required but not yet authorized. This process is called step-up authorization.

        To implement, install the Auth0 AI Components for React SDK to get the required UI components:

        ```bash wrap lines theme={null}
        cd frontend
        npm install @auth0/ai @langchain/langgraph-sdk
        npx @auth0/ai-components add TokenVault
        ```

        Add a new file, `src/components/TokenVaultInterruptHandler.tsx`, with the following code:

        ```tsx src/components/TokenVaultInterruptHandler.tsx wrap lines theme={null}
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import type { Interrupt } from "@langchain/langgraph-sdk";

        import { TokenVaultConsent } from "@/components/auth0-ai/TokenVault";
        import type { TokenVaultAuthProps } from "./auth0-ai/TokenVault/TokenVaultAuthProps";

        export interface TokenVaultInterruptHandlerProps {
          interrupt: Interrupt | undefined | null;
          onFinish: () => void;
          auth?: TokenVaultAuthProps['auth'];
        }

        export function TokenVaultInterruptHandler({
          interrupt,
          onFinish,
          auth,
        }: TokenVaultInterruptHandlerProps) {
          if (!interrupt) {
            return null;
          }

          if (!TokenVaultInterrupt.isInterrupt(interrupt.value)) {
            return null;
          }

          return (
            <div key={interrupt.ns?.join("")} className="whitespace-pre-wrap">
              <TokenVaultConsent
                mode="popup"
                interrupt={interrupt.value}
                onFinish={onFinish}
                auth={auth}
                connectWidget={{
                  title: "Authorization Required.",
                  description: interrupt.value.message,
                  action: { label: "Authorize" },
                }}
              />
            </div>
          );
        }
        ```

        Now, update your chat window code to include the `TokenVaultInterruptHandler` component, for example:

        ```tsx src/components/chat-window.tsx wrap lines highlight={2,3,25-50} theme={null}
        //...
        import { TokenVaultInterruptHandler } from '@/components/TokenVaultInterruptHandler';
        import { getConnectUrl } from "@/lib/use-auth";

        //... existing code
        export function ChatWindow(props: {
          //... existing code
        }) {
          //... existing code
          return (
            <StickToBottom>
              <StickyToBottomContent
                className="absolute inset-0"
                contentClassName="py-8 px-2"
                content={
                  chat.messages.length === 0 ? (
                    <div>{props.emptyStateComponent}</div>
                  ) : (
                    <>
                      <ChatMessages
                        aiEmoji={props.emoji}
                        messages={chat.messages}
                        emptyStateComponent={props.emptyStateComponent}
                      />
                      <div className="flex flex-col max-w-[768px] mx-auto pb-12 w-full">
                        {!!chat.interrupt?.value && (
                          <TokenVaultInterruptHandler
                            auth={{
                              connectPath: getConnectUrl(),
                              returnTo: new URL(
                                "/close",
                                window.location.origin
                              ).toString(),
                            }}
                            interrupt={{
                              ...chat.interrupt,
                              value: {
                                ...chat.interrupt.value,
                                requiredScopes:
                                  (
                                    chat.interrupt.value as {
                                      required_scopes: [string];
                                    }
                                  ).required_scopes || [],
                                authorizationParams:
                                  (
                                    chat.interrupt.value as {
                                      authorization_params: Record<string, string>;
                                    }
                                  ).authorization_params || {},
                              },
                            }}
                            onFinish={() => chat.submit(null)}
                          />
                        )}
                      </div>
                    </>
                  )
                }
                {/* ... existing code */}
              ></StickyToBottomContent>
            </StickToBottom>
          );
        }
        ```

        Now when step-up authorization is required, the user will see a prompt in the chat window asking them to authorize.

        ### Test your application

        Start your application. If you are already logged in, make sure to log out and log back in using Google. Then, ask your AI agent to list the upcoming events in your Google Calendar!

        That's it! You successfully integrated third-party API access using Token Vault into your app.

        ### View a complete example

        Want to see how it all comes together? Explore or clone the fully implemented sample application on [GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/others-api/langchain-fastapi-py).
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Vercel AI + React SPA" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
    <Prerequisites />

    ### Key differences from Next.js approach

    This React SPA implementation differs from the <a href="/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-next-js">Next.js example</a> in a few important ways:

    1. **Token Vault Access Token Exchange**: Instead of using refresh tokens, the React SPA implementation exchanges the SPA's access token for a third-party access token.
    2. **Client-Side Authorization**: Client login and step-up authorization are handled client-side using `@auth0/auth0-spa-js`.
    3. **Resource Server Client**: Requires a special Resource Server Client configured for token exchange with Token Vault.
    4. **Interrupt Handling**: The React client manages tool access errors and step-up authorization using interrupts that trigger a redirect for re-authorization.

    <Tabs>
      <Tab title="Use sample app (recommended)">
        ### Download sample app

        Start by downloading and extracting the sample app. Then open in your preferred IDE.

        <DownloadQuickstartButton />

        ### Create your environment files

        Add separate `.env` files with environment variables for the client and server.

        #### Client (client/.env)

        ```bash .env wrap lines theme={null}
        VITE_AUTH0_DOMAIN=your-auth0-domain
        VITE_AUTH0_CLIENT_ID=your-spa-client-id
        VITE_AUTH0_AUDIENCE=your-api-identifier
        VITE_API_URL=http://localhost:3001
        ```

        To get your SPA application's `VITE_AUTH0_DOMAIN`, and `VITE_AUTH0_CLIENT_ID`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your SPA application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        To get your API's `AUTH0_AUDIENCE`, navigate to <strong>[Applications > APIs](https://manage.auth0.com/#/apis)</strong> in the Auth0 Dashboard and select your API. You'll find the identifier in the **General Settings** section at the top.

        #### Server (server/.env)

        ```bash .env wrap lines theme={null}
        AUTH0_DOMAIN=your-auth0-domain
        AUTH0_AUDIENCE=your-api-identifier
        AUTH0_CUSTOM_API_CLIENT_ID=your-custom-api-client-id
        AUTH0_CUSTOM_API_CLIENT_SECRET=your-custom-api-client-secret
        OPENAI_API_KEY=your-openai-api-key
        PORT=3001
        ```

        To get your Custom API Client's `AUTH0_DOMAIN`, `AUTH0_AUDIENCE`, and `AUTH0_CUSTOM_API_CLIENT_ID`, and `AUTH0_CUSTOM_API_CLIENT_SECRET` navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your Custom API Client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        The `AUTH0_AUDIENCE` should match the identifier of the API referenced in the `client/.env` file above.

        Lastly, set your OpenAI API key or use any provider supported by the Vercel AI SDK:

        ```bash .env.local wrap lines theme={null}
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        ### Install packages

        Ensure you have `npm` installed or follow the instructions to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) in its documentation.
        In the root directory of your project, run the following command to install the required packages:

        ```bash wrap lines theme={null}
        npm install
        ```

        ### Test your application

        1. Start the client and server using Turbo: `npm run dev`.
        2. Navigate to `http://localhost:5173`.
        3. Log in with Google and ask your AI agent about your calendar.

        The application will automatically prompt for additional calendar permissions when needed using Auth0's step-up authorization flow.

        That's it! You've successfully called a third-party API using Token Vault in your React SPA + Vercel AI application.
      </Tab>

      <Tab title="Integrate into your app">
        ### Install dependencies

        In the root directory of your project, ensure you have the following client and server dependencies:

        **Client dependencies:**

        * `@auth0/auth0-spa-js`: Auth0 SPA SDK for client-side authentication
        * `@auth0/ai-vercel`: [Auth0 AI SDK for Vercel AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) built for AI agents
        * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module

        **Server dependencies:**

        * `@hono/node-server`: Node.js server adapter for Hono
        * `hono`: Lightweight web framework
        * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module
        * `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider
        * `googleapis`: Node.js client for Google APIs
        * `jose`: JavaScript Object Signing and Encryption library for JWT verification
          To install all the client and server dependencies, navigate to the root directory of your project and run the following command:

        ```bash wrap lines theme={null}
        # Install all client & server dependencies from the root directory of the project.
        npm install
        ```

        ### Update the environment files

        Add separate `.env` files with environment variables for the client and server.

        #### Client (client/.env)

        ```bash .env wrap lines theme={null}
        VITE_AUTH0_DOMAIN=your-auth0-domain
        VITE_AUTH0_CLIENT_ID=your-spa-client-id
        VITE_AUTH0_AUDIENCE=your-api-identifier
        VITE_API_URL=http://localhost:3001
        ```

        To get your SPA application's `VITE_AUTH0_DOMAIN`, and `VITE_AUTH0_CLIENT_ID`, navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your SPA application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        To get your API's `AUTH0_AUDIENCE`, navigate to <strong>[Applications > APIs](https://manage.auth0.com/#/apis)</strong> in the Auth0 Dashboard and select your API. You'll find the identifier in the **General Settings** section at the top.

        #### Server (server/.env)

        ```bash .env wrap lines theme={null}
        AUTH0_DOMAIN=your-auth0-domain
        AUTH0_AUDIENCE=your-api-identifier
        AUTH0_CUSTOM_API_CLIENT_ID=your-custom-api-client-id
        AUTH0_CUSTOM_API_CLIENT_SECRET=your-custom-api-client-secret
        OPENAI_API_KEY=your-openai-api-key
        PORT=3001
        ```

        To get your Custom API Client's `AUTH0_DOMAIN`, `AUTH0_AUDIENCE`, and `AUTH0_CUSTOM_API_CLIENT_ID`, and `AUTH0_CUSTOM_API_CLIENT_SECRET` navigate to <strong>[Applications > Applications](https://manage.auth0.com/#/applications)</strong> in the Auth0 Dashboard and select your Custom API Client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        The `AUTH0_AUDIENCE` should match the identifier of the API referenced in the `client/.env` file above.

        Lastly, set your OpenAI API key or use any provider supported by the Vercel AI SDK:

        ```bash .env.local wrap lines theme={null}
        OPENAI_API_KEY="YOUR_API_KEY"
        ```

        ### Create an Auth0 Provider and initialize the Auth0 SPA SDK

        Create `client/src/lib/auth0.ts` and initialize the Auth0 SPA SDK with your Auth0 application details, along with configuration for token storage and refresh tokens:

        ```ts client/src/lib/auth0.ts wrap lines theme={null}
        import { Auth0Client, createAuth0Client } from "@auth0/auth0-spa-js";

        // Auth0 configuration
        const AUTH0_DOMAIN = import.meta.env.VITE_AUTH0_DOMAIN;
        const AUTH0_CLIENT_ID = import.meta.env.VITE_AUTH0_CLIENT_ID;
        const AUTH0_AUDIENCE = import.meta.env.VITE_AUTH0_AUDIENCE;

        export const initAuth0 = async (): Promise<Auth0Client> => {
          if (auth0Client) {
            return auth0Client;
          }

          auth0Client = await createAuth0Client({
            domain: AUTH0_DOMAIN,
            clientId: AUTH0_CLIENT_ID,
            authorizationParams: {
              redirect_uri: window.location.origin,
              audience: AUTH0_AUDIENCE,
              scope: "openid profile email offline_access",
            },
            // Store tokens in localstorage to allow restoring the user session after following redirects.
            // Redirects are necessary to connect an account for the user.
            cacheLocation: 'localstorage',
            useRefreshTokens: true,
            useMrrt: true,
            useDpop: true,
          });

          return auth0Client;
        };
        ```

        Create a Provider component to wrap your application with Auth0 context in `client/src/components/Auth0Provider.tsx`:

        ```tsx client/src/components/Auth0Provider.tsx wrap lines theme={null}
        import React, { ReactNode, useEffect, useRef, useState } from "react";

        import { User } from "@auth0/auth0-ai-js-examples-react-hono-ai-sdk-shared";

        import {
          getToken,
          getUser,
          initAuth0,
          isAuthenticated,
          login,
          logout,
        } from "../lib/auth0";
        import { Auth0Context, Auth0ContextType } from "./auth0-context";

        interface Auth0ProviderProps {
          children: ReactNode;
        }

        export const Auth0Provider: React.FC<Auth0ProviderProps> = ({ children }) => {
          const [isLoading, setIsLoading] = useState(true);
          const [isAuthenticatedState, setIsAuthenticatedState] = useState(false);
          const [user, setUser] = useState<User | null>(null);
          const [error, setError] = useState<string | null>(null);
          const initRef = useRef(false);

          useEffect(() => {
            // Prevent double execution in React Strict Mode
            if (initRef.current) return;
            initRef.current = true;

            const initializeAuth0 = async () => {
              try {
                setIsLoading(true);
                const client = await initAuth0();

                // Check if user is returning from login redirect or connect flow
                if (
                  (window.location.search.includes("code=") ||
                    window.location.search.includes("connect_code=")) &&
                  window.location.search.includes("state=")
                ) {
                  await client.handleRedirectCallback();
                  window.history.replaceState({}, document.title, window.location.pathname);
                }

                const authenticated = await isAuthenticated();
                setIsAuthenticatedState(authenticated);

                if (authenticated) {
                  const userData = await getUser();
                  setUser(userData as User);
                }
              } catch (err) {
                setError(err instanceof Error ? err.message : "Authentication error");
              } finally {
                setIsLoading(false);
              }
            };

            initializeAuth0();
          }, []);

          const handleLogin = async (targetUrl?: string) => {
            try {
              setError(null);
              await login(targetUrl);
            } catch (err) {
              setError(err instanceof Error ? err.message : "Login failed");
            }
          };

          const handleLogout = async () => {
            try {
              setError(null);
              await logout();
              setIsAuthenticatedState(false);
              setUser(null);
            } catch (err) {
              setError(err instanceof Error ? err.message : "Logout failed");
            }
          };

          const contextValue: Auth0ContextType = {
            isLoading,
            isAuthenticated: isAuthenticatedState,
            user,
            error,
            login: handleLogin,
            logout: handleLogout,
            getToken,
          };

          return (
            <Auth0Context.Provider value={contextValue}>
              {children}
            </Auth0Context.Provider>
          );
        };
        ```

        Finally, wrap your application with the `Auth0Provider` in `client/src/main.tsx`:

        ```tsx client/src/main.tsx wrap lines theme={null}
        import "./index.css";

        import { StrictMode } from "react";
        import { createRoot } from "react-dom/client";

        import App from "./App.tsx";
        import { Auth0Provider } from "./contexts/Auth0Context.tsx";

        createRoot(document.getElementById("root")!).render(
          <StrictMode>
            <Auth0Provider>
              <App />
            </Auth0Provider>
          </StrictMode>
        );
        ```

        ### Configure the SPA for step-up authorization

        Unlike the <a href="/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-next-js">Next.js example</a>, which uses refresh tokens, this React SPA approach uses **access tokens** for token exchange with Token Vault. The SPA handles step-up authorization using the `loginWithPopup()` method from the Auth0 SPA SDK to display the consent screen and allow the user to grant additional permissions.

        Create `client/src/components/TokenVaultConsentPopup.tsx`:

        ```tsx client/src/components/TokenVaultConsentPopup.tsx wrap lines theme={null}
        import { useCallback, useState } from "react";
        import type { Auth0InterruptionUI } from "@auth0/ai-vercel/react";

        import { getAuth0Client } from "../lib/auth0";
        import { Button } from "./ui/button";
        import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";

        /**
         * Component for handling connection authorization popups.
         * This component manages the connect account flow for Token Vault, allowing the
         * user to authorize access to third-party providers.
         */

        interface TokenVaultConsentPopupProps {
          interrupt: Auth0InterruptionUI;
        }

        export function TokenVaultConsentPopup({
          interrupt,
        }: TokenVaultConsentPopupProps) {
          const [isLoading, setIsLoading] = useState(false);

          const { connection, requiredScopes, authorizationParams, resume } = interrupt;

          // Use Auth0 SPA SDK to connect an external account
          const startConnectAccountFlow = useCallback(async () => {
            try {
              setIsLoading(true);

              // Filter out empty scopes
              const validScopes = requiredScopes.filter(
                (scope: string) => scope && scope.trim() !== "",
              );

              const auth0Client = getAuth0Client();

              // Use the connect account flow to request authorization+consent for the external API.
              // This will redirect the browser away from the SPA.
              await auth0Client.connectAccountWithRedirect({
                connection,
                scopes: validScopes,
                ...(authorizationParams
                  ? { authorization_params: authorizationParams }
                  : {}),
              });

              setIsLoading(false);

              // Resume the interrupted tool after successful authorization
              if (typeof resume === "function") {
                resume();
              }
            } catch (error) {
              console.error("Connect account flow failed:", error);
              setIsLoading(false);

              // Even if login fails, we should clear the interrupt
              if (typeof resume === "function") {
                resume();
              }
            }
          }, [connection, requiredScopes, authorizationParams, resume]);

          if (isLoading) {
            return (
              <Card className="w-full">
                <CardContent className="flex items-center justify-center p-6">
                  <div className="text-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-2"></div>
                    <p className="text-sm text-muted-foreground">
                      Connecting to {connection.replace("-", " ")}...
                    </p>
                  </div>
                </CardContent>
              </Card>
            );
          }

          return (
            <Card className="w-full border-yellow-200 bg-yellow-50">
              <CardHeader>
                <CardTitle className="text-lg text-yellow-800">
                  Authorization Required
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <p className="text-sm text-yellow-700">
                  To access your {connection.replace("-", " ")} data, you need to
                  connect your account and authorize this application.
                </p>
                <p className="text-xs text-yellow-600">
                  Required permissions:{" "}
                  {requiredScopes
                    .filter((scope: string) => scope && scope.trim() !== "")
                    .join(", ")}
                </p>
                <Button onClick={startConnectAccountFlow} className="w-full">
                  Connect &amp; Authorize {connection.replace("-", " ")}
                </Button>
              </CardContent>
            </Card>
          );
        }
        ```

        #### Create tools with integrated Token Vault support for retrieving third-party access tokens

        Next, create a tool that accesses Token Vault to fetch a Google access token to list all the Google Calendars a user has access to.

        Create `server/src/lib/tools/listUserCalendars.ts`:

        ```ts server/src/lib/tools/listUserCalendars.ts wrap lines theme={null}
        import { tool } from "ai";
        import { google } from "googleapis";
        import { z } from "zod";

        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";

        import type { ToolWrapper } from "@auth0/ai-vercel";

        /**
         * Tool: listUserCalendars
         * Lists all calendars the user has access to.
         * Uses the enhanced @auth0/ai SDK for token exchange with Token Vault.
         */
        export const createListUserCalendarsTool = (
          googleCalendarWrapper: ToolWrapper
        ) =>
          googleCalendarWrapper(
            tool({
              description: "List all calendars the user has access to",
              inputSchema: z.object({}),
              execute: async () => {
                // Get the access token from Token Vault using the enhanced SDK
                const token = getAccessTokenFromTokenVault();

                const calendar = google.calendar("v3");
                const auth = new google.auth.OAuth2();
                auth.setCredentials({ access_token: token });

                const res = await calendar.calendarList.list({ auth });

                const calendars =
                  res.data.items?.map((cal) => ({
                    id: cal.id,
                    name: cal.summary,
                    accessRole: cal.accessRole,
                  })) ?? [];

                return calendars;
              },
            })
          );
        ```

        #### Configure the API server with Google connection wrapper for calendar tools

        Instantiate an instance of `Auth0AI` with a pre-configured resource client. Then, create a wrapper for the Google Calendar Tool that sets up the token exchange. This allows you to directly exchange an Auth0 access token for a Google access token from Token Vault with the necessary Calendar scopes.

        Create `server/src/lib/auth0.ts`:

        ```ts server/src/lib/auth0.ts wrap lines theme={null}
        import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
        import { Auth0AI } from "@auth0/ai-vercel";

        import type { Context } from "hono";

        import type { ToolWrapper } from "@auth0/ai-vercel";
        // Create an Auth0AI instance configured with reserver client credentials
        const auth0AI = new Auth0AI({
          auth0: {
            domain: process.env.AUTH0_DOMAIN!,
            clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!, // Resource server client ID for token exchange
            clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!, // Resource server client secret
          },
        });

        // Enhanced token exchange with Token Vault, setup with access token support
        // This demonstrates the new API pattern where access tokens can be used directly
        export const createGoogleCalendarTool = (c: Context): ToolWrapper => {
          const accessToken = c.get("auth")?.token;
          if (!accessToken) {
            throw new Error("Access token not available in auth context");
          }
          return auth0AI.withTokenVault({
            accessToken: async () => accessToken,
            subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
            connection: process.env.GOOGLE_CONNECTION_NAME || "google-oauth2",
            scopes: [
              "openid",
              "https://www.googleapis.com/auth/calendar.calendarlist.readonly", // Read-only access to calendar list
              "https://www.googleapis.com/auth/calendar.events.readonly", // Read-only access to events
            ],
          });
        };
        ```

        ### Create Hono API Chat API server with interrupt handling

        Create an AI-powered chat server using Hono, the Auth0 AI SDK, and the Vercel AI SDK that allows a user to chat with an AI assistant that can access their Google Calendar.

        The `withInterruptions()` function in the Auth0 AI SDK wraps the Vercel AI SDK `streamText()` function, enabling the Hono server to handle interrupts, which are special responses from Token Vault. An interrupt is sent if a tool call requires a new or updated access token, for example, if a user needs to re-authenticate or a new permission is needed.

        Create `server/src/index.ts`:

        ```ts server/src/index.ts wrap lines theme={null}
        import {
          convertToModelMessages,
          createUIMessageStream,
          createUIMessageStreamResponse,
          generateId,
          streamText,
        } from "ai";
        import { Hono } from "hono";
        import { cors } from "hono/cors";
        import { decodeJwt } from "jose";

        import { openai } from "@ai-sdk/openai";
        import { setAIContext } from "@auth0/ai-vercel";
        import { errorSerializer, withInterruptions } from "@auth0/ai-vercel/interrupts";
        import { serve } from "@hono/node-server";

        import { createGoogleCalendarTool } from "./lib/auth";
        import { createListUserCalendarsTool } from "./lib/tools/listUserCalendars";
        import { jwtAuthMiddleware } from "./middleware/auth";

        import type { ApiResponse } from "shared/dist";

        export const app = new Hono().post("/chat", jwtAuthMiddleware(), async (c) => {
            // auth middleware adds the auth context to the request
            const auth = c.get("auth");

            const { messages: requestMessages } = await c.req.json();

            // Generate a thread ID for this conversation
            const threadID = generateId();

            // Set AI context for the tools to access
            setAIContext({ threadID });

            // Create the Google Calendar wrapper with auth context
            const googleCalendarWrapper = createGoogleCalendarTool(c);

            // Create tools with the auth context
            const listUserCalendars = createListUserCalendarsTool(googleCalendarWrapper);

            // Use the messages from the request directly
            const tools = { listUserCalendars };

            // note: you can see more examples of Hono API consumption with AI SDK here:
            // https://ai-sdk.dev/cookbook/api-servers/hono?utm_source=chatgpt.com#hono

            const modelMessages = convertToModelMessages(requestMessages);
            const date = new Date().toISOString();

            const stream = createUIMessageStream({
              originalMessages: requestMessages,
              execute: withInterruptions(
                async ({ writer }) => {
                  const result = streamText({
                    model: openai("gpt-4o-mini"),
                    system:
                      `You are a helpful calendar assistant! You can help users with their calendar events and schedules. Keep your responses concise and helpful. Always format your responses as plain text. Do not use markdown formatting like **bold**, ##headers, or -bullet points. Use simple text formatting with line breaks and indentation only. The current date and time is ${date}.`,
                    messages: modelMessages,
                    tools,

                    onFinish: (output) => {
                      if (output.finishReason === "tool-calls") {
                        const lastMessage = output.content[output.content.length - 1];
                        if (lastMessage?.type === "tool-error") {
                          const { toolName, toolCallId, error, input } = lastMessage;
                          const serializableError = {
                            cause: error,
                            toolCallId: toolCallId,
                            toolName: toolName,
                            toolArgs: input,
                          };

                          throw serializableError;
                        }
                      }
                    },
                  });
                  writer.merge(
                    result.toUIMessageStream({
                      sendReasoning: true,
                    })
                  );
                },
                {
                  messages: requestMessages,
                  tools,
                }
              ),
              onError: errorSerializer((err) => {
                console.error("react-hono-ai-sdk route: stream error", err);
                return "Oops, an error occurred!";
              }),
            });

            return createUIMessageStreamResponse({ stream });
          });

        // Start the server for Node.js
        const port = Number(process.env.PORT) || 3000;

        console.log(`🚀 Server starting on port ${port}`);
        serve({ fetch: app.fetch, port });

        console.log(`✅ Server running on http://localhost:${port}`);
        ```

        ### Implement interrupt handling in React

        Update your chat component to handle step-up auth interrupts:

        ```tsx client/src/components/Chat.tsx wrap lines highlight={9,24,100-104,106-109} theme={null}
        import {
          DefaultChatTransport,
          lastAssistantMessageIsCompleteWithToolCalls,
        } from "ai";
        import { Loader2, Send, Trash2 } from "lucide-react";
        import { useState } from "react";

        import { useChat } from "@ai-sdk/react";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";

        import { useAuth0 } from "../hooks/useAuth0";
        import { TokenVaultConsentPopup } from "./TokenVaultConsentPopup";
        import { MarkdownText } from "./MarkdownText";
        import { Button } from "./ui/button";
        import { Card, CardContent, CardHeader, CardTitle } from "./ui/card";
        import { Input } from "./ui/input";

        import type { TextUIPart, UIMessage } from "ai";
        const SERVER_URL = import.meta.env.VITE_SERVER_URL || "http://localhost:3000";

        export function Chat() {
          const { getToken } = useAuth0();
          const [input, setInput] = useState<string>("");
          const chatHelpers = useInterruptions((errorHandler) =>
            useChat({
              transport: new DefaultChatTransport({
                api: `${SERVER_URL}/chat`,
                fetch: (async (url: string | URL | Request, init?: RequestInit) => {
                  const token = await getToken();
                  return fetch(url, {
                    ...init,
                    headers: {
                      "Content-Type": "application/json",
                      ...init?.headers,
                      Authorization: `Bearer ${token}`,
                    },
                  });
                }) as typeof fetch,
              }),
              onError: errorHandler((error) => {
                console.error("Chat error:", error);
              }),
              sendAutomaticallyWhen: lastAssistantMessageIsCompleteWithToolCalls,
            })
          );

          const { messages, sendMessage, status, error, setMessages, toolInterrupt } =
            chatHelpers;

          const clearMessages = () => {
            setMessages([]);
          };

          return (
            <Card className="w-full max-w-2xl mx-auto">
              <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                <CardTitle className="text-lg font-semibold">
                  Calendar Assistant
                </CardTitle>
                {messages.length > 0 && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={clearMessages}
                    className="h-8 w-8 p-0"
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                )}
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Messages */}
                <div className="space-y-4 max-h-96 overflow-y-auto">
                  {messages.length === 0 ? (
                    <div className="text-center text-muted-foreground py-8">
                      <p className="text-sm">Ask me about your calendar events!</p>
                      <p className="text-xs mt-1">
                        Try: "What meetings do I have today?" or "Show me my upcoming
                        events"
                      </p>
                    </div>
                  ) : (
                    messages.map((message) => (
                      <MessageBubble key={message.id} message={message} />
                    ))
                  )}
                  {status === "streaming" && (
                    <div className="flex justify-start">
                      <div className="bg-muted rounded-lg px-3 py-2 max-w-[80%] flex items-center gap-2">
                        <Loader2 className="h-4 w-4 animate-spin" />
                        <span className="text-sm text-muted-foreground">
                          Thinking...
                        </span>
                      </div>
                    </div>
                  )}
                </div>

                {/* Error message - hide if it's an Auth0 interrupt (we show the popup instead) */}
                {error && !TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                  <div className="bg-destructive/10 text-destructive text-sm p-3 rounded-lg">
                    Error: {error.message}
                  </div>
                )}

                {/* Step-Up Auth Interrupt Handling */}
                {TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                  <TokenVaultConsentPopup interrupt={toolInterrupt} />
                )}

                {/* Input form */}
                <form
                  onSubmit={(e) => {
                    e.preventDefault();
                    sendMessage({ text: input });
                    setInput("");
                  }}
                  className="flex gap-2"
                >
                  <Input
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    placeholder="Ask about your calendar..."
                    disabled={status === "streaming"}
                    className="flex-1"
                  />
                  <Button
                    className="h-10"
                    type="submit"
                    disabled={status === "streaming" || !input.trim()}
                  >
                    <Send className="h-4 w-4" />
                  </Button>
                </form>
              </CardContent>
            </Card>
          );
        }

        function MessageBubble({ message }: { message: UIMessage }) {
          const isUser = message.role === "user";

          // Get all text content from the message parts
          const textContent = message.parts
            .filter((part) => part.type === "text")
            .map((part) => (part as TextUIPart).text)
            .join("");

          return (
            <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
              <div
                className={`rounded-lg px-3 py-2 max-w-[80%] ${
                  isUser ? "bg-primary text-primary-foreground" : "bg-muted"
                }`}
              >
                {isUser ? (
                  <p className="text-sm whitespace-pre-wrap">{textContent}</p>
                ) : (
                  <div className="text-sm">
                    <MarkdownText>{textContent}</MarkdownText>
                  </div>
                )}
              </div>
            </div>
          );
        }
        ```

        ### Test your application

        1. Start the client and server using Turbo: `npm run dev`.
        2. Navigate to `http://localhost:5173`.
        3. Log in with Google and ask your AI agent about your calendar.

        The application will automatically prompt for additional calendar permissions when needed using Auth0's step-up authorization flow.

        That's it! You've successfully integrated Token Vault with access tokens into your React SPA + Vercel AI application.

        Explore [the example app on GitHub](https://github.com/auth0/auth0-ai-js/tree/main/examples/calling-apis/spa-with-backend-api/react-hono-ai-sdk).
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Next steps

You have successfully added the ability to get access tokens for tool calling to your application. For next steps:

* [Call your APIs on user's behalf docs](/intro/call-your-apis-on-users-behalf).
* Learn more about how Auth0's [Token Vault](https://auth0.com/docs/secure/tokens/token-vault) manages the tokens of supported identity providers.


# Call Your APIs on Users' Behalf
Source: https://auth0.com/ai/docs/get-started/call-your-apis-on-users-behalf

Learn how Auth0 for AI Agents enables AI agents to call first-party APIs on the user's behalf.

Let your AI agent call your APIs on behalf of the authenticated user using access tokens securely issued by Auth0. Your API can be any [API that you have configured in Auth0](https://auth0.com/docs/get-started/apis).

By the end of this quickstart, you should have an AI application integrated with Auth0 that can:

* Get an Auth0 access token.
* Use the Auth0 access token to make a tool call to your API endpoint, in this case, Auth0's `/userinfo` endpoint.
* Return the data to the user via an AI agent.

## Pick your tech stack

<Tabs>
  <Tab title="LangGraph.js + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    ### Install dependencies

    In the root directory of your project, install the following dependencies:

    * `@langchain/langgraph`: The core [LangGraph](https://js.langchain.com/docs/langgraph) module.
    * `@langchain/openai`: [OpenAI](https://js.langchain.com/docs/integrations/chat/openai) provider for LangChain.
    * `langchain`: The core [LangChain](https://js.langchain.com) module.
    * `zod`: TypeScript-first schema validation library.
    * `langgraph-nextjs-api-passthrough`: API passthrough for LangGraph.

    ```bash wrap lines theme={null}
    npm install @langchain/langgraph@0.4.4 @langchain/openai@0.6 langchain@0.3 zod@3 langgraph-nextjs-api-passthrough@0.1.4
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env.local` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Pass credentials to the agent

    You have to pass the access token from the user's session to the agent. First, create a helper function to get the access token from the session. Add the following function to `src/lib/auth0.ts`:

    ```ts src/lib/auth0.ts wrap lines highlight={11} theme={null}
    import { Auth0Client } from '@auth0/nextjs-auth0/server';

    export const auth0 = new Auth0Client({
      authorizationParameters: {
        scope: process.env.AUTH0_SCOPE,
        audience: process.env.AUTH0_AUDIENCE,
      },
    });

    export const getAccessToken = async () => {
      const tokenResult = await auth0.getAccessToken();

      if(!tokenResult || !tokenResult.token) {
        throw new Error("No access token found in Auth0 session");
      }

      return tokenResult.token;
    };
    ```

    Now, update the `/src/app/api/chat/[..._path]/route.ts` file to pass the access token to the agent:

    ```ts src/app/api/chat/[..._path]/route.ts wrap lines highlight={3,19} theme={null}
    import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";

    import { getAccessToken } from "@/lib/auth0";

    export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
      initApiPassthrough({
        apiUrl: process.env.LANGGRAPH_API_URL,
        baseRoute: "chat/",
        headers: async () => {
          const accessToken = await getAccessToken();
          return {
            Authorization: `Bearer ${accessToken}`,
          };
      });
    ```

    ### Add Custom Authentication

    <Info>
      For more information on how to add custom authentication for your LangGraph Platform application, read the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
    </Info>

    In your `langgraph.json`, add the path to your auth file:

    ```typescript langgraph.json wrap lines highlight={8} theme={null}
    {
      "node_version": "20",
      "graphs": {
        "agent": "./src/lib/agent.ts:agent"
      },
      "env": ".env",
      "auth": {
        "path": "./src/lib/auth.ts:authHandler"
      }
    }
    ```

    Then, in your `auth.ts` file, add your auth logic:

    ```typescript src/lib/auth.ts wrap lines theme={null}
    import { createRemoteJWKSet, jwtVerify } from "jose";

    const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

    const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
    const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

    // JWKS endpoint for Auth0
    const JWKS = createRemoteJWKSet(
      new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
    );

    // Create the Auth instance
    const auth = new Auth();
    // Register the authentication handler
    auth.authenticate(async (request: Request) => {
      const authHeader = request.headers.get("Authorization");
      const xApiKeyHeader = request.headers.get("x-api-key");
        /**
         * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
         * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
         *
         * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
         * or when running locally.
         */
        // This header is required in Langgraph Cloud.
        if (!authHeader && !xApiKeyHeader) {
          throw new HTTPException(401, {
            message: "Invalid auth header provided.",
          });
        }

        // prefer the xApiKeyHeader first
        let token = xApiKeyHeader || authHeader;

        // Remove "Bearer " prefix if present
        if (token && token.startsWith("Bearer ")) {
          token = token.substring(7);
        }

        // Validate Auth0 Access Token using common JWKS endpoint
        if (!token) {
          throw new HTTPException(401, {
            message:
              "Authorization header format must be of the form: Bearer <token>",
          });
        }

        if (token) {
          try {
            // Verify the JWT using Auth0 JWKS
            const { payload } = await jwtVerify(token, JWKS, {
              issuer: `https://${AUTH0_DOMAIN}/`,
              audience: AUTH0_AUDIENCE,
            });

            console.log("✅ Auth0 JWT payload resolved!", payload);

            // Return the verified payload - this becomes available in graph nodes
            return {
              identity: payload.sub!,
              email: payload.email as string,
              permissions:
                typeof payload.scope === "string" ? payload.scope.split(" ") : [],
              auth_type: "auth0",
              // include the access token for use with Auth0 Token Vault exchanges by tools
              getRawAccessToken: () => token,
              // Add any other claims you need
              ...payload,
            };
          } catch (jwtError) {
            console.log(
              "Auth0 JWT validation failed:",
              jwtError instanceof Error ? jwtError.message : "Unknown error"
            );
            throw new HTTPException(401, {
              message: "Invalid Authorization token provided.",
            });
          }
        }
    });

    export { auth as authHandler };
    ```

    ### Define a tool to call your API

    In this step, you'll create a LangChain tool to make the first-party API call. The tool fetches an access token to call the API.

    In this example, after taking in an Auth0 access token during user login, the tool returns the user profile of the currently logged-in user by calling the [/userinfo](https://auth0.com/docs/api/authentication/user-profile/get-user-info) endpoint.

    ```ts src/lib/tools/user-info.ts wrap lines highlight={6} theme={null}
    import { tool } from "@langchain/core/tools";

    export const getUserInfoTool = tool(
      async (_input, config?) => {
        // Access credentials from config
        const accessToken = config?.configurable?.langgraph_auth_user?.getRawAccessToken();
        if (!accessToken) {
          return "There is no user logged in.";
        }

        const response = await fetch(
          `https://${process.env.AUTH0_DOMAIN}/userinfo`,
          {
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          }
        );

        if (response.ok) {
          return { result: await response.json() };
        }

        return "I couldn't verify your identity";
      },
      {
        name: "get_user_info",
        description: "Get information about the current logged in user.",
      }
    );
    ```

    ### Add the tool to the AI agent

    The AI agent processes and runs the user's request through the AI pipeline, including the tool call. Update the `src/lib/agent.ts` file to add the tool to the agent.

    ```ts src/lib/agent.ts wrap lines highlight={2,8} theme={null}
    //...
    import { getUserInfoTool } from "./tools/user-info";

    //... existing code

    const tools = [
      //... existing tools
      getUserInfoTool,
    ];

    //... existing code
    ```

    You need an API Key from OpenAI or another provider to use an LLM. Add that API key to your `.env.local` file:

    ```bash .env.local wrap lines theme={null}
    # ...
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY="YOUR_API_KEY"
    ```

    If you use another provider for your LLM, adjust the variable name in `.env.local` accordingly.

    ### Test your application

    To test the application, run `npm run all:dev` and navigate to `http://localhost:3000`.

    <Note>
      This will open the LangGraph Studio in a new tab. You can close it as we won't
      require it for testing the application.
    </Note>

    To interact with the AI agent, you can ask questions like `"who am I?"` to trigger the tool call and test whether it successfully retrieves information about the logged-in user.

    ```bash wrap lines theme={null}
    User: who am I?
    AI: It seems that there is no user currently logged in. If you need assistance with anything else, feel free to ask!

    User: who am I?
    AI: You are Deepu Sasidharan. Here are your details: - .........
    ```

    That's it! You've successfully integrated first-party tool-calling into your project.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/your-api/langchain-next-js).
  </Tab>

  <Tab title="Vercel AI + Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    ### Install dependencies

    In the root directory of your project, install the following dependencies:

    * `ai`: Core [Vercel AI SDK](https://sdk.vercel.ai/docs) module that interacts with various AI model providers.
    * `@ai-sdk/openai`: [OpenAI](https://sdk.vercel.ai/providers/ai-sdk-providers/openai) provider for the Vercel AI SDK.
    * `@ai-sdk/react`: [React](https://react.dev/) UI components for the Vercel AI SDK.
    * `zod`: TypeScript-first schema validation library.

    ```bash wrap lines theme={null}
    npm install ai@5.0.33 @ai-sdk/openai@2.0.24 @ai-sdk/react@2.0.33 zod@3.25.76
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env.local` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Define a tool to call your API

    In this step, you'll create a Vercel AI tool to make the first-party API call. The tool fetches an access token to call the API.

    In this example, after taking in an Auth0 access token during user login, the tool returns the user profile of the currently logged-in user by calling the [/userinfo](https://auth0.com/docs/api/authentication/user-profile/get-user-info) endpoint.

    ```ts src/lib/tools/user-info.ts wrap lines theme={null}
    import { tool } from "ai";
    import { z } from "zod";

    import { auth0 } from "../auth0";

    export const getUserInfoTool = tool({
      description: "Get information about the current logged in user.",
      inputSchema: z.object({}),
      execute: async () => {
        const session = await auth0.getSession();
        if (!session) {
          return "There is no user logged in.";
        }

        const response = await fetch(
          `https://${process.env.AUTH0_DOMAIN}/userinfo`,
          {
            headers: {
              Authorization: `Bearer ${session.tokenSet.accessToken}`,
            },
          }
        );

        if (response.ok) {
          return { result: await response.json() };
        }

        return "I couldn't verify your identity";
      },
    });
    ```

    ### Add the tool to the AI agent

    The AI agent processes and runs the user's request through the AI pipeline, including the tool call. Vercel AI simplifies this task with the `streamText()` method. Update the `/src/app/api/chat/route.ts` file with the following code:

    ```ts src/app/api/chat/route.ts wrap lines highlight={2,11-13,23} theme={null}
    //...
    import { getUserInfoTool } from "@/lib/tools/user-info";

    //... existing code

    export async function POST(req: NextRequest) {
      const { id, messages }: { id: string; messages: Array<UIMessage> } = await req.json();

      setAIContext({ threadID: id });

      const tools = {
        getUserInfoTool,
      };

      const stream = createUIMessageStream({
        originalMessages: messages,
        execute: async ({ writer }) => {
          const result = streamText({
            model: openai('gpt-4o-mini'),
            system: AGENT_SYSTEM_TEMPLATE,
            messages: convertToModelMessages(messages),
            stopWhen: stepCountIs(5),
            tools,
          });

          writer.merge(
            result.toUIMessageStream({
              sendReasoning: true,
            })
          );
        },
        onError: (err: any) => {
          console.log(err);
          return `An error occurred! ${err.message}`;
        },
      });

      return createUIMessageStreamResponse({ stream });
    }
    //... existing code
    ```

    You need an API Key from OpenAI or another provider to use an LLM. Add that API key to your `.env.local` file:

    ```bash .env.local wrap lines theme={null}
    # ...
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY="YOUR_API_KEY"
    ```

    If you use another provider for your LLM, adjust the variable name in `.env.local` accordingly.

    ### Test your application

    To test the application, run `npm run dev` and navigate to `http://localhost:3000`. To interact with the AI agent, you can ask questions like `"who am I?"` to trigger the tool call and test whether it successfully retrieves information about the logged-in user.

    ```bash wrap lines theme={null}
    User: who am I?
    AI: It seems that there is no user currently logged in. If you need assistance with anything else, feel free to ask!

    User: who am I?
    AI: You are Deepu Sasidharan. Here are your details: - .........
    ```

    That's it! You've successfully integrated first-party tool-calling into your project.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/your-api/vercel-ai-next-js).
  </Tab>

  <Tab title="LangGraph + FastAPI" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    The project is divided into two parts:

    * `backend/`: contains the backend code for the Web app and API written in Python using FastAPI and the LangGraph agent.
    * `frontend/`: contains the frontend code for the Web app written in React as a Vite SPA.

    ### Install dependencies

    In the `backend` directory of your project, install the following dependencies:

    * `langgraph`: [LangGraph](https://pypi.org/project/langgraph/) for building stateful, multi-actor applications with LLMs.
    * `langchain-openai`: LangChain integrations for OpenAI.
    * `langgraph-cli`: LangGraph CLI for running a local LangGraph server.

    Make sure you have [uv](https://docs.astral.sh/uv/) installed and run the following command to install the dependencies:

    ```bash wrap lines theme={null}
    cd backend
    uv sync
    uv add langgraph langchain-openai "langgraph-cli[inmem]"
    ```

    ### Update the environment file

    Copy the `.env.example` file to `.env` and update the variables with your Auth0 credentials. You can find your Auth0 domain, client ID, and client secret in the application you created in the Auth0 Dashboard.

    ### Pass credentials to the agent

    First, you have to pass the access token from the user's session to the agent. The FastAPI backend will proxy requests to the LangGraph server with the user's credentials.

    Update the API route to pass the access token to the agent in `app/api/routes/chat.py`:

    ```python app/api/routes/chat.py wrap lines highlight={2,9,21-23} theme={null}
    # ...
    from app.core.auth import auth_client
    # ...

    @agent_router.api_route(
        "/{full_path:path}", methods=["GET", "POST", "DELETE", "PATCH", "PUT", "OPTIONS"]
    )
    async def api_route(
        request: Request, full_path: str, auth_session=Depends(auth_client.require_session)
    ):
        try:
            # ... existing code

            # Prepare body
            body = await request.body()
            if request.method in ("POST", "PUT", "PATCH") and body:
                content = await request.json()
                content["config"] = {
                    "configurable": {
                        "_credentials": {
                            "access_token": auth_session.get("token_sets")[0].get(
                                "access_token"
                            ),
                        }
                    }
                }
                body = json.dumps(content).encode("utf-8")

                # ... existing code
    ```

    ### Define a tool to call your API

    In this step, you'll create a LangChain tool to make the first-party API call. The tool fetches an access token to call the API.

    In this example, after taking in an Auth0 access token during user login, the tool returns the user profile of the currently logged-in user by calling the [/userinfo](https://auth0.com/docs/api/authentication/user-profile/get-user-info) endpoint.

    Create a user info tool in `app/agents/tools/user_info.py`:

    ```python app/agents/tools/user_info.py wrap lines theme={null}
    import httpx
    from langchain_core.tools import StructuredTool
    from langchain_core.runnables.config import RunnableConfig
    from pydantic import BaseModel

    from app.core.config import settings


    class UserInfoSchema(BaseModel):
        pass


    async def get_user_info_fn(config: RunnableConfig):
        """Get information about the current logged in user from Auth0 /userinfo endpoint."""

        # Access credentials from config
        if "configurable" not in config or "_credentials" not in config["configurable"]:
            return "There is no user logged in."

        credentials = config["configurable"]["_credentials"]
        access_token = credentials.get("access_token")

        if not access_token:
            return "There is no user logged in."

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"https://{settings.AUTH0_DOMAIN}/userinfo",
                    headers={
                        "Authorization": f"Bearer {access_token}",
                    },
                )

                if response.status_code == 200:
                    user_info = response.json()
                    return f"User information: {user_info}"
                else:
                    return "I couldn't verify your identity"

        except Exception as e:
            return f"Error getting user info: {str(e)}"


    get_user_info = StructuredTool(
        name="get_user_info",
        description="Get information about the current logged in user.",
        args_schema=UserInfoSchema,
        coroutine=get_user_info_fn,
    )
    ```

    ### Add the tool to the AI agent

    The AI agent processes and runs the user's request through the AI pipeline, including the tool call. Update the `app/agents/assistant0.py` file to add the tool to the agent:

    ```python app/agents/assistant0.py wrap lines highlight={2,4} theme={null}
    # ...
    from app.agents.tools.user_info import get_user_info

    tools = [get_user_info]

    llm = ChatOpenAI(model="gpt-4.1-mini")

    # ... existing code
    agent = create_react_agent(
        llm,
        tools=ToolNode(tools, handle_tool_errors=False),
        prompt=get_prompt(),
    )
    ```

    You need an API Key from OpenAI to use the LLM. Add that API key to your `.env` file:

    ```bash .env wrap lines theme={null}
    # ...
    OPENAI_API_KEY="YOUR_API_KEY"
    ```

    If you use another provider for your LLM, adjust the variable name in `.env` accordingly.

    ### Test your application

    To test the application, start the FastAPI backend, LangGraph server, and the frontend:

    1. In a new terminal, start the FastAPI backend:

    ```bash wrap lines theme={null}
    cd backend
    source .venv/bin/activate
    fastapi dev app/main.py
    ```

    2. In another terminal, start the LangGraph server:

    ```bash wrap lines theme={null}
    cd backend
    source .venv/bin/activate
    uv pip install -U langgraph-api
    langgraph dev --port 54367 --allow-blocking
    ```

    <Note>
      This will open the LangGraph Studio in a new tab. You can close it as we won't
      require it for testing the application.
    </Note>

    3. In another terminal, start the frontend:

    ```bash wrap lines theme={null}
    cd frontend
    cp .env.example .env # Copy the `.env.example` file to `.env`.
    npm install
    npm run dev
    ```

    Visit the URL `http://localhost:5173` in your browser and interact with the AI agent. You can ask questions like `"who am I?"` to trigger the tool call and test whether it successfully retrieves information about the logged-in user.

    ```bash wrap lines theme={null}
    User: who am I?
    AI: It seems that there is no user currently logged in. If you need assistance with anything else, feel free to ask!

    User: who am I?
    AI: You are Deepu Sasidharan. Here are your details: - .........
    ```

    That's it! You've successfully integrated first-party tool-calling into your LangGraph FastAPI project.

    Explore [the example app on GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/your-api/langchain-fastapi-py).
  </Tab>

  <Tab title="Cloudflare Agents" icon="cloudflare">
    <Prerequisites />

    ### Start from our Cloudflare Agents template

    Our [Auth0 Cloudflare Agents Starter Kit](https://github.com/auth0-lab/cloudflare-agents-starter) provides a starter project that includes the necessary dependencies and configuration to get you up and running quickly.

    To create a new Cloudflare Agents project using the template, run the following command in your terminal:

    ```bash wrap lines theme={null}
    npx create-cloudflare@latest --template auth0-lab/cloudflare-agents-starter
    ```

    ### About the dependencies

    The start kit is similar to the [Cloudflare Agents starter kit](https://github.com/cloudflare/agents-starter) but includes the following dependencies to integrate with Auth0 and Vercel AI:

    * `hono`: [Hono](https://hono.dev/) Web Application framework.
    * `@auth0/auth0-hono`: [Auth0 SDK](https://github.com/auth0-lab/auth0-hono) for the Hono web framework.
    * `hono-agents`: [Hono Agents](https://github.com/cloudflare/agents/tree/main/packages/hono-agents) to add intelligent, stateful AI agents to your Hono app.
    * `@auth0/auth0-cloudflare-agents-api`: [Auth0 Cloudflare Agents API SDK](https://github.com/auth0-lab/auth0-cloudflare-agents-api) to secure Cloudflare Agents using bearer tokens from Auth0.
    * `@auth0/ai`: [Auth0 AI SDK](https://github.com/auth0/auth0-ai-js) to provide base abstractions for authentication and authorization in AI applications.
    * `@auth0/ai-vercel`: [Auth0 Vercel AI SDK](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel) to provide building blocks for using Auth0 for AI Agents with the Vercel AI SDK.
    * `@auth0/ai-cloudflare`: [Auth0 Cloudflare AI SDK](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-cloudflare) to provide building blocks for using Auth0 for AI Agents with the Cloudflare Agents API.

    **You don't need to install these dependencies manually**; they are already included in the starter kit.

    ```bash wrap lines theme={null}
    npm remove agents
    npm install hono \
      @auth0/auth0-hono \
      hono-agents \
      @auth0/auth0-cloudflare-agents-api \
      @auth0/ai-cloudflare \
      @auth0/ai-vercel \
      @auth0/ai
    ```

    ### Set up environment variables

    In the root directory of your project, copy the `.dev.vars.example` into `.dev.vars` file and configure the Auth0 and OpenAI variables.

    ```bash .dev.vars wrap lines theme={null}
    # ...
    # You can use any provider of your choice supported by Vercel AI
    OPENAI_API_KEY="OPENAI API KEY"

    #auth0
    AUTH0_DOMAIN="YOUR-ACCOUNT.us.auth0.com"
    AUTH0_CLIENT_ID="YOUR CLIENT ID"
    AUTH0_CLIENT_SECRET="YOUR CLIENT SECRET"
    AUTH0_SESSION_ENCRYPTION_KEY="RANDOM 32 CHARS"
    AUTH0_AUDIENCE="YOUR AUDIENCE"

    BASE_URL="http://localhost:3000"
    ```

    If you use another provider for your LLM, adjust the variable name in `.dev.vars` accordingly.

    #### Configure a persistent store

    For persisting Auth0 session data and other key-value pairs, you need to configure a persistent store with your Cloudflare agent worker. When constructing the `CloudflareKVStore` instance with your Cloudflare agent worker, you can use Workers KV and a [KV namespace](https://developers.cloudflare.com/kv/get-started/) as the persistent store. This enables you to store Auth0 session data and other key-value pairs with easy access from your Cloudflare agent workers.

    ```ts theme={null}
    import { CloudflareKVStore } from '@auth0/ai-cloudflare';
    ...

    return new CloudflareKVStore({ kv: this.env.YOUR_KV_NAMESPACE });
    ```

    **Note:** the `kv` prop accepts any store which implements the [`KVNamespace` interface](https://github.com/auth0/auth0-ai-js/blob/%40auth0/ai-cloudflare-v2.0.0/packages/ai-cloudflare/src/CloudflareKVStore.ts#L3-L14), so any persistent store which implements this interface will work.

    ### Define a tool to call your API

    In this step, you'll create a Vercel AI tool to make the first-party API call to the Auth0 API. You will do the same for third-party APIs.

    After taking in an Auth0 access token during user login, the Cloudflare Worker sends the token to the Cloudflare Agent using the Authorization header in every web request or WebSocket connection.

    Since the Agent defined in the class Chat in `src/agent/chat.ts` uses the **AuthAgent** trait from the `@auth0/auth0-cloudflare-agents-api` it validates the signature of the token and that it matches the audience of the Agent.

    The tool we are defining here uses the same access token to call Auth0's [`/userinfo`](https://auth0.com/docs/api/authentication/user-profile/get-user-info) endpoint.

    ```tsx src/agent/tools.ts wrap lines theme={null}
    /**
     * Tool definitions for the AI chat agent
     * Tools can either require human confirmation or execute automatically
     */
    import { tool } from "ai";
    import { z } from "zod";

    import { getCurrentAgent } from "agents";
    import { unstable_scheduleSchema } from "agents/schedule";
    import { format, toZonedTime } from "date-fns-tz";
    import { buyStock } from "./auth0-ai-sample-tools/buy-stock";
    import { checkUsersCalendar } from "./auth0-ai-sample-tools/check-user-calendar";

    /**
     * Weather information tool that requires human confirmation
     * When invoked, this will present a confirmation dialog to the user
     * The actual implementation is in the executions object below
     */
    const getWeatherInformation = tool({
      description: "show the weather in a given city to the user",
      inputSchema: z.object({ city: z.string() }),
    });

    /**
     * Local time tool that executes automatically
     * Since it includes an execute function, it will run without user confirmation
     * This is suitable for low-risk operations that don't need oversight
     */
    const getLocalTime = tool({
      description: "get the local time for a specified location",
      inputSchema: z.object({
        timeZone: z.string().describe("IANA time zone name"),
      }),
      execute: async ({ timeZone: location }) => {
        const now = new Date();
        const zonedDate = toZonedTime(now, location);
        const output = format(zonedDate, "yyyy-MM-dd HH:mm:ssXXX", {
          timeZone: location,
        });
        return output;
      },
    });

    const scheduleTask = tool({
      description: "A tool to schedule a task to be executed at a later time",
      inputSchema: unstable_scheduleSchema,
      execute: async ({ when, description }) => {
        const { agent } = getCurrentAgent();

        function throwError(msg: string): string {
          throw new Error(msg);
        }
        if (when.type === "no-schedule") {
          return "Not a valid schedule input";
        }
        const input =
          when.type === "scheduled"
            ? when.date // scheduled
            : when.type === "delayed"
              ? when.delayInSeconds // delayed
              : when.type === "cron"
                ? when.cron // cron
                : throwError("not a valid schedule input");
        try {
          agent!.schedule(input!, "executeTask" as keyof typeof agent, description);
        } catch (error) {
          console.error("error scheduling task", error);
          return `Error scheduling task: ${error}`;
        }
        return `Task scheduled for type "${when.type}" : ${input}`;
      },
    });

    /**
     * Tool to list all scheduled tasks
     * This executes automatically without requiring human confirmation
     */
    const getScheduledTasks = tool({
      description: "List all tasks that have been scheduled",
      inputSchema: z.object({}),
      execute: async () => {
        const { agent } = getCurrentAgent();

        try {
          const tasks = agent!.getSchedules();
          if (!tasks || tasks.length === 0) {
            return "No scheduled tasks found.";
          }
          return tasks;
        } catch (error) {
          console.error("Error listing scheduled tasks", error);
          return `Error listing scheduled tasks: ${error}`;
        }
      },
    });

    /**
     * Tool to cancel a scheduled task by its ID
     * This executes automatically without requiring human confirmation
     */
    const cancelScheduledTask = tool({
      description: "Cancel a scheduled task using its ID",
      inputSchema: z.object({
        taskId: z.string().describe("The ID of the task to cancel"),
      }),
      execute: async ({ taskId }) => {
        const { agent } = getCurrentAgent();
        try {
          await agent!.cancelSchedule(taskId);
          return `Task ${taskId} has been successfully canceled.`;
        } catch (error) {
          console.error("Error canceling scheduled task", error);
          return `Error canceling task ${taskId}: ${error}`;
        }
      },
    });

    /**
     * Export all available tools
     * These will be provided to the AI model to describe available capabilities
     */
    export const tools = {
      getWeatherInformation,
      getLocalTime,
      scheduleTask,
      getScheduledTasks,
      cancelScheduledTask,
      checkUsersCalendar,
      buyStock,
    };

    /**
     * Implementation of confirmation-required tools
     * This object contains the actual logic for tools that need human approval
     * Each function here corresponds to a tool above that doesn't have an execute function
     */
    export const executions = {
      getWeatherInformation: async ({ city }: { city: string }) => {
        console.log(`Getting weather information for ${city}`);
        return `The weather in ${city} is sunny`;
      },
    };
    ```

    Then in the `tools` export of the `src/agent/chat.ts` file, add the `tools` to the `allTools` array:

    ```tsx src/agent/chat.ts wrap lines theme={null}
    async onChatMessage() {
        const allTools = {
          ...tools,
          ...(this.mcp?.getAITools?.() ?? {}),
        };
        ... // The rest of the code
    ```

    ### Test your application

    To test the application, run `npm run start` and navigate to `http://localhost:3000/` and interact with the AI agent. You can ask questions like `“who am I?”` to trigger the tool call and test whether it successfully retrieves information about the logged-in user.

    ```bash wrap lines theme={null}
    User: who am I?
    AI: It seems that there is no user currently logged in. If you need assistance with anything else, feel free to ask!

    User: who am I?
    AI: You are Juan Martinez. Here are your details: - .........
    ```

    That's it! You've successfully integrated first-party tool-calling into your project.

    Explore [the starter kit on GitHub](https://github.com/auth0-lab/cloudflare-agents-starter).
  </Tab>
</Tabs>

## Next steps

* [Call your APIs on user's behalf docs](/intro/call-your-apis-on-users-behalf).
* To set up third-party tool calling, complete the
  [Call other's APIs on user's behalf](../get-started/call-others-apis-on-users-behalf) quickstart.
* To explore the Auth0 Next.js SDK, see the
  [GitHub repo](https://github.com/auth0/nextjs-auth0).


# Get Started
Source: https://auth0.com/ai/docs/get-started/overview

Start building with Auth0 for AI Agents quickstarts.

## For user authentication, calling APIs, and human-in-the-loop flows

Learn how to secure AI agents that can act on your users' behalf by authenticating them, calling internal or external APIs, and handling advanced authorization flows for critical actions that require human approval.

<Columns>
  <Card title="User Authentication" icon="user" href="./user-authentication">
    Leverage Auth0's Universal Login to enable AI agents to securely authenticate users.

    `NEXT.JS` `FASTAPI`
  </Card>

  <Card title="Call Your APIs on User's Behalf" icon="shapes" href="./call-your-apis-on-users-behalf">
    Manage tokens to enable AI agents to call first-party APIs.

    `NEXT.JS`  `FASTAPI` `VERCEL AI` `LANGGRAPH` `CLOUDFLARE AGENTS`
  </Card>

  <Card title="Call Other's APIs on User's Behalf" icon="plug" href="./call-others-apis-on-users-behalf">
    Connect AI agents to external tools, functions, and services. Auth0 handles token refreshes and exchanges without any user intervention.

    `NEXT.JS` `FASTAPI` `VERCEL AI` `LANGGRAPH`
  </Card>

  <Card title="Asynchronous Authorization" icon="clock" href="./asynchronous-authorization">
    Add human-in-the-loop controls for critical or delayed actions using secure protocols like Client-Initiated Backchannel Authentication and Pushed Authorization Requests.

    `NEXT.JS` `FASTAPI` `VERCEL AI` `LANGGRAPH`
  </Card>
</Columns>

## For access controls in Retrieval Augmented Generation (RAG) pipelines

Use the Authorization for RAG quickstart to build document and relationship-level access control in your RAG pipelines.

<Columns>
  <Card title="Authorization for RAG" icon="server" href="./authorization-for-rag">
    Use Auth0 Fine-Grained Authorization to enforce document and relationship-level access control in your Retrieval Augmented Generation (RAG) pipelines.

    `NEXT.JS` `FASTAPI` `VERCEL AI` `LANGGRAPH`
  </Card>
</Columns>


# User Authentication
Source: https://auth0.com/ai/docs/get-started/user-authentication

Learn how Auth0 for AI Agents enables AI agents to seamlessly authenticate users.

Authentication is the process of proving a user's identity before granting them access to a resource. In this quickstart, you'll learn how to bring [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) to your AI agent and leverage OAuth 2.0 and OpenID Connect to securely authenticate users.

When a user authenticates with an identity provider through Auth0, Auth0 can pass user information in an ID token to an application or AI agent to deliver a personalized experience. For example, a chatbot can greet a user with their name and display relevant information based on the user's profile.

By the end of this quickstart, you should have an application that can:

* Sign up and log in using a username and password or a Google account.
* Authenticate and authorize users using OAuth 2.0 and OpenID Connect.

## Pick your tech stack

<Tabs>
  <Tab title="Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/next-js.svg">
    <Prerequisites />

    <Tabs>
      <Tab title="Use sample app (recommended)">
        ### Download sample app

        Start by downloading and extracting the sample app. Then open in your preferred IDE.

        <DownloadQuickstartButton />

        ### Install packages

        Ensure you have `npm` installed or follow the instructions to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) in its documentation.
        In the root directory of your project, install the required packages:

        ```bash wrap lines theme={null}
        npm install
        ```

        ### Create your environment file

        In the root directory of your project, create a new `.env.local` file and add the following content:

        ```bash .env.local wrap lines theme={null}
        APP_BASE_URL='http://localhost:3000'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'
        ```

        To get your Auth0 application's `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET`, navigate to <strong>Applications > Applications </strong> in the Auth0 Dashboard and select your client application. You'll find these values in the **Basic Information** section at the top.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field:

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        ### Run your application

        Run this command to start your server:

        ```bash wrap lines theme={null}
        npm run dev
        ```

        Visit the URL `http://localhost:3000` in your browser.

        You will see:

        <Frame>
          <img alt="Auth0 login screen" />
        </Frame>

        Sign up for your application to create a new user account. You will then see a welcome message with your username. You can sign in with that account on future visits.
      </Tab>

      <Tab title="Integrate into your app">
        ### Install Auth0 Next.js SDK

        In the root directory of your project, install the [Auth0 Next.js SDK](https://github.com/auth0/nextjs-auth0):

        ```bash wrap lines theme={null}
        npm i @auth0/nextjs-auth0@4
        ```

        ### Add log in to your application

        Secure your application using the Auth0 Next.js SDK.

        #### Create your environment file

        In the root directory of your project, create or add the following content to your `.env.local` file:

        ```bash .env.local wrap lines theme={null}
        APP_BASE_URL='http://localhost:3000'
        AUTH0_SECRET='random 32 byte value'
        AUTH0_DOMAIN='<your-auth0-domain>'
        AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
        AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'
        ```

        Access your `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET` by viewing the Auth0 Application that you created in the Auth0 Dashboard and navigating to the Basic Information section at the top of the Settings tab.
        Copy each value to the matching setting.

        Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field.

        ```bash generate random 32 byte value theme={null}
        openssl rand -hex 32
        ```

        #### Create the Auth0 client

        Create a new file in the `src/lib` directory and name it `auth0.ts`. Add the following code to create a new Auth0 client:

        ```tsx src/lib/auth0.ts wrap lines theme={null}
        import { Auth0Client } from "@auth0/nextjs-auth0/server";

        // Create an Auth0 Client.
        export const auth0 = new Auth0Client();
        ```

        The Auth0 client provides methods for handling authentication, sessions, and user data.

        #### Add the authentication middleware

        The middleware intercepts incoming requests and applies Auth0's authentication logic. Create a new file in the `src` directory and name it `middleware.ts` or update your existing middleware file. Add the following code to the file:

        ```tsx src/middleware.ts wrap lines theme={null}
        import { NextRequest, NextResponse } from "next/server";
        import { auth0 } from "./lib/auth0";

        export async function middleware(request: NextRequest) {
          const authRes = await auth0.middleware(request);

          // Authentication routes — let the Auth0 middleware handle it.
          if (request.nextUrl.pathname.startsWith("/auth")) {
            return authRes;
          }

          const { origin } = new URL(request.url);
          const session = await auth0.getSession(request);

          // User does not have a session — redirect to login.
          if (!session) {
            return NextResponse.redirect(`${origin}/auth/login`);
          }
          return authRes;
        }

        export const config = {
          matcher: [
            /*
             * Match all request paths except for the ones starting with:
             * - _next/static (static files)
             * - _next/image, images (image optimization files)
             * - favicon.ico, sitemap.xml, robots.txt (metadata files)
             * - $ (root)
             */
            "/((?!_next/static|_next/image|images|favicon.[ico|png]|sitemap.xml|robots.txt|$).*)",
          ],
        };
        ```

        #### Add Log in and Sign up buttons

        Use the following code example to check if the user is signed in or not:
        It will display the **Sign up** or **Log in** buttons without a user session. If a user session exists, the app displays a welcome message with the user's name.

        ```tsx src/app/page.tsx wrap lines highlight={5,7-27, 36} theme={null}
        //...
        import { auth0 } from "@/lib/auth0";

        export default async function Home() {
          const session = await auth0.getSession();

          if (!session) {
            return (
              <div className="flex flex-col items-center justify-center min-h-[50vh] my-auto gap-4">
                <h2 className="text-xl">You are not logged in</h2>
                <div className="flex gap-4">
                  <Button asChild variant="default" size="default">
                    <a href="/auth/login" className="flex items-center gap-2">
                      <LogIn />
                      <span>Login</span>
                    </a>
                  </Button>
                  <Button asChild variant="default" size="default">
                    <a href="/auth/login?screen_hint=signup">
                      <UserPlus />
                      <span>Sign up</span>
                    </a>
                  </Button>
                </div>
              </div>
            );
          }

          //... existing code

          // applicable only if you are using the starter template
          return (
            <ChatWindow
              endpoint="api/chat"
              emoji="🤖"
              placeholder={`Hello ${session?.user?.name}, I'm your personal assistant. How can I help you today?`}
              emptyStateComponent={InfoCard}
            />
          );
        }
        ```

        ### Run your application

        Start your app, typically with this command:

        ```bash wrap lines theme={null}
        npm run dev
        ```

        Visit your app in the browser, typically at `http://localhost:3000`.

        You will see:

        <Frame>
          <img alt="Auth0 login screen" />
        </Frame>

        Sign up to your application to create a new user account. You will then see a welcome message with your user name. You can sign in with that account on future visits.

        ### View a complete example

        Want to see how it all comes together? Explore or clone the fully implemented sample application on [GitHub](https://github.com/auth0-samples/auth0-ai-samples/tree/main/authenticate-users/vercel-ai-next-js).
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="FastAPI" icon="https://mintlify-assets.b-cdn.net/auth0/FastAPI.svg">
    <Prerequisites />

    ### Download sample app

    Start by downloading and extracting the sample app. Then open in your preferred IDE.

    <DownloadQuickstartButton />

    The project is divided into these two folders:

    * `backend`: contains the backend code for the web application, an API written in Python using FastAPI and the LangGraph agent.
    * `frontend`: contains the frontend code for the web application written in React as a Vite Single Page App (SPA).

    ### Install backend packages

    In the `backend` directory of your project, install the required packages using your preferred package manager, such as `uv`. You can follow the instructions to [install uv](https://docs.astral.sh/uv/getting-started/installation/) in its documentation.

    ```bash wrap lines theme={null}
    cd backend
    uv sync
    ```

    ### Create your environment file

    In the `backend` directory of your project, create a new file and name it `.env` and add the following content:

    ```bash .env wrap lines theme={null}
    APP_BASE_URL='http://localhost:8000'
    AUTH0_SECRET='random 32 byte value'
    AUTH0_DOMAIN='<your-auth0-domain>'
    AUTH0_CLIENT_ID='<your-auth0-application-client-id>'
    AUTH0_CLIENT_SECRET='<your-auth0-application-client-secret>'
    ```

    Access your `AUTH0_DOMAIN`, `AUTH0_CLIENT_ID`, and `AUTH0_CLIENT_SECRET` by viewing the Auth0 Application that you created in the Auth0 Dashboard and navigating to the Basic Information section at the top of the Settings tab.
    Copy each value to the matching setting.

    Next, run this command to generate a random 32 byte value and copy it to the `AUTH0_SECRET` field.

    ```bash generate random 32 byte value theme={null}
    openssl rand -hex 32
    ```

    ### Install frontend packages

    Ensure you have `npm` installed or follow the instructions here to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
    Navigate to the `frontend` directory of your project and install the required packages:

    ```bash wrap lines theme={null}
    cd frontend
    npm install
    ```

    ### Run your application

    To run your application, start both the FastAPI backend and the frontend in two terminals:

    1. In one terminal, start the FastAPI backend:

    ```bash wrap lines theme={null}
    cd backend
    source .venv/bin/activate
    fastapi dev app/main.py
    ```

    2. In a second new terminal, start the frontend:

    ```bash wrap lines theme={null}
    cd frontend
    npm run dev
    ```

    Visit the URL `http://localhost:5173` in your browser.

    You will see:

    <Frame>
      <img
        alt="Auth0 login
screen"
      />
    </Frame>

    Sign up to your application to create a new user account. You will then see a welcome message with your user name. You can sign in with that account on future visits.
  </Tab>
</Tabs>

## Next steps

* To set up first-party tool calling, complete the [Call your APIs on user's behalf](../get-started/call-your-apis-on-users-behalf) quickstart.
* To set up third-party tool calling, complete the [Call other's APIs on user's behalf](../get-started/call-others-apis-on-users-behalf) quickstart.
* Learn more about [User Authentication](/intro/user-authentication).


# Glossary
Source: https://auth0.com/ai/docs/glossary

Learn about Generative AI (GenAI) and identity management concepts related to Auth0 for AI Agents.

## What is authentication and authorization?

Authentication verifies a user’s identity. Authorization grants or denies the user’s access to certain resources. To learn more, read [Authentication vs Authorization](https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization).

Auth0 secures your AI agent authentication and authorization flows with the following services:

* Authentication: [Passwordless](https://auth0.com/docs/authenticate/passwordless/passwordless-with-universal-login), [Multi-factor Authentication (MFA)](https://auth0.com/docs/secure/multi-factor-authentication), and [Single-Sign On (SSO)](https://auth0.com/docs/authenticate/single-sign-on).
* Authorization: [Role-Based Access Control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac) and [Fine-Grained Authorization (FGA)](https://docs.fga.dev/fga).

## What is fine-grained authorization?

Fine-grained authorization provides more granular control over what resources your users have access to on a server. In contrast to coarse-grained authorization such as [Role-Based Access Control (RBAC)](https://auth0.com/docs/manage-users/access-control/rbac), which defines access solely through roles, fine-grained authorization allows you to define authorization policies based on a combination of the following:

* User attributes, such as username, role, location, and more
* Actions the user wants to perform, such read, write, and delete
* Resources the user wants to access

Auth0 for AI Agents provides fine-grained authorization through [Auth0 FGA](https://docs.fga.dev/). To learn how to set up fine-grained authorization for AI agents, read [Authorization for RAG](#authorization-for-rag).

## What is GenAI?

GenAI uses generative models to produce new content such as text, images, videos, and more. Trained on large datasets, GenAI models are able to learn patterns, styles, and structures while utilizing a variety of architectures, each with strengths for specific tasks and the type of content being generated:

| **Model type**                         | **Common AI model**      | **Used for**                                         |
| -------------------------------------- | ------------------------ | ---------------------------------------------------- |
| Transformers                           | GPT, Bert, LLaMa         | Text generation, chatbots, translation               |
| GANs (Generative Adversarial Networks) | StyleGAN, BigGAN         | Image and video generation                           |
| Diffusion models                       | DALL-E, Stable Diffusion | High-quality image synthesis                         |
| RNNs and LSTMs                         | Older NLP models         | Sequence generation such as in music and simple text |

When integrated with [agentic frameworks](#what-are-agentic-frameworks), GenAI models can move beyond generating content and autonomously plan, retrieve information, and make tool calls to third-party APIs.

## What are agentic frameworks?

Agentic frameworks are software tools for developing autonomous AI agents capable of making complex decisions and managing their own workflows. Built on top of LLMs, AI agents can help with task delegation, data retrieval, tool integration, and more.

AI agents have the ability to:

* Plan: Break down complex tasks into actionable steps.
* Retrieve information: Use RAG for information retrieval.
* Dynamically reason: Dynamically evaluate actions based on constraints.
* Execute: Fetch access tokens, make tool calls, and more. To learn more, read [Call Other's APIs on the user's behalf](/get-started/call-others-apis-on-users-behalf).
* Remember and adapt: Stores context across interactions for better responses in the future.

With [Auth0 SDKs](/sdks/overview), you can easily integrate with popular agentic frameworks, including [Genkit](https://firebase.google.com/docs/genkit), [LangChain](https://www.langchain.com/), [Vercel AI](https://ai-sdk.dev/docs/introduction), and [LlamaIndex](https://www.llamaindex.ai/).

## What is Retrieval-augmented generation (RAG)?

A subset of GenAI includes large language models (LLMs) that utilize retrieval-augmented generation (RAG) to incorporate relevant information from external sources to provide more contextually accurate answers to user queries.

RAG has the following components:

<Columns>
  <Card title="Retrieval" icon="square-1">
    The model fetches relevant external documents from databases, APIs, or the
    web based on the user query.
  </Card>

  <Card title="Augmentation" icon="square-2">
    After ranking the retrieved documents based on relevancy, the most relevant
    documents are used as retrieved context in the prompt.
  </Card>

  <Card title="Generation" icon="square-3">
    The model generates a response using both its pretrained knowledge and
    retrieved context.
  </Card>
</Columns>

With [Auth0 SDKs](/sdks/overview), you can easily implement RAG in LLMs:

<Columns>
  <Card
    title="Auth0 AI with LangChain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
    href="/sdks/langchain-sdk"
  >
    Integrate with LangChain to connect LLMs with vector databases for RAG.
  </Card>

  <Card
    title="Auth0 AI with LlamaIndex"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
    href="/sdks/llamaindex-sdk"
  >
    Integrate with LlamaIndex to structure external data for better retrieval.
  </Card>
</Columns>

## Next steps

* To start building with Auth0 for AI Agents, read the [Get started](/get-started/overview) quickstarts.


# Check Google Calendar Availability
Source: https://auth0.com/ai/docs/how-tos/check-google-calendar-availability

Use OpenAI, NextJS, and the Auth0-AI SDKs to check your Google Calendar availability.

<Tabs>
  <Tab title="Javascript" icon="js">
    <Tabs>
      <Tab title="AI SDK" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
        <GoogleCalendarPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-vercel
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Google Calendar scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-vercel";
        import { auth0 } from "@/lib/auth0";

        const auth0AI = new Auth0AI();

        export const withGoogleCalendar = auth0AI.withTokenVault({
          connection: "google-oauth2",
          scopes: ["https://www.googleapis.com/auth/calendar.freebusy"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;

            return refreshToken;
          },
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with Google Calendar

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Google Calendar API.

        ```typescript ./src/lib/tools/checkUsersCalendar.ts wrap lines highlight={4-6,10,19,26-28,46-48} theme={null}
        import { addHours, formatISO } from "date-fns";
        import { GaxiosError } from "gaxios";
        import { google } from "googleapis";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withGoogleCalendar } from "@/lib/auth0-ai";
        import { tool } from "ai";
        import { z } from "zod";

        export const checkUsersCalendar = withGoogleCalendar(
          tool({
            description:
              "Check user availability on a given date time on their calendar",
            parameters: z.object({
              date: z.coerce.date(),
            }),
            execute: async ({ date }) => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              // Google SDK
              try {
                const calendar = google.calendar("v3");
                const auth = new google.auth.OAuth2();

                auth.setCredentials({
                  access_token: accessToken,
                });

                const response = await calendar.freebusy.query({
                  auth,
                  requestBody: {
                    timeMin: formatISO(date),
                    timeMax: addHours(date, 1).toISOString(),
                    timeZone: "UTC",
                    items: [{ id: "primary" }],
                  },
                });

                return {
                  available: response.data?.calendars?.primary?.busy?.length === 0,
                };
              } catch (error) {
                if (error instanceof GaxiosError) {
                  if (error.status === 401) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault connection`
                    );
                  }
                }

                throw error;
              }
            },
          })
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the Vercel AI SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={3-4,10,13,27,29} theme={null}
        import { createDataStreamResponse, Message, streamText } from "ai";
        import { checkUsersCalendar } from "@/lib/tools/";
        import { setAIContext } from "@auth0/ai-vercel";
        import { errorSerializer, withInterruptions } from "@auth0/ai-vercel/interrupts";
        import { openai } from "@ai-sdk/openai";

        export async function POST(request: Request) {
          const { id, messages} = await request.json();
          const tools = { checkUsersCalendar };
          setAIContext({ threadID: id });

          return createDataStreamResponse({
            execute: withInterruptions(
              async (dataStream) => {
                const result = streamText({
                  model: openai("gpt-4o-mini"),
                  system: "You are a friendly assistant! Keep your responses concise and helpful.",
                  messages,
                  maxSteps: 5,
                  tools,
                });

                result.mergeIntoDataStream(dataStream, {
                  sendReasoning: true,
                });
              },
              { messages, tools }
            ),
            onError: errorSerializer((err) => {
              console.log(err);
              return "Oops, an error occured!";
            }),
          });
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,10-14,25-34} theme={null}
        "use client";

        import { useChat } from "@ai-sdk/react";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        export default function Chat() {
          const { messages, handleSubmit, input, setInput, toolInterrupt } =
            useInterruptions((handler) =>
              useChat({
                onError: handler((error) => console.error("Chat error:", error)),
              })
            );

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                </div>
              ))}

              {TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                <TokenVaultConsentPopup
                  interrupt={toolInterrupt}
                  connectWidget={{
                    title: "Check your availability in Google Calendar",
                    description:"description ...",
                    action: { label: "Check" },
                  }}
                />
              )}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="Cloudflare Agents" icon="https://mintlify-assets.b-cdn.net/auth0/cloudflare.svg">
        <GoogleCalendarPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        <Note>
          If you started from the [Auth0 Cloudflare Agents starter
          kit](https://github.com/auth0-lab/cloudflare-agents-starter), you can skip
          this step as the Auth0 AI SDK is already configured.
        </Note>

        First, you must configure your Cloudflare Agent to use Auth0 and both in the Worker and in the Chat Agent itself. We recommend the following two sdks:

        * [Auth0 Hono Web SDK](https://github.com/auth0-lab/auth0-hono): for the Worker.
        * [Auth0 Cloudflare Agents API SDK](https://github.com/auth0-lab/auth0-cloudflare-agents-api) for the Chat Agent.

        You can also check our [Starter Kit](https://github.com/auth0-lab/cloudflare-agents-starter) to understand how to configure this.

        Then, you need to install the Auth0 AI SDK for Cloudflare Agents:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-vercel @auth0/ai-cloudflare @auth0/ai
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Google Calendar scopes.

        ```typescript ./src/agent/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI, setGlobalAIContext } from "@auth0/ai-vercel";
        import { getCurrentAgent } from "agents";
        import type { Chat } from "./chat";

        const getAgent = () => {
          const { agent } = getCurrentAgent<Chat>();
          if (!agent) {
            throw new Error("No agent found");
          }
          return agent;
        };

        setGlobalAIContext(() => ({ threadID: getAgent().name }));

        const auth0AI = new Auth0AI({
          store: () => {
            return getAgent().auth0AIStore;
          },
        });

        const refreshToken = async () => {
          const credentials = getAgent().getCredentials();
          return credentials?.refresh_token;
        };

        export const withGoogleCalendar = auth0AI.withTokenVault({
          refreshToken,
          connection: "google-oauth2",
          scopes: ["https://www.googleapis.com/auth/calendar.freebusy"],
        });
        ```

        ### 2. Integrate your tool with Google Calendar

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Google Calendar API.

        ```typescript ./src/agent/auth0-ai-sample-tools/check-user-calendar.ts wrap lines highlight={1-2,6,8,17,37-39} theme={null}
        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { tool } from "ai";
        import { addHours } from "date-fns";
        import { z } from "zod";
        import { withGoogleCalendar } from "../auth0-ai";

        export const checkUsersCalendar = withGoogleCalendar(
          tool({
            description:
              "Check user availability on a given date time on their calendar",
            inputSchema: z.object({
              date: z.coerce.date(),
            }),
            execute: async ({ date }) => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();
              const url = "https://www.googleapis.com/calendar/v3/freeBusy";
              const body = JSON.stringify({
                timeMin: date,
                timeMax: addHours(date, 1),
                timeZone: "UTC",
                items: [{ id: "primary" }],
              });

              const response = await fetch(url, {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${accessToken}`,
                  "Content-Type": "application/json",
                },
                body,
              });

              if (!response.ok) {
                if (response.status === 401) {
                  throw new TokenVaultError(
                    "Authorization required to access the Federated Connection"
                  );
                }
                throw new Error(
                  `Invalid response from Google Calendar API: ${
                    response.status
                  } - ${await response.text()}`
                );
              }

              const busyResp = await response.json();

              return { available: busyResp.calendars.primary.busy.length === 0 };
            },
          })
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the Vercel AI SDK via these interrupts.

        <Note>
          If you started from the [Auth0 Cloudflare Agents starter
          kit](https://github.com/auth0-lab/cloudflare-agents-starter), you can skip
          this section as the Auth0 AI SDK is already configured to handle interrupts.
        </Note>

        #### Server Side

        On the Chat agent class, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`.

        ```typescript ./src/agent/chat.ts wrap lines highlight={5-6,46,70-84,95} theme={null}
        import { openai } from "@ai-sdk/openai";
        import { CloudflareKVStore } from "@auth0/ai-cloudflare";
        import {
          errorSerializer,
          invokeTools,
          withInterruptions,
        } from "@auth0/ai-vercel/interrupts";
        import { AIChatAgent } from "agents/ai-chat-agent";
        import {
          convertToModelMessages,
          createUIMessageStream,
          createUIMessageStreamResponse,
          generateId,
          stepCountIs,
          streamText,
          type UIMessage,
        } from "ai";
        import { extend } from "flumix";
        import { executions, tools } from "./tools";
        import { processToolCalls } from "./utils";

        import { AsyncUserConfirmationResumer } from "@auth0/ai-cloudflare";
        import { AuthAgent, OwnedAgent } from "@auth0/auth0-cloudflare-agents-api";

        const model = openai("gpt-4o-2024-11-20");

        const SuperAgent = extend(AIChatAgent<Env>)
          .with(AuthAgent)
          .with(OwnedAgent)
          .with(AsyncUserConfirmationResumer)
          .build();

        export class Chat extends SuperAgent {
          messages: UIMessage[] = [];

          async onChatMessage() {
            const allTools = {
              ...tools,
              ...(this.mcp?.getAITools?.() ?? {}),
            };

            const claims = this.getClaims?.();

            const stream = createUIMessageStream({
              originalMessages: this.messages,
              execute: withInterruptions(
                async ({ writer }) => {
                  await invokeTools({
                    messages: convertToModelMessages(this.messages),
                    tools: allTools,
                  });

                  const processed = await processToolCalls({
                    messages: this.messages,
                    dataStream: writer,
                    tools: allTools,
                    executions,
                  });

                  const result = streamText({
                    model,
                    stopWhen: stepCountIs(10),
                    messages: convertToModelMessages(processed),
                    system: `You are a helpful assistant that can do various tasks...

        If the user asks to schedule a task, use the schedule tool to schedule the task.

        The name of the user is ${claims?.name ?? "unknown"}.`,
                    tools: allTools,
                    onStepFinish: (output) => {
                      if (output.finishReason === "tool-calls") {
                        const last = output.content[output.content.length - 1];
                        if (last?.type === "tool-error") {
                          const { toolName, toolCallId, error, input } = last;
                          const serializableError = {
                            cause: error,
                            toolCallId,
                            toolName,
                            toolArgs: input,
                          };
                          throw serializableError;
                        }
                      }
                    },
                  });

                  writer.merge(
                    result.toUIMessageStream({
                      sendReasoning: true,
                    })
                  );
                },
                { messages: this.messages, tools: allTools }
              ),
              onError: errorSerializer(),
            });

            return createUIMessageStreamResponse({ stream });
          }

          async executeTask(description: string) {
            await this.saveMessages([
              ...this.messages,
              {
                id: generateId(),
                role: "user",
                parts: [
                  { type: "text", text: `Running scheduled task: ${description}` },
                ],
              },
            ]);
          }

          get auth0AIStore() {
            return new CloudflareKVStore({ kv: this.env.Session });
          }
        }
        ```

        **Note about CloudflareKVStore:**

        For persisting Auth0 session data and other key-value pairs, you need to configure a persistent store with your Cloudflare agent worker. When constructing the `CloudflareKVStore` instance with your Cloudflare agent worker, you can use Workers KV and a [KV namespace](https://developers.cloudflare.com/kv/get-started/) as the persistent store. This enables you to store Auth0 session data and other key-value pairs with easy access from your Cloudflare agent workers.

        ```ts theme={null}
        import { CloudflareKVStore } from '@auth0/ai-cloudflare';
        ...

        return new CloudflareKVStore({ kv: this.env.YOUR_KV_NAMESPACE });
        ```

        **Note:** the `kv` prop accepts any store which implements the [`KVNamespace` interface](https://github.com/auth0/auth0-ai-js/blob/%40auth0/ai-cloudflare-v2.0.0/packages/ai-cloudflare/src/CloudflareKVStore.ts#L3-L14), so any persistent store which implements this interface will work.

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/client/app.tsx wrap lines highlight={4-6,14-17,24,48-71} theme={null}
        "use client";

        import { useChat } from "@ai-sdk/react";
        import { useAgentChatInterruptions } from "@auth0/ai-cloudflare/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        export default function Chat() {
          const agent = useAgent({
            agent: "chat",
            name: threadID ?? undefined,
          });

          const chat = useAgentChatInterruptions({
            agent,
            id: threadID,
          });

          const {
            messages: agentMessages,
            sendMessage: handleAgentSubmit,
            addToolResult,
            clearHistory,
            toolInterrupt,
          } = chat;

          return (
            <Layout>
              {agentMessages.map((m: UIMessage, index) => {
                const isUser = m.role === "user";

                return (
                  <div key={`${m.id}-${index}`}>
                    {showDebug && (
                      <pre className="text-xs text-muted-foreground overflow-scroll">
                        {JSON.stringify(m, null, 2)}
                      </pre>
                    )}
                    <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
                      <div
                        className={`flex gap-2 max-w-[85%] ${
                          isUser ? "flex-row-reverse" : "flex-row"
                        }`}
                      >
                        <div>
                          <div>
                            {m.parts?.map((part: any, i) => {
                              if (
                                part?.type?.startsWith("tool-") &&
                                toolInterrupt &&
                                TokenVaultInterrupt.isInterrupt(toolInterrupt)
                              ) {
                                return (
                                  <TokenVaultConsentPopup
                                    key={toolInterrupt?.toolCall?.id}
                                    interrupt={toolInterrupt}
                                    auth={{ authorizePath: "/auth/login" }}
                                    connectWidget={{
                                      icon: (
                                        <div className="bg-gray-200 p-3 rounded-lg flex-wrap">
                                          <GoogleCalendarIcon />
                                        </div>
                                      ),
                                      title: "Google Calendar Access",
                                      description:
                                        "We need access to your google Calendar in order to call this tool...",
                                      action: { label: "Grant" },
                                    }}
                                  />
                                );
                              }
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}

              <form onSubmit={handleSubmit}>
                <input
                  value={input}
                  placeholder="Say something..."
                  onChange={(e) => setInput(e.target.value)}
                />
              </form>
            </Layout>
          );
        }
        ```
      </Tab>

      <Tab title="LangGraph" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
        <GoogleCalendarPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-langchain
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Google Calendar scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
        import { Auth0AI } from "@auth0/ai-langchain";

        const auth0AI = new Auth0AI({
          auth0: {
            domain: process.env.AUTH0_DOMAIN!,
            clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!,
            clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!,
          },
        });

        const withAccessTokenForConnection = (connection: string, scopes: string[]) =>
          auth0AI.withTokenVault({
            connection,
            scopes,
            accessToken: async (_, config) => {
              return config.configurable?.langgraph_auth_user?.getRawAccessToken();
            },
            subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
          });

        export const withGoogleCalendar = withAccessTokenForConnection(
          "google-oauth2",
          ["https://www.googleapis.com/auth/calendar.freebusy"]
        );
        ```

        ### 2. Integrate your tool with Google Calendar

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Google Calendar API.

        ```typescript ./src/lib/tools/checkUsersCalendar.ts wrap lines highlight={4-6,10,13,20-22,39-41} theme={null}
        import { addHours, formatISO } from "date-fns";
        import { GaxiosError } from "gaxios";
        import { google } from "googleapis";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-langchain";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withGoogleCalendar } from "@/lib/auth0-ai";
        import { tool } from "@langchain/core/tools";
        import { z } from "zod";

        export const checkUsersCalendar = withGoogleCalendar(
          tool(async ({ date }) => {
            // Get the access token from Auth0 AI
            const accessToken = getAccessTokenFromTokenVault();

            // Google SDK
            try {
              const calendar = google.calendar("v3");
              const auth = new google.auth.OAuth2();

              auth.setCredentials({
                access_token: accessToken,
              });

              const response = await calendar.freebusy.query({
                auth,
                requestBody: {
                  timeMin: formatISO(date),
                  timeMax: addHours(date, 1).toISOString(),
                  timeZone: "UTC",
                  items: [{ id: "primary" }],
                },
              });

              return {
                available: response.data?.calendars?.primary?.busy?.length === 0,
              };
            } catch (err) {
              if (err instanceof GaxiosError && err.status === 401) {
                throw new TokenVaultError(
                  `Authorization required to access the Token Vault connection`
                );
              }
              throw err;
            }
          },
          {
            name: "check_user_calendar",
            description:
              "Use this function to check if the user is available on a certain date and time",
            schema: z.object({
              date: z.coerce.date(),
            }),
          })
        );
        ```

        Now that the tool is protected, you can pass it your LangGraph agent as part of a `ToolNode`. The agent will automatically request the access token when the tool is called.

        ```typescript src/lib/agent.ts wrap lines highlight={7,10,33,39} theme={null}
        import { AIMessage } from "@langchain/core/messages";
        import { RunnableLike } from "@langchain/core/runnables";
        import { END, InMemoryStore, MemorySaver, MessagesAnnotation, START, StateGraph } from "@langchain/langgraph";
        import { ToolNode } from "@langchain/langgraph/prebuilt";
        import { ChatOpenAI } from "@langchain/openai";

        import { checkUsersCalendar } from "@/lib/tools/checkUsersCalendar";

        const model = new ChatOpenAI({ model: "gpt-4o", }).bindTools([
          checkUsersCalendar,
        ]);

        const callLLM = async (state: typeof MessagesAnnotation.State) => {
          const response = await model.invoke(state.messages);
          return { messages: [response] };
        };

        const routeAfterLLM: RunnableLike = function (state) {
          const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
          if (!lastMessage.tool_calls?.length) {
            return END;
          }
          return "tools";
        };

        const stateGraph = new StateGraph(MessagesAnnotation)
          .addNode("callLLM", callLLM)
          .addNode(
            "tools",
            new ToolNode(
              [
                // A tool with Token Vault access
                checkUsersCalendar,
                // ... other tools
              ],
              {
                // Error handler should be disabled in order to
                // trigger interruptions from within tools.
                handleToolErrors: false,
              }
            )
          )
          .addEdge(START, "callLLM")
          .addConditionalEdges("callLLM", routeAfterLLM, [END, "tools"])
          .addEdge("tools", "callLLM");

        const checkpointer = new MemorySaver();
        const store = new InMemoryStore();

        export const graph = stateGraph.compile({
          checkpointer,
          store,
          interruptBefore: [],
          interruptAfter: [],
        });
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the Langchain SDK.

        #### Server Side

        On the server side of your Next.js application you need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the LangGraph API. Additionally, you must provide the `accessToken` in the headers.

        ```typescript ./src/app/api/langgraph/[..._path]/route.ts wrap lines theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";
        import { NextRequest } from "next/server";

        import { auth0 } from "@/lib/auth0";

        async function getAccessToken() {
          const tokenResult = await auth0.getAccessToken();
          if (!tokenResult?.token) {
            throw new Error("Error retrieving access token for langgraph api.");
          }
          return tokenResult.token;
        }

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            apiKey: process.env.LANGSMITH_API_KEY,
            runtime: "edge",
            baseRoute: "langgraph/",
            headers: async (req: NextRequest) => {
              const headers: Record<string, string> = {};
              req.headers.forEach((value, key) => {
                headers[key] = value;
              });

              const accessToken = await getAccessToken();
              headers["Authorization"] = `Bearer ${accessToken}`;
              return headers;
            },
          });


        ```

        :::info
        Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
        You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        :::

        ### Add Custom Authentication

        <Info>
          For more information on how to add custom authentication for your LangGraph Platform application, see the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
        </Info>

        In your langgraph.json, add the path to your auth file:

        ```typescript langgraph.json wrap lines highlight={8} theme={null}
        {
          "node_version": "20",
          "graphs": {
            "agent": "./src/lib/agent.ts:agent"
          },
          "env": ".env",
          "auth": {
            "path": "./src/lib/auth.ts:authHandler"
          }
        }
        ```

        Then, in your auth.ts file, add your auth logic:

        ```typescript src/lib/auth.ts wrap lines theme={null}
        import { createRemoteJWKSet, jwtVerify } from "jose";

        const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

        const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
        const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

        // JWKS endpoint for Auth0
        const JWKS = createRemoteJWKSet(
          new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
        );

        // Create the Auth instance
        const auth = new Auth();
        // Register the authentication handler
        auth.authenticate(async (request: Request) => {
          const authHeader = request.headers.get("Authorization");
          const xApiKeyHeader = request.headers.get("x-api-key");
            /**
             * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
             * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
             *
             * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
             * or when running locally.
             */
            // This header is required in Langgraph Cloud.
            if (!authHeader && !xApiKeyHeader) {
              throw new HTTPException(401, {
                message: "Invalid auth header provided.",
              });
            }

            // prefer the xApiKeyHeader first
            let token = xApiKeyHeader || authHeader;

            // Remove "Bearer " prefix if present
            if (token && token.startsWith("Bearer ")) {
              token = token.substring(7);
            }

            // Validate Auth0 Access Token using common JWKS endpoint
            if (!token) {
              throw new HTTPException(401, {
                message:
                  "Authorization header format must be of the form: Bearer <token>",
              });
            }

            if (token) {
              try {
                // Verify the JWT using Auth0 JWKS
                const { payload } = await jwtVerify(token, JWKS, {
                  issuer: `https://${AUTH0_DOMAIN}/`,
                  audience: AUTH0_AUDIENCE,
                });

                console.log("✅ Auth0 JWT payload resolved!", payload);

                // Return the verified payload - this becomes available in graph nodes
                return {
                  identity: payload.sub!,
                  email: payload.email as string,
                  permissions:
                    typeof payload.scope === "string" ? payload.scope.split(" ") : [],
                  auth_type: "auth0",
                  // include the access token for use with Auth0 Token Vault exchanges by tools
                  getRawAccessToken: () => token,
                  // Add any other claims you need
                  ...payload,
                };
              } catch (jwtError) {
                console.log(
                  "Auth0 JWT validation failed:",
                  jwtError instanceof Error ? jwtError.message : "Unknown error"
                );
                throw new HTTPException(401, {
                  message: "Invalid Authorization token provided.",
                });
              }
            }
        });

        export { auth as authHandler };
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={2-3,63-73} theme={null}
        import { useStream } from "@langchain/langgraph-sdk/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const thread = useStream({
            apiUrl: `${process.env.NEXT_PUBLIC_URL}/api/langgraph`,
            assistantId: "agent",
            threadId,
            onThreadId: setThreadId,
            onError: (err) => {
              console.dir(err);
            },
          });

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (thread.isLoading) {
              return;
            }
            setInputFocus();
          }, [thread.isLoading, setInputFocus]);

          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            thread.submit(
              { messages: [{ type: "human", content: input }] },
              {
                optimisticValues: (prev) => ({
                  messages: [
                    ...((prev?.messages as []) ?? []),
                    { type: "human", content: input, id: "temp" },
                  ],
                }),
              }
            );
            setInput("");
          };

          return (
            <div>
              {thread.messages.filter((m) => m.content && ["human", "ai"].includes(m.type)).map((message) => (
                <div key={message.id}>
                  {message.type === "human" ? "User: " : "AI: "}
                  {message.content as string}
                </div>
              ))}

              {thread.interrupt && TokenVaultInterrupt.isInterrupt(thread.interrupt.value) ? (
                <div key={thread.interrupt.ns?.join("")}>
                  <TokenVaultConsentPopup
                    interrupt={thread.interrupt.value}
                    onFinish={() => thread.submit(null)}
                    connectWidget={{
                        title: "Check your availability in Google Calendar",
                        description:"description ...",
                        action: { label: "Check" },
                      }}
                  />
                </div>
              ) : null}

              <form onSubmit={handleSubmit}>
                <input ref={inputRef} value={input} placeholder="Say something..." readOnly={thread.isLoading} disabled={thread.isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="GenKit" icon="https://mintlify-assets.b-cdn.net/auth0/genkit.svg">
        <GoogleCalendarPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-genkit
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Google Calendar scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-genkit";
        import { auth0 } from "@/lib/auth0";

        // importing GenKit instance
        import { ai } from "./genkit";

        const auth0AI = new Auth0AI({
          genkit: ai,
        });

        export const withGoogleCalendar = auth0AI.withTokenVault({
          connection: "google-oauth2",
          scopes: ["https://www.googleapis.com/auth/calendar.freebusy"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;
            return refreshToken;
          },
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with Google Calendar

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Google Calendar API.

        ```typescript ./src/lib/tools/checkUsersCalendar.ts wrap lines highlight={3-5,11,24,31-33,51-53} theme={null}
        import { addHours } from "date-fns";
        import { z } from "zod";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-genkit";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withGoogleCalendar } from "@/lib/auth0-ai";

        // importing GenKit instance
        import { ai } from "../genkit";

        export const checkUsersCalendar = ai.defineTool(
          ...withGoogleCalendar(
            {
              description:
                "Check user availability on a given date time on their calendar",
              inputSchema: z.object({
                date: z.coerce
                  .date()
                  .describe("Date to check availability for in UTC time always."),
              }),
              name: "checkUsersCalendar",
            },
            async ({ date }) => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              // Google SDK
              try {
                const calendar = google.calendar("v3");
                const auth = new google.auth.OAuth2();

                auth.setCredentials({
                  access_token: .accessToken,
                });

                const response = await calendar.freebusy.query({
                  auth,
                  requestBody: {
                    timeMin: formatISO(date),
                    timeMax: addHours(date, 1).toISOString(),
                    timeZone: "UTC",
                    items: [{ id: "primary" }],
                  },
                });

                return {
                  available: response.data?.calendars?.primary?.busy?.length === 0,
                };
              } catch (error) {
                if (error instanceof GaxiosError) {
                  if (error.status === 401) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault connection`
                    );
                  }
                }

                throw error;
              }
            }
          )
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the GenKit SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={4-5,47} theme={null}
        import { ToolRequestPart } from "genkit";
        import path from "path";
        import { ai } from "@/lib/genkit";
        import { checkUsersCalendar } from "@/lib/tools/check-user-calendar";
        import { resumeAuth0Interrupts } from "@auth0/ai-genkit";
        import { auth0 } from "@/lib/auth0";

        export async function POST(
          request: Request,
          { params }: { params: Promise<{ id: string }> }
        ) {
          const auth0Session = await auth0.getSession();
          const { id } = await params;
          const {
            message,
            interruptedToolRequest,
            timezone,
          }: {
            message?: string;
            interruptedToolRequest?: ToolRequestPart;
            timezone: { region: string; offset: number };
          } = await request.json();

          let session = await ai.loadSession(id);

          if (!session) {
            session = ai.createSession({
              sessionId: id,
            });
          }

          const tools = [checkUsersCalendar];

          const chat = session.chat({
            tools: tools,
            system: `You are a helpful assistant.
            The user's timezone is ${timezone.region} with an offset of ${timezone.offset} minutes.
            User's details: ${JSON.stringify(auth0Session?.user, null, 2)}.
            You can use the tools provided to help the user.
            You can also ask the user for more information if needed.
            Chat started at ${new Date().toISOString()}
            `,
          });

          const r = await chat.send({
            prompt: message,
            resume: resumeAuth0Interrupts(tools, interruptedToolRequest),
          });

          return Response.json({ messages: r.messages, interrupts: r.interrupts });
        }

        export async function GET(
          request: Request,
          { params }: { params: Promise<{ id: string }> }
        ) {
          const { id } = await params;

          const session = await ai.loadSession(id);

          if (!session) {
            return new Response("Session not found", {
              status: 404,
            });
          }

          const json = session.toJSON();

          if (!json?.threads?.main) {
            return new Response("Session not found", {
              status: 404,
            });
          }

          return Response.json(json.threads.main);
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-5, 120-141} theme={null}
        "use client";
        import { useQueryState } from "nuqs";
        import { FormEventHandler, useEffect, useRef, useState } from "react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";
        import Markdown from "react-markdown";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const [isLoading, setIsLoading] = useState(false);
          const [messages, setMessages] = useState<
            {
              role: "user" | "model";
              content: [{ text?: string; metadata?: { interrupt?: any } }];
            }[]
          >([]);

          useEffect(() => {
            if (!threadId) {
              setThreadId(self.crypto.randomUUID());
            }
          }, [threadId, setThreadId]);

          useEffect(() => {
            if (!threadId) {
              return;
            }

            setIsLoading(true);

            (async () => {
              const messagesResponse = await fetch(`/api/chat/${threadId}`, {
                method: "GET",
                credentials: "include",
              });
              if (!messagesResponse.ok) {
                setMessages([]);
              } else {
                setMessages(await messagesResponse.json());
              }
              setIsLoading(false);
            })();
          }, [threadId]);

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (isLoading) {
              return;
            }
            setInputFocus();
          }, [isLoading, setInputFocus]);

          const submit = async ({
            message,
            interruptedToolRequest,
          }: {
            message?: string;
            interruptedToolRequest?: any;
          }) => {
            setIsLoading(true);
            const timezone = {
              region: Intl.DateTimeFormat().resolvedOptions().timeZone,
              offset: new Date().getTimezoneOffset(),
            };
            const response = await fetch(`/api/chat/${threadId}`, {
              method: "POST",
              credentials: "include",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ message, interruptedToolRequest, timezone }),
            });
            if (!response.ok) {
              console.error("Error sending message");
            } else {
              const { messages: messagesResponse } = await response.json();
              setMessages(messagesResponse);
            }
            setIsLoading(false);
          };

          // //When the user submits a message, add it to the list of messages and resume the conversation.
          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            setMessages((messages) => [
              ...messages,
              { role: "user", content: [{ text: input }] },
            ]);
            submit({ message: input });
            setInput("");
          };

          return (
            <div>
              {messages
                .filter(
                  (m) =>
                    ["model", "user", "tool"].includes(m.role) &&
                    m.content?.length > 0 &&
                    (m.content[0].text || m.content[0].metadata?.interrupt)
                )
                .map((message, index) => (
                  <div key={index}>
                    <Markdown>
                      {(message.role === "user" ? "User: " : "AI: ") +
                        (message.content[0].text || "")}
                    </Markdown>
                    {!isLoading &&
                    message.content[0].metadata?.interrupt &&
                    TokenVaultInterrupt.isInterrupt(
                      message.content[0].metadata?.interrupt
                    )
                      ? (() => {
                          const interrupt: any = message.content[0].metadata?.interrupt;
                          return (
                            <div>
                              <TokenVaultConsentPopup
                                onFinish={() => submit({ interruptedToolRequest: message.content[0] })}
                                interrupt={interrupt}
                                connectWidget={{
                                  title: `Requested by: "${interrupt.toolCall.toolName}"`,
                                  description: "Description...",
                                  action: { label: "Check" },
                                }}
                              />
                            </div>
                          );
                        })()
                      : null}
                  </div>
                ))}

              <form onSubmit={handleSubmit}>
                <input value={input} ref={inputRef} placeholder="Say something..." readOnly={isLoading} disabled={isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
        <GoogleCalendarPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-llamaindex
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-llamaindex";
        import { auth0 } from "@/lib/auth0";

        const auth0AI = new Auth0AI();

        export const withGoogleCalendar = auth0AI.withTokenVault({
          connection: "google-oauth2",
          scopes: ["https://www.googleapis.com/auth/calendar.freebusy"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;

            return refreshToken;
          },
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/lib/tools/listRepositories.ts wrap lines highlight={5-7,11,15,23,42-44} theme={null}
        import { addHours, formatISO } from "date-fns";
        import { GaxiosError } from "gaxios";
        import { google } from "googleapis";
        import { tool } from "llamaindex";
        import { withGoogleCalendar } from "@/lib/auth0-ai";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-llamaindex";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { z } from "zod";

        export const checkUsersCalendar = () =>
          withGoogleCalendar(
            tool(
              async ({ date }) => {
                // Get the access token from Auth0 AI
                const accessToken = getAccessTokenFromTokenVault();

                // Google SDK
                try {
                  const calendar = google.calendar("v3");
                  const auth = new google.auth.OAuth2();

                  auth.setCredentials({
                    access_token: accessToken,
                  });

                  const response = await calendar.freebusy.query({
                    auth,
                    requestBody: {
                      timeMin: formatISO(date),
                      timeMax: addHours(date, 1).toISOString(),
                      timeZone: "UTC",
                      items: [{ id: "primary" }],
                    },
                  });

                  return {
                    available: response.data?.calendars?.primary?.busy?.length === 0,
                  };
                } catch (error) {
                  if (error instanceof GaxiosError) {
                    if (error.status === 401) {
                      throw new TokenVaultError(
                        `Authorization required to access the Token Vault connection`
                      );
                    }
                  }

                  throw error;
                }
              },
              {
                name: "checkUsersCalendar",
                description:
                  "Check user availability on a given date time on their calendar",
                parameters: z.object({
                  date: z.coerce.date(),
                }),
              }
            )
          );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the LlamaIndex SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={2-5,15,35} theme={null}
        import { createDataStreamResponse, LlamaIndexAdapter, Message, ToolExecutionError } from "ai";
        import { listRepositories } from "@/lib/tools/";
        import { setAIContext } from "@auth0/ai-llamaindex";
        import { withInterruptions } from "@auth0/ai-llamaindex/interrupts";
        import { errorSerializer } from "@auth0/ai-vercel/interrupts";
        import { OpenAIAgent } from "llamaindex";

        export async function POST(request: Request) {
          const { id, messages }: { id: string; messages: Message[] } =
            await request.json();

          setAIContext({ threadID: id });

          return createDataStreamResponse({
            execute: withInterruptions(
              async (dataStream) => {
                const agent = new OpenAIAgent({
                  systemPrompt: "You are an AI assistant",
                  tools: [listRepositories()],
                  verbose: true,
                });

                const stream = await agent.chat({
                  message: messages[messages.length - 1].content,
                  stream: true,
                });

                LlamaIndexAdapter.mergeIntoDataStream(stream as any, { dataStream });
              },
              {
                messages,
                errorType: ToolExecutionError,
              }
            ),
            onError: errorSerializer((err) => {
              console.log(err);
              return "Oops, an error occured!";
            }),
          });
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,28-38} theme={null}
        "use client";

        import { generateId } from "ai";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { useChat } from "@ai-sdk/react";

        export default function Chat() {
          const { messages, handleSubmit, input, setInput, toolInterrupt } =
            useInterruptions((handler) =>
              useChat({
                experimental_throttle: 100,
                sendExtraMessageFields: true,
                generateId,
                onError: handler((error) => console.error("Chat error:", error)),
              })
            );

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                  {message.parts && message.parts.length > 0 && (
                    <div>
                      {toolInterrupt?.toolCall.id.includes(message.id) &&
                        TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                          <TokenVaultConsentPopup
                            interrupt={toolInterrupt}
                            connectWidget={{
                              title: `Requested by: "${toolInterrupt.toolCall.name}"`,
                              description: "Description...",
                              action: { label: "Check" },
                            }}
                          />
                        )}
                    </div>
                  )}
                </div>
              ))}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} autoFocus />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="NextJS-Auth0" icon="https://mintlify-assets.b-cdn.net/auth0/nextjs-svgrepo-com.svg">
        <GoogleCalendarPrereqs lang="js" />

        ### 1. Before you start

        * Ensure that the Google connection in Auth0 (`google-oauth2`) has the following scopes configured:
          * `openid`
          * `profile`
          * `email`
          * `https://www.googleapis.com/auth/calendar.freebusy`

        ### 2. Integrate your tool with Google Calendar

        ```ts ./src/lib/tools/checkUsersCalendar.ts wrap lines highlight={4,12,18} theme={null}
        import { tool } from "ai";
        import { z } from 'zod';
        import { google } from "googleapis";
        import { auth0 } from "@/lib/auth0";

        export const checkUsersCalendar = tool({
          description: 'Check user availability on a given date time on their calendar',
          parameters: z.object({
            date: z.coerce.date(),
          }),
          execute: async ({ date }) => {
            const { token } = await auth0.getAccessTokenForConnection({ connection: 'google-oauth2' });

            // Google SDK
            const calendar = google.calendar("v3");
            const auth = new google.auth.OAuth2();

            auth.setCredentials({ access_token: token });

            const response = await calendar.freebusy.query({
              auth,
              requestBody: {
                timeMin: formatISO(date),
                timeMax: addHours(date, 1).toISOString(),
                timeZone: "UTC",
                items: [{ id: "primary" }],
              },
            });

            return {
              available: response.data?.calendars?.primary?.busy?.length === 0,
            };
          }
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 3. Set up the API route for the chat

        ```tsx ./src/app/api/chat/route.ts wrap lines highlight={5,16} theme={null}
        import { z } from 'zod';
        import { streamText } from "ai"
        import { openai } from "@ai-sdk/openai"
        import { google } from "googleapis";
        import { checkUsersCalendar } from "@/lib/tools/checkUsersCalendar";

        export const maxDuration = 60;

        export async function POST(req) {
          const { messages } = await req.json()

          const response = streamText({
            model: openai('gpt-4o'),
            messages,
            system: "You're a helpful AI assistant that can read events from Google Calendar",
            tools: { checkUsersCalendar }
          })
          return response.toDataStreamResponse();
        }

        ```

        ### 4. Call from the client side

        ```tsx ./src/app/page.tsx wrap lines theme={null}
        'use client';

        import { useChat } from '@ai-sdk/react';

        export default function Chat() {
          const { messages, input, handleInputChange, handleSubmit } = useChat();
          return (
            <div className="flex flex-col w-full max-w-3xl py-24 mx-auto stretch text-gray-100">
              {messages.map(message => (
                <div key={message.id} className="whitespace-pre-wrap">
                  {message.role === 'user' ? 'User: ' : 'AI: '}
                  {message.parts.map((part, i) => {
                    switch (part.type) {
                      case 'text':
                        return <div key={`${message.id}-${i}`}>{part.text}</div>;
                      case 'tool-invocation':
                        return (
                          <pre key={`${message.id}-${i}`}>
                            {JSON.stringify(part.toolInvocation, null, 2)}
                          </pre>
                        );
                    }
                  })}
                </div>
              ))}
              <form onSubmit={handleSubmit}>
                <input onChange={handleInputChange} value={input} placeholder="Say something..." className="fixed bottom-0 w-full max-w-3xl p-2 mb-8 border border-zinc-300 rounded shadow-xl text-black" />
              </form>
            </div>
          );
        }
        ```

        ### 5. Example UI

        Navigate to `https://localhost:3000` to see the chat UI:

        <img alt="Google Calendar Events Chat UI" />

        When the user sends a message like `Get me the next event`, GPT-4 interprets the request and calls the `listEvents` tool. This tool uses a Google access token (retrieved via Auth0) to fetch upcoming events from the user’s Google Calendar.

        You can extend the chat UI to display event summaries, highlight meetings, or even visualize the day’s schedule in a timeline view.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Python" icon="python">
    <Tabs>
      <Tab title="LangGraph" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
        <GoogleCalendarPrereqs lang="python" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        pip install auth0-ai-langchain
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Google Calendar scopes.

        ```python ./src/lib/auth0-ai.py wrap lines theme={null}
        from auth0_ai_langchain.auth0_ai import Auth0AI

        auth0_ai = Auth0AI()

        with_google = auth0_ai.with_token_vault(
            connection="google-oauth2",
            scopes=["https://www.googleapis.com/auth/calendar.freebusy"]
            # Optional: By default, the SDK will expect the refresh token from
            # the LangChain RunnableConfig (`config.configurable._credentials.refresh_token`)
            # If you want to use a different store for refresh token you can set up a getter here
            # refresh_token=lambda *_args, **_kwargs:session["user"]["refresh_token"],
        )
        ```

        ### 2. Integrate your tool with Google Calendar

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Google Calendar API.

        ```python ./src/lib/tools/check_availability.py wrap lines highlight={7-8,15,19,34,38} theme={null}
        from datetime import datetime, timedelta
        from googleapiclient.errors import HttpError
        from googleapiclient.discovery import build
        from google.oauth2.credentials import Credentials
        from pydantic import BaseModel
        from langchain_core.tools import StructuredTool
        from auth0_ai_langchain.token_vault import get_access_token_from_token_vault, TokenVaultError
        from lib.auth0_ai import with_google

        class CheckUserCalendarSchema(BaseModel):
            date: datetime

        def check_user_calendar_tool_function(date: datetime):
            # Get the access token from Auth0 AI
            access_token = get_access_token_from_token_vault()

            # Google SDK
            try:
                service = build('calendar', 'v3', credentials=Credentials(token=access_token))
                time_min = date.isoformat() + 'Z'
                time_max = (date + timedelta(hours=1)).isoformat() + 'Z'
                body = {
                    "timeMin": time_min,
                    "timeMax": time_max,
                    "timeZone": "UTC",
                    "items": [{"id": "primary"}]
                }

                freebusy_query = service.freebusy().query(body=body).execute()
                busy_times = freebusy_query['calendars']['primary'].get('busy', [])
                return {"available": len(busy_times) == 0}
            except HttpError as e:
                if e.resp.status == 401:
                    raise TokenVaultError("Authorization required to access the Token Vault API")

                raise ValueError(f"Invalid response from Google Calendar API: {response.status_code} - {response.text}")

        check_user_calendar_tool = with_google(StructuredTool(
            name="check_user_calendar",
            description="Use this function to check if the user is available on a certain date and time",
            args_schema=CheckUserCalendarSchema,
            func=check_user_calendar_tool_function,
        ))
        ```

        Now that the tool is protected, you can pass it your LangGraph agent as part of a `ToolNode`. The agent will automatically request the access token when the tool is called.

        ```python ./src/lib/agent.py wrap lines highlight={8,15,37,42} theme={null}
        from typing import Annotated, Sequence, TypedDict
        from langchain.storage import InMemoryStore
        from langchain_core.messages import AIMessage, BaseMessage
        from langchain_openai import ChatOpenAI
        from langgraph.checkpoint.memory import MemorySaver
        from langgraph.graph import END, START, StateGraph, add_messages
        from langgraph.prebuilt import ToolNode
        from tools.check_availability import check_user_calendar_tool


        class State(TypedDict):
            messages: Annotated[Sequence[BaseMessage], add_messages]

        llm = ChatOpenAI(model="gpt-4o")
        llm.bind_tools([check_user_calendar_tool])

        async def call_llm(state: State):
            response = await llm.ainvoke(state["messages"])
            return {"messages": [response]}

        def route_after_llm(state: State):
            messages = state["messages"]
            last_message = messages[-1] if messages else None

            if isinstance(last_message, AIMessage) and last_message.tool_calls:
                return "tools"
            return END

        workflow = (
            StateGraph(State)
            .add_node("call_llm", call_llm)
            .add_node(
                "tools",
                ToolNode(
                    [
                        # a tool with Token Vault access
                        check_user_calendar_tool,
                        # ... other tools
                    ],
                    # The error handler should be disabled to
                    # allow interruptions to be triggered from within tools.
                    handle_tool_errors=False
                )
            )
            .add_edge(START, "call_llm")
            .add_edge("tools", "call_llm")
            .add_conditional_edges("call_llm", route_after_llm, [END, "tools"])
        )

        graph = workflow.compile(checkpointer=MemorySaver(), store=InMemoryStore())
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the Langchain SDK.

        #### Server Side

        On the server side of your Next.js application you need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the LangGraph API. Additionally, you must provide the `refreshToken` to the Langchain's RunnableConfig from the authenticated user's session.

        ```typescript ./src/app/api/langgraph/[..._path]/route.ts wrap lines highlight={2,23-29} theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";
        import { auth0 } from "@/lib/auth0";

        const getRefreshToken = async () => {
          const session = await auth0.getSession();
          const refreshToken = session?.tokenSet.refreshToken as string;
          return refreshToken;
        };

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            apiKey: process.env.LANGSMITH_API_KEY,
            runtime: "edge",
            baseRoute: "langgraph/",
            bodyParameters: async (req, body) => {
              if (
                req.nextUrl.pathname.endsWith("/runs/stream") &&
                req.method === "POST"
              ) {
                return {
                  ...body,
                  config: {
                    configurable: {
                      _credentials: {
                        refreshToken: await getRefreshToken(),
                      },
                    },
                  },
                };
              }

              return body;
            },
          });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={2-3,62-74} theme={null}
        import { useStream } from "@langchain/langgraph-sdk/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const thread = useStream({
            apiUrl: `${process.env.NEXT_PUBLIC_URL}/api/langgraph`,
            assistantId: "agent",
            threadId,
            onThreadId: setThreadId,
            onError: (err) => {
              console.dir(err);
            },
          });

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (thread.isLoading) {
              return;
            }
            setInputFocus();
          }, [thread.isLoading, setInputFocus]);

          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            thread.submit(
              { messages: [{ type: "human", content: input }] },
              {
                optimisticValues: (prev) => ({
                  messages: [
                    ...((prev?.messages as []) ?? []),
                    { type: "human", content: input, id: "temp" },
                  ],
                }),
              }
            );
            setInput("");
          };

          return (
            <div>
              {thread.messages.filter((m) => m.content && ["human", "ai"].includes(m.type)).map((message) => (
                <div key={message.id}>
                  {message.type === "human" ? "User: " : "AI: "}
                  {message.content as string}
                </div>
              ))}

              {thread.interrupt && TokenVaultInterrupt.isInterrupt(thread.interrupt.value) ? (
                <div key={thread.interrupt.ns?.join("")}>
                  <TokenVaultConsentPopup
                    interrupt={thread.interrupt.value}
                    onFinish={() => thread.submit(null)}
                    connectWidget={{
                        title: "List GitHub respositories",
                        description:"description ...",
                        action: { label: "Check" },
                      }}
                  />
                </div>
              ) : null}

              <form onSubmit={handleSubmit}>
                <input ref={inputRef} value={input} placeholder="Say something..." readOnly={thread.isLoading} disabled={thread.isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
        <GoogleCalendarPrereqs lang="python" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        pip install auth0-ai-llamaindex
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Google Calendar scopes.

        ```python ./src/lib/auth0-ai.py wrap lines theme={null}
        from auth0_ai_llamaindex.auth0_ai import Auth0AI
        from flask import session

        auth0_ai = Auth0AI()

        with_google = auth0_ai.with_token_vault(
            connection="google-oauth2",
            scopes=["https://www.googleapis.com/auth/calendar.freebusy"],
            refresh_token=lambda *_args, **_kwargs:session["user"]["refresh_token"],
        )
        ```

        <Info>
          Here, the session is controlled by a Flask application instance. You may utilize any other framework or session store of your preference.
        </Info>

        ### 2. Integrate your tool with Google Calendar

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Google Calendar API.

        ```python ./src/lib/tools/check_availability.py wrap lines highlight={7-8,14,18,33,37} theme={null}
        from datetime import timedelta
        from googleapiclient.errors import HttpError
        from googleapiclient.discovery import build
        from google.oauth2.credentials import Credentials
        from typing import Annotated
        from llama_index.core.tools import FunctionTool
        from auth0_ai_llamaindex.token_vault import get_access_token_from_token_vault, TokenVaultError
        from src.lib.auth0_ai import with_google

        def check_user_calendar_tool_function(
            date: Annotated[str, "Date and time in ISO 8601 format."]
        ):
            # Get the access token from Auth0 AI
            access_token = get_access_token_from_token_vault()

            # Google SDK
            try:
                service = build('calendar', 'v3', credentials=Credentials(token=access_token))
                time_min = date.isoformat() + 'Z'
                time_max = (date + timedelta(hours=1)).isoformat() + 'Z'
                body = {
                    "timeMin": time_min,
                    "timeMax": time_max,
                    "timeZone": "UTC",
                    "items": [{"id": "primary"}]
                }

                freebusy_query = service.freebusy().query(body=body).execute()
                busy_times = freebusy_query['calendars']['primary'].get('busy', [])
                return {"available": len(busy_times) == 0}
            except HttpError as e:
                if e.resp.status == 401:
                    raise TokenVaultError("Authorization required to access the Token Vault API")

                raise ValueError(f"Invalid response from Google Calendar API: {response.status_code} - {response.text}")

        check_user_calendar_tool = with_google(FunctionTool.from_defaults(
            name="check_user_calendar",
            description="Use this function to check if the user is available on a certain date and time",
            fn=check_user_calendar_tool_function,
        ))
        ```

        Now that the tool is protected, you can pass it your LlamaIndex agent.

        ```python ./src/lib/agent.ts wrap lines highlight={3,13} theme={null}
        from datetime import datetime
        from llama_index.agent.openai import OpenAIAgent
        from src.lib.tools.check_availability import check_user_calendar_tool

        system_prompt = f"""You are an assistant designed to answer random user's questions.
        **Additional Guidelines**:
        - Today’s date for reference: {datetime.now().isoformat()}
        """

        agent = OpenAIAgent.from_tools(
            tools=[
                # a tool with Token Vault access
                check_user_calendar_tool
                # ... other tools
            ],
            model="gpt-4o",
            system_prompt=system_prompt
            verbose=True,
        )
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the LLamaIndex SDK.

        #### Server side

        On the server side of your Flask application you will need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the OpenAI API utilizing LlamaIndex's SDK, that has been initialized with Auth0 AI's protection enhancements for tools.

        When `TokenVaultInterrupt` error occurs, the server side will signal the front-end about the level access restrictions, and the front-end should prompt the user to trigger a new authorization (or login) request with the necessary permissions.

        ```python ./src/app.py wrap lines highlight={3-5,19-20} theme={null}
        from dotenv import load_dotenv
        from flask import Flask, request, jsonify, session
        from auth0_ai_llamaindex.auth0_ai import Auth0AI
        from auth0_ai_llamaindex.token_vault import TokenVaultInterrupt
        from src.lib.agent import agent

        load_dotenv()
        app = Flask(__name__)

        @app.route("/chat", methods=["POST"])
        async def chat():
            if "user" not in session:
                return jsonify({"error": "unauthorized"}), 401

            try:
                message = request.json.get("message")
                response = agent.achat(message)
                return jsonify({"response": str(response)})
            except TokenVaultInterrupt as e:
                return jsonify({"error": str(e.to_json())}), 403
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        ```
      </Tab>

      <Tab title="CrewAI" icon="https://mintlify-assets.b-cdn.net/auth0/crew_ai.svg">
        Coming soon!
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Account Linking

If you're integrating with Google, but users in your app or agent can sign in using other methods (e.g., a username and password or another social provider), you'll need to link these identities into a single user account. Auth0 refers to this process as [Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).

**Account Linking** logic and handling will vary depending on your app or agent. You can find an example of how to implement it in a Next.js chatbot app [here](https://github.com/auth0-lab/market0/blob/main/app/api/auth/%5Bauth0%5D/route.ts#L43). If you have questions or are looking for best practices, [join our Discord](http://discord.gg/XbQpZSF2Ys) and ask in the `#auth0-for-gen-ai` channel.


# Get Salesforce Opportunities
Source: https://auth0.com/ai/docs/how-tos/get-salesforce-opportunities

Use OpenAI, NextJS, and the Auth0-AI SDKs to get Salesforce opportunities

<Tabs>
  <Tab title="Next.js" icon="https://mintlify-assets.b-cdn.net/auth0/nextjs-svgrepo-com.svg">
    <SalesforcePrereqs lang="js" />

    ## 1. Define the Vercel AI tool and backend API route

    Create an AI tool that gets a list of opportunities from Salesforce and a backend route that uses Auth0 to get a Salesforce access token:

    * When the tool calls `auth0.getAccessTokenForConnection()`, pass `sfdc` as the connection name to get a Salesforce access token.

    ```tsx app/api/chat/route.js wrap lines theme={null}
    import { openai } from "@ai-sdk/openai";
    import { streamText, tool } from "ai";
    import { z } from "zod";
    import { auth0 } from "@/lib/auth0";

    export const maxDuration = 60;

    export async function POST(req) {
      const { messages } = await req.json();

      const system = `You're a helpful AI agent that helps analyze salesforce data`;

      const response = streamText({
        model: openai("gpt-4o"),
        messages,
        system,
        maxSteps: 10,
        tools: {
          listOpportunities: tool({
            // salesforce tool call to get a list of opportunities
            description: "Get a list of opportunities from Salesforce",
            parameters: z.object({
              limit: z
                .number()
                .default(10)
                .describe("The maximum number of opportunities to return"),
            }),
            execute: async ({ limit }) => {
              const instanceUrl = process.env.SALESFORCE_INSTANCE_URL;

              const endpoint = `query/?q=${encodeURIComponent(
                `SELECT Id, Name, StageName, CloseDate FROM Opportunity LIMIT ${limit}`
              )}`;
              const url = `${instanceUrl}/services/data/v57.0/${endpoint}`;

              // call auth0 to get the access token
              const { accessToken } = await auth0.getAccessTokenForConnection({
                connection: "sfdc",
              });

              const response = await fetch(url, {
                method: "GET",
                headers: {
                  Authorization: `Bearer ${accessToken}`,
                  "Content-Type": "application/json",
                },
              });
              return await response.json();
            },
          }),
        },
      });
      return response.toDataStreamResponse();
    }
    ```

    ## 2. Call from the frontend Chat UI

    Use the `@ai-sdk/react` hook to wire up the chat component:

    ```tsx src/components/chat.tsx wrap lines theme={null}
    "use client";
    import { useChat } from "@ai-sdk/react";
    export default function Chat() {
      const { messages, input, handleInputChange, handleSubmit } = useChat();
      return (
        <div className="flex flex-col w-full max-w-3xl py-24 mx-auto stretch text-gray-100">
          {messages.map((message) => (
            <div key={message.id} className="whitespace-pre-wrap">
              {message.role === "user" ? "User: " : "AI: "}
              {message.parts.map((part, i) => {
                switch (part.type) {
                  case "text":
                    return <div key={`${message.id}-${i}`}>{part.text}</div>;
                }
              })}
            </div>
          ))}
          <form onSubmit={handleSubmit}>
            <input
              className="fixed bottom-0 w-full max-w-3xl p-2 mb-8 border border-zinc-300 rounded shadow-xl"
              value={input}
              placeholder="Say something..."
              onChange={handleInputChange}
            />
          </form>
        </div>
      );
    }
    ```

    ## 3. Example UI

    Navigate to `https://localhost:3000` to see the chat UI:

    <Frame>
      <img
        alt="Get Salesforce Opportunities Chat
UI"
      />
    </Frame>

    You can customize the chat UI to display structured results in tables, charts, or summaries. When the user sends a message like `Get me 2 opportunities from Salesforce`, GPT-4 interprets the request and invokes the `listOpportunities` tool, which securely calls the Salesforce API using access tokens obtained via Auth0 and returns the results.
  </Tab>

  <Tab title="LangChain" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
    Coming soon!
  </Tab>

  <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
    Coming soon!
  </Tab>

  <Tab title="GenKit" icon="https://mintlify-assets.b-cdn.net/auth0/genkit.svg">
    Coming soon!
  </Tab>
</Tabs>


# List GitHub Repositories
Source: https://auth0.com/ai/docs/how-tos/list-github-repositories

Use OpenAI, NextJS, and the Auth0-AI SDKs to list your GitHub repositories

<Tabs>
  <Tab title="JavaScript" icon="js">
    <Tabs>
      <Tab title="AI SDK" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
        <GitHubPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash lines theme={null}
        npm install @auth0/ai-vercel
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-vercel";
        import { auth0 } from "@/lib/auth0";

        const auth0AI = new Auth0AI();

        export const withGitHub = auth0AI.withTokenVault({
          connection: "github",
          scopes: ["repo"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;

            return refreshToken;
          },
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/lib/tools/listRepositories.ts wrap lines highlight={2-4,9,15,19-21,31-33} theme={null}
        import { Octokit, RequestError } from "octokit";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withGitHub } from "@/lib/auth0-ai";
        import { tool } from "ai";
        import { z } from "zod";


        export const listRepositories = withGitHub(
          tool({
            description: "List respositories for the current user on GitHub",
            parameters: z.object({}),
            execute: async () => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              // GitHub SDK
              try {
                const octokit = new Octokit({
                  auth: accessToken,
                });

                const { data } = await octokit.rest.repos.listForAuthenticatedUser();

                return data.map((repo) => repo.name);
              } catch (error) {
                console.log("Error", error);

                if (error instanceof RequestError) {
                  if (error.status === 401) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault connection`
                    );
                  }
                }

                throw error;
              }
            },
          })
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the Vercel AI SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={3-4,10,13,27,29} theme={null}
        import { createDataStreamResponse, Message, streamText } from "ai";
        import { listRepositories } from "@/lib/tools/";
        import { setAIContext } from "@auth0/ai-vercel";
        import { errorSerializer, withInterruptions } from "@auth0/ai-vercel/interrupts";
        import { openai } from "@ai-sdk/openai";

        export async function POST(request: Request) {
          const { id, messages} = await request.json();
          const tools = { listRepositories };
          setAIContext({ threadID: id });

          return createDataStreamResponse({
            execute: withInterruptions(
              async (dataStream) => {
                const result = streamText({
                  model: openai("gpt-4o-mini"),
                  system: "You are a friendly assistant! Keep your responses concise and helpful.",
                  messages,
                  maxSteps: 5,
                  tools,
                });

                result.mergeIntoDataStream(dataStream, {
                  sendReasoning: true,
                });
              },
              { messages, tools }
            ),
            onError: errorSerializer((err) => {
              console.log(err);
              return "Oops, an error occured!";
            }),
          });
        }
        ```

        #### Client Side

        On this example we utilize the `TokenVaultConsentPopup` component to show a popup that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,10-14,25-34} theme={null}
        "use client";

        import { useChat } from "@ai-sdk/react";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        export default function Chat() {
          const { messages, handleSubmit, input, setInput, toolInterrupt } =
            useInterruptions((handler) =>
              useChat({
                onError: handler((error) => console.error("Chat error:", error)),
              })
            );

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                </div>
              ))}

              {TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                <TokenVaultConsentPopup
                  interrupt={toolInterrupt}
                  connectWidget={{
                    title: "List GitHub respositories",
                    description:"description ...",
                    action: { label: "Check" },
                  }}
                />
              )}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="Cloudflare Agents" icon="https://mintlify-assets.b-cdn.net/auth0/cloudflare.svg">
        <GitHubPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        <Note>
          If you started from the [Auth0 Cloudflare Agents starter kit](https://github.com/auth0-lab/cloudflare-agents-starter), you can skip this step as the Auth0 AI SDK is already configured.
        </Note>

        First, you must configure your Cloudflare Agent to use Auth0 and both in the Worker and in the Chat Agent itself. We recommend the following two sdks:

        * [Auth0 Hono Web SDK](https://github.com/auth0-lab/auth0-hono): for the Worker.
        * [Auth0 Cloudflare Agents API SDK](https://github.com/auth0-lab/auth0-cloudflare-agents-api) for the Chat Agent.

        You can also check our [Starter Kit](https://github.com/auth0-lab/cloudflare-agents-starter) to understand how to configure this.

        Then, you need to install the Auth0 AI SDK for Cloudflare Agents:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-vercel @auth0/ai-cloudflare @auth0/ai
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/agent/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI, setGlobalAIContext } from "@auth0/ai-vercel";
        import { getCurrentAgent } from "agents";

        setGlobalAIContext(() => ({ threadID: getAgent().name }));

        const auth0AI = new Auth0AI({
          store: () => {
            return (getAgent() as any).auth0AIStore;
          },
        });

        const getAgent = () => {
          const { agent } = getCurrentAgent();
          if (!agent) {
            throw new Error("No agent found");
          }
          return agent;
        };

        const refreshToken = async () => {
          const credentials = getAgent().getCredentials();
          return credentials?.refresh_token;
        };

        export const withGitHub = auth0AI.withTokenVault({
          refreshToken,
          connection: "github",
          scopes: ["repo"],
        });
        ```

        ### 2. Integrate your tool with the GitHub API

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/agent/tools/listRepositories.ts wrap lines highlight={7-8,10,16,20-22,29-31} theme={null}
        import { tool } from "ai";
        import { z } from "zod/v3";

        import { Octokit, RequestError } from "octokit";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { Octokit, RequestError } from "octokit";
        import { withGitHub } from "@/agent/auth0-ai";

        export const listRepositories = withGitHub(
          tool({
            description: "List respositories for the current user on GitHub",
            inputSchema: z.object({}),
            execute: async () => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              // GitHub SDK
              try {
                const octokit = new Octokit({
                  auth: accessToken,
                });
                const { data } = await octokit.rest.repos.listForAuthenticatedUser();

                return data.map((repo) => repo.name);
              } catch (error) {
                if (error instanceof RequestError) {
                  if (error.status === 401) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault`
                    );
                  }
                }

                throw error;
              }
            },
          })
        );

        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the Vercel AI SDK via these interrupts.

        <Note>If you started from the [Auth0 Cloudflare Agents starter kit](https://github.com/auth0-lab/cloudflare-agents-starter), you can skip this section as the Auth0 AI SDK is already configured to handle interrupts.</Note>

        #### Server Side

        On the Chat agent class, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`.

        ```typescript ./src/agent/chat.ts wrap lines highlight={4,6,46,70-84,95} theme={null}
        import { openai } from "@ai-sdk/openai";
        import { CloudflareKVStore } from "@auth0/ai-cloudflare";
        import {
          errorSerializer,
          invokeTools,
          withInterruptions,
        } from "@auth0/ai-vercel/interrupts";
        import { AIChatAgent } from "agents/ai-chat-agent";
        import {
          convertToModelMessages,
          createUIMessageStream,
          createUIMessageStreamResponse,
          generateId,
          stepCountIs,
          streamText,
          type UIMessage,
        } from "ai";
        import { extend } from "flumix";
        import { executions, tools } from "./tools";
        import { processToolCalls } from "./utils";

        import { AsyncUserConfirmationResumer } from "@auth0/ai-cloudflare";
        import { AuthAgent, OwnedAgent } from "@auth0/auth0-cloudflare-agents-api";

        const model = openai("gpt-4o-2024-11-20");

        const SuperAgent = extend(AIChatAgent<Env>)
          .with(AuthAgent)
          .with(OwnedAgent)
          .with(AsyncUserConfirmationResumer)
          .build();

        export class Chat extends SuperAgent {
          messages: UIMessage[] = [];

          async onChatMessage() {
            const allTools = {
              ...tools,
              ...(this.mcp?.getAITools?.() ?? {}),
            };

            const claims = this.getClaims?.();

            const stream = createUIMessageStream({
              originalMessages: this.messages,
              execute: withInterruptions(
                async ({ writer }) => {
                  await invokeTools({
                    messages: convertToModelMessages(this.messages),
                    tools: allTools,
                  });

                  const processed = await processToolCalls({
                    messages: this.messages,
                    dataStream: writer,
                    tools: allTools,
                    executions,
                  });

                  const result = streamText({
                    model,
                    stopWhen: stepCountIs(10),
                    messages: convertToModelMessages(processed),
                    system: `You are a helpful assistant that can do various tasks...

        If the user asks to schedule a task, use the schedule tool to schedule the task.

        The name of the user is ${claims?.name ?? "unknown"}.`,
                    tools: allTools,
                    onStepFinish: (output) => {
                      if (output.finishReason === "tool-calls") {
                        const last = output.content[output.content.length - 1];
                        if (last?.type === "tool-error") {
                          const { toolName, toolCallId, error, input } = last;
                          const serializableError = {
                            cause: error,
                            toolCallId,
                            toolName,
                            toolArgs: input,
                          };
                          throw serializableError;
                        }
                      }
                    },
                  });

                  writer.merge(
                    result.toUIMessageStream({
                      sendReasoning: true,
                    })
                  );
                },
                { messages: this.messages, tools: allTools }
              ),
              onError: errorSerializer(),
            });

            return createUIMessageStreamResponse({ stream });
          }

          async executeTask(description: string) {
            await this.saveMessages([
              ...this.messages,
              {
                id: generateId(),
                role: "user",
                parts: [
                  { type: "text", text: `Running scheduled task: ${description}` },
                ],
              },
            ]);
          }

          get auth0AIStore() {
            return new CloudflareKVStore({ kv: this.env.Session });
          }
        }
        ```

        **Note about CloudflareKVStore:**

        For persisting Auth0 session data and other key-value pairs, you need to configure a persistent store with your Cloudflare agent worker. When constructing the `CloudflareKVStore` instance with your Cloudflare agent worker, you can use Workers KV and a [KV namespace](https://developers.cloudflare.com/kv/get-started/) as the persistent store. This enables you to store Auth0 session data and other key-value pairs with easy access from your Cloudflare agent workers.

        ```ts theme={null}
        import { CloudflareKVStore } from '@auth0/ai-cloudflare';
        ...

        return new CloudflareKVStore({ kv: this.env.YOUR_KV_NAMESPACE });
        ```

        **Note:** the `kv` prop accepts any store which implements the [`KVNamespace` interface](https://github.com/auth0/auth0-ai-js/blob/%40auth0/ai-cloudflare-v2.0.0/packages/ai-cloudflare/src/CloudflareKVStore.ts#L3-L14), so any persistent store which implements this interface will work.

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/client/app.tsx wrap lines highlight={4-6,14-17,24,48-71} theme={null}
        "use client";

        import { useChat } from "@ai-sdk/react";
        import { useAgentChatInterruptions } from "@auth0/ai-cloudflare/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        export default function Chat() {
          const agent = useAgent({
            agent: "chat",
            name: threadID ?? undefined,
          });

          const chat = useAgentChatInterruptions({
            agent,
            id: threadID,
          });

          const {
            messages: agentMessages,
            sendMessage: handleAgentSubmit,
            addToolResult,
            clearHistory,
            toolInterrupt,
          } = chat;

          return (
            <Layout>
              {agentMessages.map((m: UIMessage, index) => {
                const isUser = m.role === "user";

                return (
                  <div key={`${m.id}-${index}`}>
                    {showDebug && (
                      <pre className="text-xs text-muted-foreground overflow-scroll">
                        {JSON.stringify(m, null, 2)}
                      </pre>
                    )}
                    <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
                      <div
                        className={`flex gap-2 max-w-[85%] ${
                          isUser ? "flex-row-reverse" : "flex-row"
                        }`}
                      >
                        <div>
                          <div>
                            {m.parts?.map((part: any, i) => {
                              if (
                                part?.type?.startsWith("tool-") &&
                                toolInterrupt &&
                                TokenVaultInterrupt.isInterrupt(toolInterrupt)
                              ) {
                                return (
                                  <TokenVaultConsentPopup
                                    key={toolInterrupt?.toolCall?.id}
                                    interrupt={toolInterrupt}
                                    auth={{ authorizePath: "/auth/login" }}
                                    connectWidget={{
                                      title: "Access to your GitHub repositories",
                                      description:
                                        "We need access to your GitHub repositories in order to call this tool...",
                                      action: { label: "Grant" },
                                    }}
                                  />
                                );
                              }
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })}

              <form onSubmit={handleSubmit}>
                <input
                  value={input}
                  placeholder="Say something..."
                  onChange={(e) => setInput(e.target.value)}
                />
              </form>
            </Layout>
          );
        }
        ```
      </Tab>

      <Tab title="LangGraph" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
        <GitHubPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-langchain
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
        import { Auth0AI } from "@auth0/ai-langchain";

        const auth0AI = new Auth0AI({
          auth0: {
            domain: process.env.AUTH0_DOMAIN!,
            clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!,
            clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!,
          },
        });

        const withAccessTokenForConnection = (connection: string, scopes: string[]) =>
          auth0AI.withTokenVault({
            connection,
            scopes,
            accessToken: async (_, config) => {
              return config.configurable?.langgraph_auth_user?.getRawAccessToken();
            },
            subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
          });

        export const withGitHub = withAccessTokenForConnection("github", ["repo"]);
        ```

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/lib/tools/listRepositories.ts wrap lines highlight={3-5,9,12,16-18,28-30} theme={null}
        import { Octokit } from "@octokit/rest";
        import { RequestError } from "@octokit/request-error";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-langchain";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withGitHub } from "@/lib/auth0-ai";
        import { tool } from "@langchain/core/tools";
        import { z } from "zod";

        export const listRepositories = withGitHub(
          tool(async () => {
            // Get the access token from Auth0 AI
            const accessToken = getAccessTokenFromTokenVault();

            // GitHub SDK
            try {
              const octokit = new Octokit({
                auth: accessToken,
              });

              const { data } = await octokit.rest.repos.listForAuthenticatedUser();

              return data.map((repo) => repo.name);
            } catch (error) {
              console.log("Error", error);

              if (error instanceof RequestError) {
                if (error.status === 401) {
                  throw new TokenVaultError(
                    `Authorization required to access the Token Vault connection`
                  );
                }
              }

              throw error;
            }
          },
          {
            name: "list_github_repositories",
            description: "List respositories for the current user on GitHub",
            schema: z.object({}),
          })
        );
        ```

        Now that the tool is protected, you can pass it your LangGraph agent as part of a `ToolNode`. The agent will automatically request the access token when the tool is called.

        ```typescript src/lib/agent.ts wrap lines highlight={7,10,33,39} theme={null}
        import { AIMessage } from "@langchain/core/messages";
        import { RunnableLike } from "@langchain/core/runnables";
        import { END, InMemoryStore, MemorySaver, MessagesAnnotation, START, StateGraph } from "@langchain/langgraph";
        import { ToolNode } from "@langchain/langgraph/prebuilt";
        import { ChatOpenAI } from "@langchain/openai";

        import { listRepositories } from "@/lib/tools/listRepositories";

        const model = new ChatOpenAI({ model: "gpt-4o", }).bindTools([
          listRepositories,
        ]);

        const callLLM = async (state: typeof MessagesAnnotation.State) => {
          const response = await model.invoke(state.messages);
          return { messages: [response] };
        };

        const routeAfterLLM: RunnableLike = function (state) {
          const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
          if (!lastMessage.tool_calls?.length) {
            return END;
          }
          return "tools";
        };

        const stateGraph = new StateGraph(MessagesAnnotation)
          .addNode("callLLM", callLLM)
          .addNode(
            "tools",
            new ToolNode(
              [
                // A tool with Token Vault access
                listRepositories,
                // ... other tools
              ],
              {
                // Error handler should be disabled in order to
                // trigger interruptions from within tools.
                handleToolErrors: false,
              }
            )
          )
          .addEdge(START, "callLLM")
          .addConditionalEdges("callLLM", routeAfterLLM, [END, "tools"])
          .addEdge("tools", "callLLM");

        const checkpointer = new MemorySaver();
        const store = new InMemoryStore();

        export const graph = stateGraph.compile({
          checkpointer,
          store,
          interruptBefore: [],
          interruptAfter: [],
        });
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the Langchain SDK.

        #### Server Side

        On the server side of your Next.js application you need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the LangGraph API. Additionally, you must provide the `accessToken` in the headers.

        ```typescript ./src/app/api/langgraph/[..._path]/route.ts wrap lines theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";
        import { NextRequest } from "next/server";

        import { auth0 } from "@/lib/auth0";

        async function getAccessToken() {
          const tokenResult = await auth0.getAccessToken();
          if (!tokenResult?.token) {
            throw new Error("Error retrieving access token for langgraph api.");
          }
          return tokenResult.token;
        }

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            apiKey: process.env.LANGSMITH_API_KEY,
            runtime: "edge",
            baseRoute: "langgraph/",
            headers: async (req: NextRequest) => {
              const headers: Record<string, string> = {};
              req.headers.forEach((value, key) => {
                headers[key] = value;
              });

              const accessToken = await getAccessToken();
              headers["Authorization"] = `Bearer ${accessToken}`;
              return headers;
            },
          });


        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### Add Custom Authentication

        <Info>
          For more information on how to add custom authentication for your LangGraph Platform application, see the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
        </Info>

        In your langgraph.json, add the path to your auth file:

        ```typescript langgraph.json wrap lines highlight={8} theme={null}
        {
          "node_version": "20",
          "graphs": {
            "agent": "./src/lib/agent.ts:agent"
          },
          "env": ".env",
          "auth": {
            "path": "./src/lib/auth.ts:authHandler"
          }
        }
        ```

        Then, in your auth.ts file, add your auth logic:

        ```typescript src/lib/auth.ts wrap lines theme={null}
        import { createRemoteJWKSet, jwtVerify } from "jose";

        const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

        const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
        const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

        // JWKS endpoint for Auth0
        const JWKS = createRemoteJWKSet(
          new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
        );

        // Create the Auth instance
        const auth = new Auth();
        // Register the authentication handler
        auth.authenticate(async (request: Request) => {
          const authHeader = request.headers.get("Authorization");
          const xApiKeyHeader = request.headers.get("x-api-key");
            /**
             * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
             * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
             *
             * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
             * or when running locally.
             */
            // This header is required in Langgraph Cloud.
            if (!authHeader && !xApiKeyHeader) {
              throw new HTTPException(401, {
                message: "Invalid auth header provided.",
              });
            }

            // prefer the xApiKeyHeader first
            let token = xApiKeyHeader || authHeader;

            // Remove "Bearer " prefix if present
            if (token && token.startsWith("Bearer ")) {
              token = token.substring(7);
            }

            // Validate Auth0 Access Token using common JWKS endpoint
            if (!token) {
              throw new HTTPException(401, {
                message:
                  "Authorization header format must be of the form: Bearer <token>",
              });
            }

            if (token) {
              try {
                // Verify the JWT using Auth0 JWKS
                const { payload } = await jwtVerify(token, JWKS, {
                  issuer: `https://${AUTH0_DOMAIN}/`,
                  audience: AUTH0_AUDIENCE,
                });

                console.log("✅ Auth0 JWT payload resolved!", payload);

                // Return the verified payload - this becomes available in graph nodes
                return {
                  identity: payload.sub!,
                  email: payload.email as string,
                  permissions:
                    typeof payload.scope === "string" ? payload.scope.split(" ") : [],
                  auth_type: "auth0",
                  // include the access token for use with Auth0 Token Vault exchanges by tools
                  getRawAccessToken: () => token,
                  // Add any other claims you need
                  ...payload,
                };
              } catch (jwtError) {
                console.log(
                  "Auth0 JWT validation failed:",
                  jwtError instanceof Error ? jwtError.message : "Unknown error"
                );
                throw new HTTPException(401, {
                  message: "Invalid Authorization token provided.",
                });
              }
            }
        });

        export { auth as authHandler };
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={2-3,62-74} theme={null}
        import { useStream } from "@langchain/langgraph-sdk/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const thread = useStream({
            apiUrl: `${process.env.NEXT_PUBLIC_URL}/api/langgraph`,
            assistantId: "agent",
            threadId,
            onThreadId: setThreadId,
            onError: (err) => {
              console.dir(err);
            },
          });

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (thread.isLoading) {
              return;
            }
            setInputFocus();
          }, [thread.isLoading, setInputFocus]);

          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            thread.submit(
              { messages: [{ type: "human", content: input }] },
              {
                optimisticValues: (prev) => ({
                  messages: [
                    ...((prev?.messages as []) ?? []),
                    { type: "human", content: input, id: "temp" },
                  ],
                }),
              }
            );
            setInput("");
          };

          return (
            <div>
              {thread.messages.filter((m) => m.content && ["human", "ai"].includes(m.type)).map((message) => (
                <div key={message.id}>
                  {message.type === "human" ? "User: " : "AI: "}
                  {message.content as string}
                </div>
              ))}

              {thread.interrupt && TokenVaultInterrupt.isInterrupt(thread.interrupt.value) ? (
                <div key={thread.interrupt.ns?.join("")}>
                  <TokenVaultConsentPopup
                    interrupt={thread.interrupt.value}
                    onFinish={() => thread.submit(null)}
                    connectWidget={{
                        title: "List GitHub respositories",
                        description:"description ...",
                        action: { label: "Check" },
                      }}
                  />
                </div>
              ) : null}

              <form onSubmit={handleSubmit}>
                <input ref={inputRef} value={input} placeholder="Say something..." readOnly={thread.isLoading} disabled={thread.isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="GenKit" icon="https://mintlify-assets.b-cdn.net/auth0/genkit.svg">
        <GitHubPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-genkit
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-genkit";
        import { auth0 } from "@/lib/auth0";

        // importing GenKit instance
        import { ai } from "./genkit";

        const auth0AI = new Auth0AI({
          genkit: ai,
        });

        export const withGitHub = auth0AI.withTokenVault({
          connection: "github",
          scopes: ["repo"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;
            return refreshToken;
          },
        });

        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/lib/tools/listRepositories.ts wrap lines highlight={3-5,11,19,33-35} theme={null}
        import { Octokit, RequestError } from "octokit";
        import { z } from "zod";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-genkit";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withGoogleCalendar } from "@/lib/auth0-ai";

        // importing GenKit instance
        import { ai } from "../genkit";

        export const listRepositories = ai.defineTool(
          ...withGitHub(
            {
              description: "List respositories for the current user on GitHub",
              inputSchema: z.object({}),
              name: "listRepositories",
            },
            async () => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              try {
                // GitHub SDK
                const octokit = new Octokit({
                  auth: accessToken,
                });

                const { data } = await octokit.rest.repos.listForAuthenticatedUser();

                return data.map((repo) => repo.name);
              } catch (error) {
                if (error instanceof RequestError) {
                  if (error.status === 401) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault connection`
                    );
                  }
                }

                throw error;
              }
            }
          )
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the GenKit SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={4-5,47} theme={null}
        import { ToolRequestPart } from "genkit";
        import path from "path";
        import { ai } from "@/lib/genkit";
        import { listRepositories } from "@/lib/tools/list-repositories";
        import { resumeAuth0Interrupts } from "@auth0/ai-genkit";
        import { auth0 } from "@/lib/auth0";

        export async function POST(
          request: Request,
          { params }: { params: Promise<{ id: string }> }
        ) {
          const auth0Session = await auth0.getSession();
          const { id } = await params;
          const {
            message,
            interruptedToolRequest,
            timezone,
          }: {
            message?: string;
            interruptedToolRequest?: ToolRequestPart;
            timezone: { region: string; offset: number };
          } = await request.json();

          let session = await ai.loadSession(id);

          if (!session) {
            session = ai.createSession({
              sessionId: id,
            });
          }

          const tools = [listRepositories];

          const chat = session.chat({
            tools: tools,
            system: `You are a helpful assistant.
            The user's timezone is ${timezone.region} with an offset of ${timezone.offset} minutes.
            User's details: ${JSON.stringify(auth0Session?.user, null, 2)}.
            You can use the tools provided to help the user.
            You can also ask the user for more information if needed.
            Chat started at ${new Date().toISOString()}
            `,
          });

          const r = await chat.send({
            prompt: message,
            resume: resumeAuth0Interrupts(tools, interruptedToolRequest),
          });

          return Response.json({ messages: r.messages, interrupts: r.interrupts });
        }

        export async function GET(
          request: Request,
          { params }: { params: Promise<{ id: string }> }
        ) {
          const { id } = await params;

          const session = await ai.loadSession(id);

          if (!session) {
            return new Response("Session not found", {
              status: 404,
            });
          }

          const json = session.toJSON();

          if (!json?.threads?.main) {
            return new Response("Session not found", {
              status: 404,
            });
          }

          return Response.json(json.threads.main);
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-5,120-141} theme={null}
        "use client";
        import { useQueryState } from "nuqs";
        import { FormEventHandler, useEffect, useRef, useState } from "react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";
        import Markdown from "react-markdown";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const [isLoading, setIsLoading] = useState(false);
          const [messages, setMessages] = useState<
            {
              role: "user" | "model";
              content: [{ text?: string; metadata?: { interrupt?: any } }];
            }[]
          >([]);

          useEffect(() => {
            if (!threadId) {
              setThreadId(self.crypto.randomUUID());
            }
          }, [threadId, setThreadId]);

          useEffect(() => {
            if (!threadId) {
              return;
            }

            setIsLoading(true);

            (async () => {
              const messagesResponse = await fetch(`/api/chat/${threadId}`, {
                method: "GET",
                credentials: "include",
              });
              if (!messagesResponse.ok) {
                setMessages([]);
              } else {
                setMessages(await messagesResponse.json());
              }
              setIsLoading(false);
            })();
          }, [threadId]);

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (isLoading) {
              return;
            }
            setInputFocus();
          }, [isLoading, setInputFocus]);

          const submit = async ({
            message,
            interruptedToolRequest,
          }: {
            message?: string;
            interruptedToolRequest?: any;
          }) => {
            setIsLoading(true);
            const timezone = {
              region: Intl.DateTimeFormat().resolvedOptions().timeZone,
              offset: new Date().getTimezoneOffset(),
            };
            const response = await fetch(`/api/chat/${threadId}`, {
              method: "POST",
              credentials: "include",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ message, interruptedToolRequest, timezone }),
            });
            if (!response.ok) {
              console.error("Error sending message");
            } else {
              const { messages: messagesResponse } = await response.json();
              setMessages(messagesResponse);
            }
            setIsLoading(false);
          };

          // //When the user submits a message, add it to the list of messages and resume the conversation.
          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            setMessages((messages) => [
              ...messages,
              { role: "user", content: [{ text: input }] },
            ]);
            submit({ message: input });
            setInput("");
          };

          return (
            <div>
              {messages
                .filter(
                  (m) =>
                    ["model", "user", "tool"].includes(m.role) &&
                    m.content?.length > 0 &&
                    (m.content[0].text || m.content[0].metadata?.interrupt)
                )
                .map((message, index) => (
                  <div key={index}>
                    <Markdown>
                      {(message.role === "user" ? "User: " : "AI: ") +
                        (message.content[0].text || "")}
                    </Markdown>
                    {!isLoading &&
                    message.content[0].metadata?.interrupt &&
                    TokenVaultInterrupt.isInterrupt(
                      message.content[0].metadata?.interrupt
                    )
                      ? (() => {
                          const interrupt: any = message.content[0].metadata?.interrupt;
                          return (
                            <div>
                              <TokenVaultConsentPopup
                                onFinish={() => submit({ interruptedToolRequest: message.content[0] })}
                                interrupt={interrupt}
                                connectWidget={{
                                  title: `Requested by: "${interrupt.toolCall.toolName}"`,
                                  description: "Description...",
                                  action: { label: "Check" },
                                }}
                              />
                            </div>
                          );
                        })()
                      : null}
                  </div>
                ))}

              <form onSubmit={handleSubmit}>
                <input value={input} ref={inputRef} placeholder="Say something..." readOnly={isLoading} disabled={isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
        <GitHubPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-llamaindex
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-llamaindex";
        import { auth0 } from "@/lib/auth0";

        const auth0AI = new Auth0AI();

        export const withGitHub = auth0AI.withTokenVault({
          connection: "github",
          scopes: ["repo"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;
            return refreshToken;
          },
        });

        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/lib/tools/listRepositories.ts wrap lines highlight={3-5,13,18,27-29} theme={null}
        import { Octokit, RequestError } from "octokit";
        import { z } from "zod";
        import { withGitHub } from "@/lib/auth0-ai";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { tool } from "llamaindex";

        export const listRepositories = () =>
          withGitHub(
            tool(
              async () => {
                // Get the access token from Auth0 AI
                const accessToken = getAccessTokenFromTokenVault();

                // GitHub SDK
                try {
                  const octokit = new Octokit({
                    auth: accessToken,
                  });

                  const { data } = await octokit.rest.repos.listForAuthenticatedUser();

                  return data.map((repo) => repo.name);
                } catch (error) {
                  if (error instanceof RequestError) {
                    if (error.status === 401) {
                      throw new TokenVaultError(
                        `Authorization required to access the Token Vault connection`
                      );
                    }
                  }

                  throw error;
                }
              },
              {
                name: "listRepositories",
                description: "List respositories for the current user on GitHub",
                parameters: z.object({}),
              }
            )
          );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the LlamaIndex SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={2-5,15,35} theme={null}
        import { createDataStreamResponse, LlamaIndexAdapter, Message, ToolExecutionError } from "ai";
        import { listRepositories } from "@/lib/tools/";
        import { setAIContext } from "@auth0/ai-llamaindex";
        import { withInterruptions } from "@auth0/ai-llamaindex/interrupts";
        import { errorSerializer } from "@auth0/ai-vercel/interrupts";
        import { OpenAIAgent } from "llamaindex";

        export async function POST(request: Request) {
          const { id, messages }: { id: string; messages: Message[] } =
            await request.json();

          setAIContext({ threadID: id });

          return createDataStreamResponse({
            execute: withInterruptions(
              async (dataStream) => {
                const agent = new OpenAIAgent({
                  systemPrompt: "You are an AI assistant",
                  tools: [listRepositories()],
                  verbose: true,
                });

                const stream = await agent.chat({
                  message: messages[messages.length - 1].content,
                  stream: true,
                });

                LlamaIndexAdapter.mergeIntoDataStream(stream as any, { dataStream });
              },
              {
                messages,
                errorType: ToolExecutionError,
              }
            ),
            onError: errorSerializer((err) => {
              console.log(err);
              return "Oops, an error occured!";
            }),
          });
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,28-38} theme={null}
        "use client";

        import { generateId } from "ai";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { useChat } from "@ai-sdk/react";

        export default function Chat() {
          const { messages, handleSubmit, input, setInput, toolInterrupt } =
            useInterruptions((handler) =>
              useChat({
                experimental_throttle: 100,
                sendExtraMessageFields: true,
                generateId,
                onError: handler((error) => console.error("Chat error:", error)),
              })
            );

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                  {message.parts && message.parts.length > 0 && (
                    <div>
                      {toolInterrupt?.toolCall.id.includes(message.id) &&
                        TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                          <TokenVaultConsentPopup
                            interrupt={toolInterrupt}
                            connectWidget={{
                              title: `Requested by: "${toolInterrupt.toolCall.name}"`,
                              description: "Description...",
                              action: { label: "Check" },
                            }}
                          />
                        )}
                    </div>
                  )}
                </div>
              ))}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} autoFocus />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="NextJS-Auth0" icon="https://mintlify-assets.b-cdn.net/auth0/nextjs-svgrepo-com.svg">
        <GitHubPrereqs lang="js" />

        ### 1. Before you start

        * Ensure that the GitHub connection in Auth0 (`github`) has the following scopes configured:
          * `repo`
          * `read:user`

        ### 2. Integrate your tool with GitHub

        ```ts ./src/lib/tools/listRepos.ts wrap lines highlight={5,11-12} theme={null}
        import { tool } from "ai";
        import { z } from 'zod';
        import { openai } from "@ai-sdk/openai";
        import { Octokit } from "@octokit/rest";
        import { auth0 } from "@/lib/auth0";

        export const listRepos = tool({
          description: 'List respositories for the current user on GitHub',
          parameters: z.object({}),
          execute: async () => {
            const { accessToken } = await auth0.getAccessTokenForConnection({ connection: "github" });
            const octokit = new Octokit({ auth: accessToken });

            const response = await octokit.request('GET /user/repos', {
              visibility: 'all',
            });

            const filteredRepos = response.data.map(repo => ({
              id: repo.id,
              full_name: repo.full_name,
              private: repo.private,
              owner_name: repo.owner.login,
              url: repo.html_url,
              description: repo.description,
              stars: repo.stargazers_count,
              forks: repo.forks_count,
            }));

            return filteredRepos;
          }
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 3. Set up the API route for the chat

        Create an AI tool that fetches GitHub repositories for the authenticated user using Auth0 to get a GitHub access token:

        ```tsx ./src/app/api/chat/route.ts wrap lines highlight={6,17} theme={null}
        import { z } from 'zod';
        import { streamText, tool } from "ai"
        import { openai } from "@ai-sdk/openai"
        const { Octokit } = require("@octokit/rest");

        import { listRepos } from "@/lib/tools/listRepos";

        export const maxDuration = 60;

        export async function POST(req) {
          const { messages } = await req.json()

          const response = streamText({
            model: openai('gpt-4o'),
            messages,
            system: "You're a helpful AI agent that fetches GitHub repositories",
            tools: { listRepos }
          })
          return response.toDataStreamResponse();
        }
        ```

        ### 4. Call from the client side

        ```tsx ./src/app/page.tsx wrap lines theme={null}
        'use client';

        import { useChat } from '@ai-sdk/react';

        export default function Chat() {
          const { messages, input, handleInputChange, handleSubmit } = useChat();

          return (
            <div className="flex flex-col w-full max-w-3xl py-24 mx-auto stretch text-gray-100">
              {messages.map(message => (
                <div key={message.id} className="whitespace-pre-wrap">
                  {message.role === 'user' ? 'User: ' : 'AI: '}
                  {message.parts.map((part, i) => {
                    switch (part.type) {
                      case 'text':
                        return <div key={`${message.id}-${i}`}>{part.text}</div>;
                    }
                  })}
                </div>
              ))}

              <form onSubmit={handleSubmit}>
                <input onChange={handleInputChange} value={input} placeholder="Say something..." className="fixed bottom-0 w-full max-w-3xl p-2 mb-8 border border-zinc-300 rounded shadow-xl text-black" />
              </form>
            </div>
          );
        }
        ```

        Navigate to `https://localhost:3000` to see the chat UI show an array of returned GitHub repos for the user.
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Python" icon="python">
    <Tabs>
      <Tab title="LangGraph" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
        <GitHubPrereqs lang="python" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        pip install auth0-ai-langchain
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```python ./src/lib/auth0-ai.py wrap lines theme={null}
        from auth0_ai_langchain.auth0_ai import Auth0AI

        auth0_ai = Auth0AI()

        with_github = auth0_ai.with_token_vault(
            connection="github",
            scopes=["repo"]
            # Optional: By default, the SDK will expect the refresh token from
            # the LangChain RunnableConfig (`config.configurable._credentials.refresh_token`)
            # If you want to use a different store for refresh token you can set up a getter here
            # refresh_token=lambda *_args, **_kwargs:session["user"]["refresh_token"],
        )
        ```

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```python ./src/lib/tools/list_repositories.py wrap lines highlight={5-6,13,23,25} theme={null}
        from github import Github
        from github.GithubException import BadCredentialsException
        from pydantic import BaseModel
        from langchain_core.tools import StructuredTool
        from auth0_ai_langchain.token_vault import get_access_token_from_token_vault, TokenVaultError
        from src.lib.auth0_ai import with_github

        class EmptySchema(BaseModel):
            pass

        def list_repositories_tool_function(date: datetime):
            # Get the access token from Auth0 AI
            access_token = get_access_token_from_token_vault()

            # GitHub SDK
            try:
                g = Github(access_token)
                user = g.get_user()
                repos = user.get_repos()
                repo_names = [repo.name for repo in repos]
                return repo_names
            except BadCredentialsException:
                raise TokenVaultError("Authorization required to access the Token Vault API")

        list_github_repositories_tool = with_github(StructuredTool(
            name="list_github_repositories",
            description="List respositories for the current user on GitHub",
            args_schema=EmptySchema,
            func=list_repositories_tool_function,
        ))
        ```

        Now that the tool is protected, you can pass it your LangGraph agent as part of a `ToolNode`. The agent will automatically request the access token when the tool is called.

        ```python ./src/lib/agent.py wrap lines highlight={8,15,37,42} theme={null}
        from typing import Annotated, Sequence, TypedDict
        from langchain.storage import InMemoryStore
        from langchain_core.messages import AIMessage, BaseMessage
        from langchain_openai import ChatOpenAI
        from langgraph.checkpoint.memory import MemorySaver
        from langgraph.graph import END, START, StateGraph, add_messages
        from langgraph.prebuilt import ToolNode
        from tools.list_repositories import list_github_repositories_tool


        class State(TypedDict):
            messages: Annotated[Sequence[BaseMessage], add_messages]

        llm = ChatOpenAI(model="gpt-4o")
        llm.bind_tools([list_github_repositories_tool])

        async def call_llm(state: State):
            response = await llm.ainvoke(state["messages"])
            return {"messages": [response]}

        def route_after_llm(state: State):
            messages = state["messages"]
            last_message = messages[-1] if messages else None

            if isinstance(last_message, AIMessage) and last_message.tool_calls:
                return "tools"
            return END

        workflow = (
            StateGraph(State)
            .add_node("call_llm", call_llm)
            .add_node(
                "tools",
                ToolNode(
                    [
                        # a tool with Token Vault access
                        list_github_repositories_tool,
                        # ... other tools
                    ],
                    # The error handler should be disabled to
                    # allow interruptions to be triggered from within tools.
                    handle_tool_errors=False
                )
            )
            .add_edge(START, "call_llm")
            .add_edge("tools", "call_llm")
            .add_conditional_edges("call_llm", route_after_llm, [END, "tools"])
        )

        graph = workflow.compile(checkpointer=MemorySaver(), store=InMemoryStore())
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the Langchain SDK.

        #### Server Side

        On the server side of your Next.js application you need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the LangGraph API. Additionally, you must provide the `refreshToken` to the Langchain's RunnableConfig from the authenticated user's session.

        ```typescript ./src/app/api/langgraph/[..._path]/route.ts wrap lines highlight={2,23-29} theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";
        import { auth0 } from "@/lib/auth0";

        const getRefreshToken = async () => {
          const session = await auth0.getSession();
          const refreshToken = session?.tokenSet.refreshToken as string;
          return refreshToken;
        };

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            apiKey: process.env.LANGSMITH_API_KEY,
            runtime: "edge",
            baseRoute: "langgraph/",
            bodyParameters: async (req, body) => {
              if (
                req.nextUrl.pathname.endsWith("/runs/stream") &&
                req.method === "POST"
              ) {
                return {
                  ...body,
                  config: {
                    configurable: {
                      _credentials: {
                        refreshToken: await getRefreshToken(),
                      },
                    },
                  },
                };
              }

              return body;
            },
          });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={2-3,62-74} theme={null}
        import { useStream } from "@langchain/langgraph-sdk/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const thread = useStream({
            apiUrl: `${process.env.NEXT_PUBLIC_URL}/api/langgraph`,
            assistantId: "agent",
            threadId,
            onThreadId: setThreadId,
            onError: (err) => {
              console.dir(err);
            },
          });

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (thread.isLoading) {
              return;
            }
            setInputFocus();
          }, [thread.isLoading, setInputFocus]);

          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            thread.submit(
              { messages: [{ type: "human", content: input }] },
              {
                optimisticValues: (prev) => ({
                  messages: [
                    ...((prev?.messages as []) ?? []),
                    { type: "human", content: input, id: "temp" },
                  ],
                }),
              }
            );
            setInput("");
          };

          return (
            <div>
              {thread.messages.filter((m) => m.content && ["human", "ai"].includes(m.type)).map((message) => (
                <div key={message.id}>
                  {message.type === "human" ? "User: " : "AI: "}
                  {message.content as string}
                </div>
              ))}

              {thread.interrupt && TokenVaultInterrupt.isInterrupt(thread.interrupt.value) ? (
                <div key={thread.interrupt.ns?.join("")}>
                  <TokenVaultConsentPopup
                    interrupt={thread.interrupt.value}
                    onFinish={() => thread.submit(null)}
                    connectWidget={{
                        title: "List GitHub respositories",
                        description:"description ...",
                        action: { label: "Check" },
                      }}
                  />
                </div>
              ) : null}

              <form onSubmit={handleSubmit}>
                <input ref={inputRef} value={input} placeholder="Say something..." readOnly={thread.isLoading} disabled={thread.isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
        <GitHubPrereqs lang="python" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        pip install auth0-ai-llamaindex
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```python ./src/lib/auth0-ai.py wrap lines theme={null}
        from auth0_ai_llamaindex.auth0_ai import Auth0AI
        from flask import session

        auth0_ai = Auth0AI()

        with_github = auth0_ai.with_token_vault(
            connection="github",
            scopes=["repo"],
            refresh_token=lambda *_args, **_kwargs:session["user"]["refresh_token"],
        )
        ```

        <Info>
          Here, the session is controlled by a Flask application instance. You may utilize any other framework or session store of your preference.
        </Info>

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```python ./src/lib/tools/list_repositories.py wrap lines highlight={4-5,9,19,21} theme={null}
        from github import Github
        from github.GithubException import BadCredentialsException
        from llama_index.core.tools import FunctionTool
        from auth0_ai_llamaindex.token_vault import get_access_token_from_token_vault, TokenVaultError
        from src.lib.auth0_ai import with_github

        def list_github_repositories_tool_function():
            # Get the access token from Auth0 AI
            access_token = get_access_token_from_token_vault()

            # GitHub SDK
            try:
                g = Github(access_token)
                user = g.get_user()
                repos = user.get_repos()
                repo_names = [repo.name for repo in repos]
                return repo_names
            except BadCredentialsException:
                raise TokenVaultError("Authorization required to access the Token Vault API")

        list_github_repositories_tool = with_github(FunctionTool.from_defaults(
            name="list_github_repositories",
            description="List respositories for the current user on GitHub",
            fn=list_github_repositories_tool_function,
        ))
        ```

        Now that the tool is protected, you can pass it your LlamaIndex agent.

        ```python ./src/lib/agent.ts wrap lines highlight={3,13} theme={null}
        from datetime import datetime
        from llama_index.agent.openai import OpenAIAgent
        from src.lib.tools.list_repositories import list_github_repositories_tool

        system_prompt = f"""You are an assistant designed to answer random user's questions.
        **Additional Guidelines**:
        - Today’s date for reference: {datetime.now().isoformat()}
        """

        agent = OpenAIAgent.from_tools(
            tools=[
                # a tool with Token Vault access
                list_github_repositories_tool
                # ... other tools
            ],
            model="gpt-4o",
            system_prompt=system_prompt
            verbose=True,
        )
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the LLamaIndex SDK.

        #### Server side

        On the server side of your Flask application you will need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the OpenAI API utilizing LlamaIndex's SDK, that has been initialized with Auth0 AI's protection enhancements for tools.

        When `TokenVaultInterrupt` error occurs, the server side will signal the front-end about the level access restrictions, and the front-end should prompt the user to trigger a new authorization (or login) request with the necessary permissions.

        ```python ./src/app.py wrap lines highlight={3-5,19-20} theme={null}
        from dotenv import load_dotenv
        from flask import Flask, request, jsonify, session
        from auth0_ai_llamaindex.auth0_ai import Auth0AI
        from auth0_ai_llamaindex.token_vault import TokenVaultInterrupt
        from src.lib.agent import agent

        load_dotenv()
        app = Flask(__name__)

        @app.route("/chat", methods=["POST"])
        async def chat():
            if "user" not in session:
                return jsonify({"error": "unauthorized"}), 401

            try:
                message = request.json.get("message")
                response = agent.achat(message)
                return jsonify({"response": str(response)})
            except TokenVaultInterrupt as e:
                return jsonify({"error": str(e.to_json())}), 403
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        ```
      </Tab>

      <Tab title="CrewAI" icon="https://mintlify-assets.b-cdn.net/auth0/crew_ai.svg">
        comming soon!
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Account Linking

If you're integrating with Google, but users in your app or agent can sign in using other methods (e.g., a username and password or another social provider), you'll need to link these identities into a single user account. Auth0 refers to this process as [Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).

**Account Linking** logic and handling will vary depending on your app or agent. You can find an example of how to implement it in a Next.js chatbot app [here](https://github.com/auth0-lab/market0/blob/main/app/api/auth/%5Bauth0%5D/route.ts#L43). If you have questions or are looking for best practices, [join our Discord](http://discord.gg/XbQpZSF2Ys) and ask in the `#auth0-for-gen-ai` channel.


# List Slack Channels
Source: https://auth0.com/ai/docs/how-tos/list-slack-channels

Use OpenAI, NextJS, and the Auth0-AI SDKs to list your Slack channels

<Tabs>
  <Tab title="Javascript" icon="js">
    <Tabs>
      <Tab title="AI SDK" icon="https://mintlify-assets.b-cdn.net/auth0/vercel.svg">
        <SlackPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-vercel
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Slack scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-vercel";
        import { auth0 } from "@/lib/auth0";

        const auth0AI = new Auth0AI();

        export const withSlack = auth0AI.withTokenVault({
          connection: "sign-in-with-slack",
          scopes: ["channels:read", "groups:read"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;

            return refreshToken;
          },
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with Slack

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Slack API.

        ```typescript ./src/lib/tools/listChannels.ts wrap lines highlight={2-4,8,14,18,30-32} theme={null}
        import { ErrorCode, WebClient } from "@slack/web-api";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withSlack } from "@/lib/auth0-ai";
        import { tool } from "ai";
        import { z } from "zod";

        export const listChannels = withSlack(
          tool({
            description: "List channels for the current user on Slack",
            parameters: z.object({}),
            execute: async () => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              // Slack SDK
              try {
                const web = new WebClient(accessToken);

                const result = await web.conversations.list({
                  exclude_archived: true,
                  types: "public_channel,private_channel",
                  limit: 10,
                });

                return result.channels?.map((channel) => channel.name);
              } catch (error) {
                if (error && typeof error === "object" && "code" in error) {
                  if (error.code === ErrorCode.HTTPError) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault connection`
                    );
                  }
                }

                throw error;
              }
            },
          })
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the Vercel AI SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={3-4,10,13,27,29} theme={null}
        import { createDataStreamResponse, Message, streamText } from "ai";
        import { listChannels } from "@/lib/tools/";
        import { setAIContext } from "@auth0/ai-vercel";
        import { errorSerializer, withInterruptions } from "@auth0/ai-vercel/interrupts";
        import { openai } from "@ai-sdk/openai";

        export async function POST(request: Request) {
          const { id, messages} = await request.json();
          const tools = { listChannels };
          setAIContext({ threadID: id });

          return createDataStreamResponse({
            execute: withInterruptions(
              async (dataStream) => {
                const result = streamText({
                  model: openai("gpt-4o-mini"),
                  system: "You are a friendly assistant! Keep your responses concise and helpful.",
                  messages,
                  maxSteps: 5,
                  tools,
                });

                result.mergeIntoDataStream(dataStream, {
                  sendReasoning: true,
                });
              },
              { messages, tools }
            ),
            onError: errorSerializer((err) => {
              console.log(err);
              return "Oops, an error occured!";
            }),
          });
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Slack and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,10-14,25-34} theme={null}
        "use client";

        import { useChat } from "@ai-sdk/react";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        export default function Chat() {
          const { messages, handleSubmit, input, setInput, toolInterrupt } =
            useInterruptions((handler) =>
              useChat({
                onError: handler((error) => console.error("Chat error:", error)),
              })
            );

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                </div>
              ))}

              {TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                <TokenVaultConsentPopup
                  interrupt={toolInterrupt}
                  connectWidget={{
                    title: "List Slack channels",
                    description:"description ...",
                    action: { label: "Check" },
                  }}
                />
              )}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="Cloudflare Agents" icon="https://mintlify-assets.b-cdn.net/auth0/cloudflare.svg">
        <SlackPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        <Note>If you started from the [Auth0 Cloudflare Agents starter kit](https://github.com/auth0-lab/cloudflare-agents-starter), you can skip this step as the Auth0 AI SDK is already configured.</Note>

        First, you must configure your Cloudflare Agent to use Auth0 and both in the Worker and in the Chat Agent itself. We recommend the following two sdks:

        * [Auth0 Hono Web SDK](https://github.com/auth0-lab/auth0-hono): for the Worker.
        * [Auth0 Cloudflare Agents API SDK](https://github.com/auth0-lab/auth0-cloudflare-agents-api) for the Chat Agent.

        You can also check our [Starter Kit](https://github.com/auth0-lab/cloudflare-agents-starter) to understand how to configure this.

        Then, you need to install the Auth0 AI SDK for Cloudflare Agents:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-vercel @auth0/ai-cloudflare @auth0/ai
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/agent/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI, setGlobalAIContext } from "@auth0/ai-vercel";
        import { getCurrentAgent } from "agents";
        import type { Chat } from "./chat";

        const getAgent = () => {
          const { agent } = getCurrentAgent<Chat>();
          if (!agent) {
            throw new Error("No agent found");
          }
          return agent;
        };

        setGlobalAIContext(() => ({ threadID: getAgent().name }));

        const auth0AI = new Auth0AI();

        const refreshToken = async () => {
          const credentials = getAgent().getCredentials();
          return credentials?.refresh_token;
        };

        export const withSlack = auth0AI.withTokenVault({
          refreshToken,
          connection: "sign-in-with-slack",
          scopes: ["channels:read", "groups:read"],
        });
        ```

        ### 2. Integrate your tool with the Slack API

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Slack API.

        ```typescript ./src/agent/tools/listRepositories.ts wrap lines highlight={4-5,9,15,19,31-33} theme={null}
        import { tool } from "ai";
        import { z } from "zod/v3";

        import { getAccessTokenFromTokenVault } from "@auth0/ai-vercel";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withSlack } from "@/agent/auth0-ai";
        import { ErrorCode, WebClient } from "@slack/web-api";

        export const listChannels = withSlack(
          tool({
            description: "List channels for the current user on Slack",
            inputSchema: z.object({}),
            execute: async () => {
              // Get the access token from Auth0 AI
              const accessToken = getAccessTokenFromTokenVault();

              // Slack SDK
              try {
                const web = new WebClient(accessToken);

                const result = await web.conversations.list({
                  exclude_archived: true,
                  types: "public_channel,private_channel",
                  limit: 10,
                });

                return result.channels?.map((channel) => channel.name);
              } catch (error) {
                if (error && typeof error === "object" && "code" in error) {
                  if (error.code === ErrorCode.HTTPError) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault`
                    );
                  }
                }

                throw error;
              }
            },
          })
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the Vercel AI SDK via these interrupts.

        <Note>If you started from the [Auth0 Cloudflare Agents starter kit](https://github.com/auth0-lab/cloudflare-agents-starter), you can skip this section as the Auth0 AI SDK is already configured to handle interrupts.</Note>

        #### Server Side

        On the Chat agent class, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`.

        ```typescript ./src/agent/chat.ts wrap lines highlight={1-10,52,54-57,101} theme={null}
        import { openai } from "@ai-sdk/openai";
        import {
          AsyncUserConfirmationResumer,
          CloudflareKVStore,
        } from "@auth0/ai-cloudflare";
        import {
          errorSerializer,
          invokeTools,
          withInterruptions,
        } from "@auth0/ai-vercel/interrupts";
        import { AuthAgent, OwnedAgent } from "@auth0/auth0-cloudflare-agents-api";
        import { AIChatAgent } from "agents/ai-chat-agent";
        import {
          convertToModelMessages,
          createUIMessageStream,
          createUIMessageStreamResponse,
          generateId,
          stepCountIs,
          streamText,
          type UIMessage,
        } from "ai";
        import { executions, tools } from "./tools";
        import { processToolCalls } from "./utils";

        const model = openai("gpt-4o-2024-11-20");

        class BaseChat extends AIChatAgent<Env> {}

        const AuthedChat = AuthAgent(BaseChat);
        const OwnedAuthedChat = OwnedAgent(AuthedChat);
        const ResumableOwnedAuthedChat = AsyncUserConfirmationResumer(OwnedAuthedChat);

        export class Chat extends ResumableOwnedAuthedChat {
          messages: UIMessage[] = [];

          declare mcp?:
            | {
            unstable_getAITools?: () => Record<string, unknown>;
          }
            | undefined;

          async onChatMessage() {
            const allTools = {
              ...tools,
              ...(this.mcp?.unstable_getAITools?.() ?? {}),
            };

            const claims = this.getClaims?.();

            const stream = createUIMessageStream({
              originalMessages: this.messages,
              execute: withInterruptions(
                async ({ writer }) => {
                  await invokeTools({
                    messages: convertToModelMessages(this.messages),
                    tools: allTools,
                  });

                  const processed = await processToolCalls({
                    messages: this.messages,
                    dataStream: writer,
                    tools: allTools,
                    executions,
                  });

                  const result = streamText({
                    model,
                    stopWhen: stepCountIs(10),
                    messages: convertToModelMessages(processed),
                    system: `You are a helpful assistant that can do various tasks...

        If the user asks to schedule a task, use the schedule tool to schedule the task.

        The name of the user is ${claims?.name ?? "unknown"}.`,
                    tools: allTools,
                    onStepFinish: (output) => {
                      if (output.finishReason === "tool-calls") {
                        const last = output.content[output.content.length - 1];
                        if (last?.type === "tool-error") {
                          const { toolName, toolCallId, error, input } = last;
                          const serializableError = {
                            cause: error,
                            toolCallId,
                            toolName,
                            toolArgs: input,
                          };
                          throw serializableError;
                        }
                      }
                    },
                  });

                  writer.merge(
                    result.toUIMessageStream({
                      sendReasoning: true,
                    })
                  );
                },
                { messages: this.messages, tools: allTools }
              ),
              onError: errorSerializer(),
            });

            return createUIMessageStreamResponse({ stream });
          }

          async executeTask(description: string) {
            await this.saveMessages([
              ...this.messages,
              {
                id: generateId(),
                role: "user",
                parts: [{ type: "text", text: `Running scheduled task: ${description}` }],
              },
            ]);
          }

          get auth0AIStore() {
            return new CloudflareKVStore({ kv: this.env.Session });
          }
        }
        ```

        **Note about CloudflareKVStore:**

        For persisting Auth0 session data and other key-value pairs, you need to configure a persistent store with your Cloudflare agent worker. When constructing the `CloudflareKVStore` instance with your Cloudflare agent worker, you can use Workers KV and a [KV namespace](https://developers.cloudflare.com/kv/get-started/) as the persistent store. This enables you to store Auth0 session data and other key-value pairs with easy access from your Cloudflare agent workers.

        ```ts theme={null}
        import { CloudflareKVStore } from '@auth0/ai-cloudflare';
        ...

        return new CloudflareKVStore({ kv: this.env.YOUR_KV_NAMESPACE });
        ```

        **Note:** the `kv` prop accepts any store which implements the [`KVNamespace` interface](https://github.com/auth0/auth0-ai-js/blob/%40auth0/ai-cloudflare-v2.0.0/packages/ai-cloudflare/src/CloudflareKVStore.ts#L3-L14), so any persistent store which implements this interface will work.

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,17-18,33-42} theme={null}
        "use client";

        import { useChat } from "@ai-sdk/react";
        import { useAgentChatInterruptions } from "@auth0/ai-cloudflare/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        export default function Chat() {

          const {
            messages: agentMessages,
            input: agentInput,
            handleInputChange: handleAgentInputChange,
            handleSubmit: handleAgentSubmit,
            addToolResult,
            clearHistory,
            toolInterrupt,
          } = useAgentChatInterruptions({
            agent,
            maxSteps: 5,
            id: threadID,
          });

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                </div>
              ))}

              {TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                <TokenVaultConsentPopup
                  interrupt={toolInterrupt}
                  connectWidget={{
                    title: "Access to your Slack channels",
                    description:"description ...",
                    action: { label: "Check" },
                  }}
                />
              )}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LangGraph" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
        <SlackPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-langchain
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Slack scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { SUBJECT_TOKEN_TYPES } from "@auth0/ai";
        import { Auth0AI } from "@auth0/ai-langchain";

        const auth0AI = new Auth0AI({
          auth0: {
            domain: process.env.AUTH0_DOMAIN!,
            clientId: process.env.AUTH0_CUSTOM_API_CLIENT_ID!,
            clientSecret: process.env.AUTH0_CUSTOM_API_CLIENT_SECRET!,
          },
        });

        const withAccessTokenForConnection = (connection: string, scopes: string[]) =>
          auth0AI.withTokenVault({
            connection,
            scopes,
            accessToken: async (_, config) => {
              return config.configurable?.langgraph_auth_user?.getRawAccessToken();
            },
            subjectTokenType: SUBJECT_TOKEN_TYPES.SUBJECT_TYPE_ACCESS_TOKEN,
          });

        export const withSlack = withAccessTokenForConnection("sign-in-with-slack", ["channels:read", "groups:read"]);

        ```

        ### 2. Integrate your tool with Slack

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Slack API.

        ```typescript ./src/lib/tools/listChannels.ts wrap lines highlight={2-4,8,11,15,27-29} theme={null}
        import { ErrorCode, WebClient } from "@slack/web-api";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-langchain";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withSlack } from "@/lib/auth0-ai";
        import { tool } from "@langchain/core/tools";
        import { z } from "zod";

        export const listChannels = withSlack(
          tool(async ({ date }) => {
            // Get the access token from Auth0 AI
            const accessToken = getAccessTokenFromTokenVault();

            // Slack SDK
            try {
              const web = new WebClient(accessToken);

              const result = await web.conversations.list({
                exclude_archived: true,
                types: "public_channel,private_channel",
                limit: 10,
              });

              return result.channels?.map((channel) => channel.name);
            } catch (error) {
              if (error && typeof error === "object" && "code" in error) {
                if (error.code === ErrorCode.HTTPError) {
                  throw new TokenVaultError(
                    `Authorization required to access the Token Vault connection`
                  );
                }
              }

              throw error;
            }
          },
          {
            name: "list_slack_channels",
            description: "List channels for the current user on Slack",
            schema: z.object({
              date: z.coerce.date(),
            }),
          })
        );
        ```

        Now that the tool is protected, you can pass it your LangGraph agent as part of a `ToolNode`. The agent will automatically request the access token when the tool is called.

        ```typescript src/lib/agent.ts wrap lines highlight={7,10,33,39} theme={null}
        import { AIMessage } from "@langchain/core/messages";
        import { RunnableLike } from "@langchain/core/runnables";
        import { END, InMemoryStore, MemorySaver, MessagesAnnotation, START, StateGraph } from "@langchain/langgraph";
        import { ToolNode } from "@langchain/langgraph/prebuilt";
        import { ChatOpenAI } from "@langchain/openai";

        import { listChannels } from "@/lib/tools/listChannels";

        const model = new ChatOpenAI({ model: "gpt-4o", }).bindTools([
          listChannels,
        ]);

        const callLLM = async (state: typeof MessagesAnnotation.State) => {
          const response = await model.invoke(state.messages);
          return { messages: [response] };
        };

        const routeAfterLLM: RunnableLike = function (state) {
          const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
          if (!lastMessage.tool_calls?.length) {
            return END;
          }
          return "tools";
        };

        const stateGraph = new StateGraph(MessagesAnnotation)
          .addNode("callLLM", callLLM)
          .addNode(
            "tools",
            new ToolNode(
              [
                // A tool with Token Vault access
                listChannels,
                // ... other tools
              ],
              {
                // Error handler should be disabled in order to
                // trigger interruptions from within tools.
                handleToolErrors: false,
              }
            )
          )
          .addEdge(START, "callLLM")
          .addConditionalEdges("callLLM", routeAfterLLM, [END, "tools"])
          .addEdge("tools", "callLLM");

        const checkpointer = new MemorySaver();
        const store = new InMemoryStore();

        export const graph = stateGraph.compile({
          checkpointer,
          store,
          interruptBefore: [],
          interruptAfter: [],
        });
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the Langchain SDK.

        #### Server Side

        On the server side of your Next.js application you need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the LangGraph API. Additionally, you must provide the `accessToken` in the headers.

        ```typescript ./src/app/api/langgraph/[..._path]/route.ts wrap lines highlight={26} theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";
        import { NextRequest } from "next/server";

        import { auth0 } from "@/lib/auth0";

        async function getAccessToken() {
          const tokenResult = await auth0.getAccessToken();
          if (!tokenResult?.token) {
            throw new Error("Error retrieving access token for langgraph api.");
          }
          return tokenResult.token;
        }

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            apiKey: process.env.LANGSMITH_API_KEY,
            runtime: "edge",
            baseRoute: "langgraph/",
            headers: async (req: NextRequest) => {
              const headers: Record<string, string> = {};
              req.headers.forEach((value, key) => {
                headers[key] = value;
              });

              const accessToken = await getAccessToken();
              headers["Authorization"] = `Bearer ${accessToken}`;
              return headers;
            },
          });


        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### Add Custom Authentication

        <Info>
          For more information on how to add custom authentication for your LangGraph Platform application, see the [Custom Auth](https://langchain-ai.github.io/langgraphjs/how-tos/auth/custom_auth/) guide.
        </Info>

        In your langgraph.json, add the path to your auth file:

        ```typescript langgraph.json wrap lines highlight={8} theme={null}
        {
          "node_version": "20",
          "graphs": {
            "agent": "./src/lib/agent.ts:agent"
          },
          "env": ".env",
          "auth": {
            "path": "./src/lib/auth.ts:authHandler"
          }
        }
        ```

        Then, in your auth.ts file, add your auth logic:

        ```typescript src/lib/auth.ts wrap lines theme={null}
        import { createRemoteJWKSet, jwtVerify } from "jose";

        const { Auth, HTTPException } = require("@langchain/langgraph-sdk/auth");

        const AUTH0_DOMAIN = process.env.AUTH0_DOMAIN;
        const AUTH0_AUDIENCE = process.env.AUTH0_AUDIENCE;

        // JWKS endpoint for Auth0
        const JWKS = createRemoteJWKSet(
          new URL(`https://${AUTH0_DOMAIN}/.well-known/jwks.json`)
        );

        // Create the Auth instance
        const auth = new Auth();
        // Register the authentication handler
        auth.authenticate(async (request: Request) => {
          const authHeader = request.headers.get("Authorization");
          const xApiKeyHeader = request.headers.get("x-api-key");
            /**
             * LangGraph Platform will convert the `Authorization` header from the client to an `x-api-key` header automatically
             * as of now: https://docs.langchain.com/langgraph-platform/custom-auth
             *
             * We can still leverage the `Authorization` header when served in other infrastructure w/ langgraph-cli
             * or when running locally.
             */
            // This header is required in Langgraph Cloud.
            if (!authHeader && !xApiKeyHeader) {
              throw new HTTPException(401, {
                message: "Invalid auth header provided.",
              });
            }

            // prefer the xApiKeyHeader first
            let token = xApiKeyHeader || authHeader;

            // Remove "Bearer " prefix if present
            if (token && token.startsWith("Bearer ")) {
              token = token.substring(7);
            }

            // Validate Auth0 Access Token using common JWKS endpoint
            if (!token) {
              throw new HTTPException(401, {
                message:
                  "Authorization header format must be of the form: Bearer <token>",
              });
            }

            if (token) {
              try {
                // Verify the JWT using Auth0 JWKS
                const { payload } = await jwtVerify(token, JWKS, {
                  issuer: `https://${AUTH0_DOMAIN}/`,
                  audience: AUTH0_AUDIENCE,
                });

                console.log("✅ Auth0 JWT payload resolved!", payload);

                // Return the verified payload - this becomes available in graph nodes
                return {
                  identity: payload.sub!,
                  email: payload.email as string,
                  permissions:
                    typeof payload.scope === "string" ? payload.scope.split(" ") : [],
                  auth_type: "auth0",
                  // include the access token for use with Auth0 Token Vault exchanges by tools
                  getRawAccessToken: () => token,
                  // Add any other claims you need
                  ...payload,
                };
              } catch (jwtError) {
                console.log(
                  "Auth0 JWT validation failed:",
                  jwtError instanceof Error ? jwtError.message : "Unknown error"
                );
                throw new HTTPException(401, {
                  message: "Invalid Authorization token provided.",
                });
              }
            }
        });

        export { auth as authHandler };
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Slack and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={2-3,62-74} theme={null}
        import { useStream } from "@langchain/langgraph-sdk/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const thread = useStream({
            apiUrl: `${process.env.NEXT_PUBLIC_URL}/api/langgraph`,
            assistantId: "agent",
            threadId,
            onThreadId: setThreadId,
            onError: (err) => {
              console.dir(err);
            },
          });

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (thread.isLoading) {
              return;
            }
            setInputFocus();
          }, [thread.isLoading, setInputFocus]);

          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            thread.submit(
              { messages: [{ type: "human", content: input }] },
              {
                optimisticValues: (prev) => ({
                  messages: [
                    ...((prev?.messages as []) ?? []),
                    { type: "human", content: input, id: "temp" },
                  ],
                }),
              }
            );
            setInput("");
          };

          return (
            <div>
              {thread.messages.filter((m) => m.content && ["human", "ai"].includes(m.type)).map((message) => (
                <div key={message.id}>
                  {message.type === "human" ? "User: " : "AI: "}
                  {message.content as string}
                </div>
              ))}

              {thread.interrupt && TokenVaultInterrupt.isInterrupt(thread.interrupt.value) ? (
                <div key={thread.interrupt.ns?.join("")}>
                  <TokenVaultConsentPopup
                    interrupt={thread.interrupt.value}
                    onFinish={() => thread.submit(null)}
                    connectWidget={{
                        title: "List Slack channels",
                        description:"description ...",
                        action: { label: "Check" },
                      }}
                  />
                </div>
              ) : null}

              <form onSubmit={handleSubmit}>
                <input ref={inputRef} value={input} placeholder="Say something..." readOnly={thread.isLoading} disabled={thread.isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="GenKit" icon="https://mintlify-assets.b-cdn.net/auth0/genkit.svg">
        <SlackPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-genkit
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Slack scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-genkit";
        import { auth0 } from "@/lib/auth0";

        // importing GenKit instance
        import { ai } from "./genkit";

        const auth0AI = new Auth0AI({
          genkit: ai,
        });

        export const withSlack = auth0AI.withTokenVault({
          connection: "sign-in-with-slack",
          scopes: ["channels:read", "groups:read"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;
            return refreshToken;
          },
        });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with Slack

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Slack API.

        ```typescript ./src/lib/tools/listChannels.ts wrap lines highlight={2-4,11,18,22,34-36} theme={null}
        import { z } from "zod";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-genkit";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { withSlack } from "@/lib/auth0-ai";
        import { ErrorCode, WebClient } from "@slack/web-api";

        // importing GenKit instance
        import { ai } from "../genkit";

        export const listChannels = ai.defineTool(
          ...withSlack(
            {
              description: "List channels for the current user on Slack",
              inputSchema: z.object({}),
              name: "listChannels",
            },
            async () => {
              const accessToken = getAccessTokenFromTokenVault();

              try {
                // Slack SDK
                const web = new WebClient(accessToken);

                const result = await web.conversations.list({
                  exclude_archived: true,
                  types: "public_channel,private_channel",
                  limit: 10,
                });

                return result.channels?.map((channel) => channel.name);
              } catch (error) {
                if (error && typeof error === "object" && "code" in error) {
                  if (error.code === ErrorCode.HTTPError) {
                    throw new TokenVaultError(
                      `Authorization required to access the Token Vault connection`
                    );
                  }
                }

                throw error;
              }
            }
          )
        );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action—such as authenticating or granting API access—before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the GenKit SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={4-5,47} theme={null}
        import { ToolRequestPart } from "genkit";
        import path from "path";
        import { ai } from "@/lib/genkit";
        import { listChannels } from "@/lib/tools/list-channels";
        import { resumeAuth0Interrupts } from "@auth0/ai-genkit";
        import { auth0 } from "@/lib/auth0";

        export async function POST(
          request: Request,
          { params }: { params: Promise<{ id: string }> }
        ) {
          const auth0Session = await auth0.getSession();
          const { id } = await params;
          const {
            message,
            interruptedToolRequest,
            timezone,
          }: {
            message?: string;
            interruptedToolRequest?: ToolRequestPart;
            timezone: { region: string; offset: number };
          } = await request.json();

          let session = await ai.loadSession(id);

          if (!session) {
            session = ai.createSession({
              sessionId: id,
            });
          }

          const tools = [listChannels];

          const chat = session.chat({
            tools: tools,
            system: `You are a helpful assistant.
            The user's timezone is ${timezone.region} with an offset of ${timezone.offset} minutes.
            User's details: ${JSON.stringify(auth0Session?.user, null, 2)}.
            You can use the tools provided to help the user.
            You can also ask the user for more information if needed.
            Chat started at ${new Date().toISOString()}
            `,
          });

          const r = await chat.send({
            prompt: message,
            resume: resumeAuth0Interrupts(tools, interruptedToolRequest),
          });

          return Response.json({ messages: r.messages, interrupts: r.interrupts });
        }

        export async function GET(
          request: Request,
          { params }: { params: Promise<{ id: string }> }
        ) {
          const { id } = await params;

          const session = await ai.loadSession(id);

          if (!session) {
            return new Response("Session not found", {
              status: 404,
            });
          }

          const json = session.toJSON();

          if (!json?.threads?.main) {
            return new Response("Session not found", {
              status: 404,
            });
          }

          return Response.json(json.threads.main);
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Google Calendar and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-5,120-141} theme={null}
        "use client";
        import { useQueryState } from "nuqs";
        import { FormEventHandler, useEffect, useRef, useState } from "react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";
        import Markdown from "react-markdown";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const [isLoading, setIsLoading] = useState(false);
          const [messages, setMessages] = useState<
            {
              role: "user" | "model";
              content: [{ text?: string; metadata?: { interrupt?: any } }];
            }[]
          >([]);

          useEffect(() => {
            if (!threadId) {
              setThreadId(self.crypto.randomUUID());
            }
          }, [threadId, setThreadId]);

          useEffect(() => {
            if (!threadId) {
              return;
            }

            setIsLoading(true);

            (async () => {
              const messagesResponse = await fetch(`/api/chat/${threadId}`, {
                method: "GET",
                credentials: "include",
              });
              if (!messagesResponse.ok) {
                setMessages([]);
              } else {
                setMessages(await messagesResponse.json());
              }
              setIsLoading(false);
            })();
          }, [threadId]);

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (isLoading) {
              return;
            }
            setInputFocus();
          }, [isLoading, setInputFocus]);

          const submit = async ({
            message,
            interruptedToolRequest,
          }: {
            message?: string;
            interruptedToolRequest?: any;
          }) => {
            setIsLoading(true);
            const timezone = {
              region: Intl.DateTimeFormat().resolvedOptions().timeZone,
              offset: new Date().getTimezoneOffset(),
            };
            const response = await fetch(`/api/chat/${threadId}`, {
              method: "POST",
              credentials: "include",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ message, interruptedToolRequest, timezone }),
            });
            if (!response.ok) {
              console.error("Error sending message");
            } else {
              const { messages: messagesResponse } = await response.json();
              setMessages(messagesResponse);
            }
            setIsLoading(false);
          };

          // When the user submits a message, add it to the list of messages and resume the conversation.
          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            setMessages((messages) => [
              ...messages,
              { role: "user", content: [{ text: input }] },
            ]);
            submit({ message: input });
            setInput("");
          };

          return (
            <div>
              {messages
                .filter(
                  (m) =>
                    ["model", "user", "tool"].includes(m.role) &&
                    m.content?.length > 0 &&
                    (m.content[0].text || m.content[0].metadata?.interrupt)
                )
                .map((message, index) => (
                  <div key={index}>
                    <Markdown>
                      {(message.role === "user" ? "User: " : "AI: ") +
                        (message.content[0].text || "")}
                    </Markdown>
                    {!isLoading &&
                    message.content[0].metadata?.interrupt &&
                    TokenVaultInterrupt.isInterrupt(
                      message.content[0].metadata?.interrupt
                    )
                      ? (() => {
                          const interrupt: any = message.content[0].metadata?.interrupt;
                          return (
                            <div>
                              <TokenVaultConsentPopup
                                onFinish={() => submit({ interruptedToolRequest: message.content[0] })}
                                interrupt={interrupt}
                                connectWidget={{
                                  title: `Requested by: "${interrupt.toolCall.toolName}"`,
                                  description: "Description...",
                                  action: { label: "Check" },
                                }}
                              />
                            </div>
                          );
                        })()
                      : null}
                  </div>
                ))}

              <form onSubmit={handleSubmit}>
                <input value={input} ref={inputRef} placeholder="Say something..." readOnly={isLoading} disabled={isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
        <SlackPrereqs lang="js" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        npm install @auth0/ai-llamaindex
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required GitHub scopes.

        ```typescript ./src/lib/auth0-ai.ts wrap lines theme={null}
        import { Auth0AI } from "@auth0/ai-llamaindex";
        import { auth0 } from "@/lib/auth0";

        const auth0AI = new Auth0AI();

        export const withSlack = auth0AI.withTokenVault({
          connection: "sign-in-with-slack",
          scopes: ["channels:read", "groups:read"],
          refreshToken: async () => {
            const session = await auth0.getSession();
            const refreshToken = session?.tokenSet.refreshToken as string;
            return refreshToken;
          },
        });

        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        ### 2. Integrate your tool with GitHub

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the GitHub API.

        ```typescript ./src/lib/tools/listRepositories.ts wrap lines highlight={3-5,13,17,33-35} theme={null}
        import { tool } from "llamaindex";
        import { z } from "zod";
        import { withSlack } from "@/lib/auth0-ai";
        import { getAccessTokenFromTokenVault } from "@auth0/ai-llamaindex";
        import { TokenVaultError } from "@auth0/ai/interrupts";
        import { ErrorCode, WebClient } from "@slack/web-api";

        export const listChannels = () =>
          withSlack(
            tool(
              async () => {
                // Get the access token from Auth0 AI
                const accessToken = getAccessTokenFromTokenVault();

                // Slack SDK
                try {
                  const web = new WebClient(accessToken);

                  const result = await web.conversations.list({
                    exclude_archived: true,
                    types: "public_channel,private_channel",
                    limit: 10,
                  });

                  return (
                    result.channels
                      ?.map((channel) => channel.name)
                      .filter((name): name is string => name !== undefined) || []
                  );
                } catch (error) {
                  if (error && typeof error === "object" && "code" in error) {
                    if (error.code === ErrorCode.HTTPError) {
                      throw new TokenVaultError(
                        `Authorization required to access the Token Vault connection`
                      );
                    }
                  }

                  throw error;
                }
              },
              {
                name: "listChannels",
                description: "List channels for the current user on Slack",
                parameters: z.object({}),
              }
            )
          );
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages authentication redirects in the LlamaIndex SDK via these interrupts.

        #### Server Side

        On the server-side code of your Next.js App, you need to set up the tool invocation and handle the interruption messaging via the `errorSerializer`. The `setAIContext` function is used to set the async-context for the Auth0 AI SDK.

        ```typescript ./src/app/api/chat/route.ts wrap lines highlight={2-5,15,35} theme={null}
        import { createDataStreamResponse, LlamaIndexAdapter, Message, ToolExecutionError } from "ai";
        import { listRepositories } from "@/lib/tools/";
        import { setAIContext } from "@auth0/ai-llamaindex";
        import { withInterruptions } from "@auth0/ai-llamaindex/interrupts";
        import { errorSerializer } from "@auth0/ai-vercel/interrupts";
        import { OpenAIAgent } from "llamaindex";

        export async function POST(request: Request) {
          const { id, messages }: { id: string; messages: Message[] } =
            await request.json();

          setAIContext({ threadID: id });

          return createDataStreamResponse({
            execute: withInterruptions(
              async (dataStream) => {
                const agent = new OpenAIAgent({
                  systemPrompt: "You are an AI assistant",
                  tools: [listRepositories()],
                  verbose: true,
                });

                const stream = await agent.chat({
                  message: messages[messages.length - 1].content,
                  stream: true,
                });

                LlamaIndexAdapter.mergeIntoDataStream(stream as any, { dataStream });
              },
              {
                messages,
                errorType: ToolExecutionError,
              }
            ),
            onError: errorSerializer((err) => {
              console.log(err);
              return "Oops, an error occured!";
            }),
          });
        }
        ```

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with GitHub and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={4-6,28-38} theme={null}
        "use client";

        import { generateId } from "ai";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";
        import { useInterruptions } from "@auth0/ai-vercel/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { useChat } from "@ai-sdk/react";

        export default function Chat() {
          const { messages, handleSubmit, input, setInput, toolInterrupt } =
            useInterruptions((handler) =>
              useChat({
                experimental_throttle: 100,
                sendExtraMessageFields: true,
                generateId,
                onError: handler((error) => console.error("Chat error:", error)),
              })
            );

          return (
            <div>
              {messages.map((message) => (
                <div key={message.id}>
                  {message.role === "user" ? "User: " : "AI: "}
                  {message.content}
                  {message.parts && message.parts.length > 0 && (
                    <div>
                      {toolInterrupt?.toolCall.id.includes(message.id) &&
                        TokenVaultInterrupt.isInterrupt(toolInterrupt) && (
                          <TokenVaultConsentPopup
                            interrupt={toolInterrupt}
                            connectWidget={{
                              title: `Requested by: "${toolInterrupt.toolCall.name}"`,
                              description: "Description...",
                              action: { label: "Check" },
                            }}
                          />
                        )}
                    </div>
                  )}
                </div>
              ))}

              <form onSubmit={handleSubmit}>
                <input value={input} placeholder="Say something..." onChange={(e) => setInput(e.target.value)} autoFocus />
              </form>
            </div>
          );
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab title="Python" icon="python">
    <Tabs>
      <Tab title="LangGraph" icon="https://mintlify-assets.b-cdn.net/auth0/langchain.svg">
        <SlackPrereqs lang="python" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        pip install auth0-ai-langchain
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Slack scopes.

        ```python ./src/lib/auth0-ai.py wrap lines theme={null}
        from auth0_ai_langchain.auth0_ai import Auth0AI

        auth0_ai = Auth0AI()

        with_slack = auth0_ai.with_token_vault(
            connection="sign-in-with-slack",
            scopes=["channels:read groups:read"],
            # Optional: By default, the SDK will expect the refresh token from
            # the LangChain RunnableConfig (`config.configurable._credentials.refresh_token`)
            # If you want to use a different store for refresh token you can set up a getter here
            # refresh_token=lambda *_args, **_kwargs:session["user"]["refresh_token"],
        )
        ```

        ### 2. Integrate your tool with Slack

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Slack API.

        ```python ./src/lib/tools/list_channels.py wrap lines highlight={5-6,13,17,28,32} theme={null}
        from slack_sdk import WebClient
        from slack_sdk.errors import SlackApiError
        from pydantic import BaseModel
        from langchain_core.tools import StructuredTool
        from auth0_ai_langchain.token_vault import get_access_token_from_token_vault, TokenVaultError
        from lib.auth0_ai import with_slack

        class EmptySchema(BaseModel):
            pass

        def list_channels_tool_function(date: datetime):
            # Get the access token from Auth0 AI
            access_token = get_access_token_from_token_vault()

            # Slack SDK
            try:
                client = WebClient(token=access_token)
                response = client.conversations_list(
                    exclude_archived=True,
                    types="public_channel,private_channel",
                    limit=10
                )
                channels = response['channels']
                channel_names = [channel['name'] for channel in channels]
                return channel_names
            except SlackApiError as e:
                if e.response['error'] == 'not_authed':
                    raise TokenVaultError("Authorization required to access the Token Vault API")

                raise ValueError(f"An error occurred: {e.response['error']}")

        list_slack_channels_tool = with_slack(StructuredTool(
            name="list_slack_channels",
            description="List channels for the current user on Slack",
            args_schema=EmptySchema,
            func=list_channels_tool_function,
        ))
        ```

        Now that the tool is protected, you can pass it your LangGraph agent as part of a `ToolNode`. The agent will automatically request the access token when the tool is called.

        ```python ./src/lib/agent.py wrap lines highlight={8,15,37,42} theme={null}
        from typing import Annotated, Sequence, TypedDict
        from langchain.storage import InMemoryStore
        from langchain_core.messages import AIMessage, BaseMessage
        from langchain_openai import ChatOpenAI
        from langgraph.checkpoint.memory import MemorySaver
        from langgraph.graph import END, START, StateGraph, add_messages
        from langgraph.prebuilt import ToolNode
        from tools.list_channels import list_slack_channels_tool


        class State(TypedDict):
            messages: Annotated[Sequence[BaseMessage], add_messages]

        llm = ChatOpenAI(model="gpt-4o")
        llm.bind_tools([list_slack_channels_tool])

        async def call_llm(state: State):
            response = await llm.ainvoke(state["messages"])
            return {"messages": [response]}

        def route_after_llm(state: State):
            messages = state["messages"]
            last_message = messages[-1] if messages else None

            if isinstance(last_message, AIMessage) and last_message.tool_calls:
                return "tools"
            return END

        workflow = (
            StateGraph(State)
            .add_node("call_llm", call_llm)
            .add_node(
                "tools",
                ToolNode(
                    [
                        # a tool with Token Vault access
                        list_slack_channels_tool,
                        # ... other tools
                    ],
                    # The error handler should be disabled to
                    # allow interruptions to be triggered from within tools.
                    handle_tool_errors=False
                )
            )
            .add_edge(START, "call_llm")
            .add_edge("tools", "call_llm")
            .add_conditional_edges("call_llm", route_after_llm, [END, "tools"])
        )

        graph = workflow.compile(checkpointer=MemorySaver(), store=InMemoryStore())
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the Langchain SDK.

        #### Server Side

        On the server side of your Next.js application you need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the LangGraph API. Additionally, you must provide the `refreshToken` to the Langchain's RunnableConfig from the authenticated user's session.

        ```typescript ./src/app/api/langgraph/[..._path]/route.ts wrap lines highlight={2,23-29} theme={null}
        import { initApiPassthrough } from "langgraph-nextjs-api-passthrough";
        import { auth0 } from "@/lib/auth0";

        const getRefreshToken = async () => {
          const session = await auth0.getSession();
          const refreshToken = session?.tokenSet.refreshToken as string;
          return refreshToken;
        };

        export const { GET, POST, PUT, PATCH, DELETE, OPTIONS, runtime } =
          initApiPassthrough({
            apiUrl: process.env.LANGGRAPH_API_URL,
            apiKey: process.env.LANGSMITH_API_KEY,
            runtime: "edge",
            baseRoute: "langgraph/",
            bodyParameters: async (req, body) => {
              if (
                req.nextUrl.pathname.endsWith("/runs/stream") &&
                req.method === "POST"
              ) {
                return {
                  ...body,
                  config: {
                    configurable: {
                      _credentials: {
                        refreshToken: await getRefreshToken(),
                      },
                    },
                  },
                };
              }

              return body;
            },
          });
        ```

        <Info>
          Here, the property `auth0` is an instance of `@auth0/nextjs-auth0` to handle the application auth flows. <br />
          You can check different authentication options for Next.js with Auth0 at the [official documentation.](https://github.com/auth0/nextjs-auth0?tab=readme-ov-file#3-create-the-auth0-sdk-client)
        </Info>

        #### Client Side

        In this example, we utilize the `TokenVaultConsentPopup` component to show a pop-up that allows the user to authenticate with Slack and grant access with the requested scopes. You'll first need to install the `@auth0/ai-components` package:

        ```bash wrap lines theme={null}
        npx @auth0/ai-components add TokenVault
        ```

        Then, you can integrate the authentication popup in your chat component, using the interruptions helper from the SDK:

        ```tsx ./src/components/chat.tsx wrap lines highlight={2-3,62-74} theme={null}
        import { useStream } from "@langchain/langgraph-sdk/react";
        import { TokenVaultInterrupt } from "@auth0/ai/interrupts";
        import { TokenVaultConsentPopup } from "@/components/auth0-ai/TokenVault/popup";

        const useFocus = () => {
          const htmlElRef = useRef<HTMLInputElement>(null);
          const setFocus = () => {
            if (!htmlElRef.current) {
              return;
            }
            htmlElRef.current.focus();
          };
          return [htmlElRef, setFocus] as const;
        };

        export default function Chat() {
          const [threadId, setThreadId] = useQueryState("threadId");
          const [input, setInput] = useState("");
          const thread = useStream({
            apiUrl: `${process.env.NEXT_PUBLIC_URL}/api/langgraph`,
            assistantId: "agent",
            threadId,
            onThreadId: setThreadId,
            onError: (err) => {
              console.dir(err);
            },
          });

          const [inputRef, setInputFocus] = useFocus();
          useEffect(() => {
            if (thread.isLoading) {
              return;
            }
            setInputFocus();
          }, [thread.isLoading, setInputFocus]);

          const handleSubmit: FormEventHandler<HTMLFormElement> = async (e) => {
            e.preventDefault();
            thread.submit(
              { messages: [{ type: "human", content: input }] },
              {
                optimisticValues: (prev) => ({
                  messages: [
                    ...((prev?.messages as []) ?? []),
                    { type: "human", content: input, id: "temp" },
                  ],
                }),
              }
            );
            setInput("");
          };

          return (
            <div>
              {thread.messages.filter((m) => m.content && ["human", "ai"].includes(m.type)).map((message) => (
                <div key={message.id}>
                  {message.type === "human" ? "User: " : "AI: "}
                  {message.content as string}
                </div>
              ))}

              {thread.interrupt && TokenVaultInterrupt.isInterrupt(thread.interrupt.value) ? (
                <div key={thread.interrupt.ns?.join("")}>
                  <TokenVaultConsentPopup
                    interrupt={thread.interrupt.value}
                    onFinish={() => thread.submit(null)}
                    connectWidget={{
                        title: "List GitHub respositories",
                        description:"description ...",
                        action: { label: "Check" },
                      }}
                  />
                </div>
              ) : null}

              <form onSubmit={handleSubmit}>
                <input ref={inputRef} value={input} placeholder="Say something..." readOnly={thread.isLoading} disabled={thread.isLoading} onChange={(e) => setInput(e.target.value)} />
              </form>
            </div>
          );
        }
        ```
      </Tab>

      <Tab title="LlamaIndex" icon="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg">
        <SlackPrereqs lang="python" />

        ### 1. Configure Auth0 AI

        First, you must install the SDK:

        ```bash wrap lines theme={null}
        pip install auth0-ai-llamaindex
        ```

        Then, you need to initialize Auth0 AI and set up the connection to request access tokens with the required Slack scopes.

        ```python ./src/lib/auth0-ai.py wrap lines theme={null}
        from auth0_ai_llamaindex.auth0_ai import Auth0AI
        from flask import session

        auth0_ai = Auth0AI()

        with_slack = auth0_ai.with_token_vault(
            connection="sign-in-with-slack",
            scopes=["channels:read groups:read"],
            refresh_token=lambda *_args, **_kwargs:session["user"]["refresh_token"],
        )
        ```

        <Info>
          Here, the session is controlled by a Flask application instance. You may utilize any other framework or session store of your preference.
        </Info>

        ### 2. Integrate your tool with Slack

        Wrap your tool using the Auth0 AI SDK to obtain an access token for the Slack API.

        ```python ./src/lib/tools/list_channels.py wrap lines highlight={4,13,24,28} theme={null}
        from slack_sdk import WebClient
        from slack_sdk.errors import SlackApiError
        from llama_index.core.tools import FunctionTool
        from auth0_ai_llamaindex.token_vault import get_access_token_from_token_vault, TokenVaultError
        from src.lib.auth0_ai import with_slack

        def list_slack_channels_tool_function():
            # Get the access token from Auth0 AI
            access_token = get_access_token_from_token_vault()

            # Slack SDK
            try:
                client = WebClient(token=access_token)
                response = client.conversations_list(
                    exclude_archived=True,
                    types="public_channel,private_channel",
                    limit=10
                )
                channels = response['channels']
                channel_names = [channel['name'] for channel in channels]
                return channel_names
            except SlackApiError as e:
                if e.response['error'] == 'not_authed':
                    raise TokenVaultError("Authorization required to access the Token Vault API")

                raise ValueError(f"An error occurred: {e.response['error']}")

        list_slack_channels_tool = with_slack(FunctionTool.from_defaults(
            name="list_slack_channels",
            description="List channels for the current user on Slack",
            fn=list_slack_channels_tool_function,
        ))
        ```

        Now that the tool is protected, you can pass it your LlamaIndex agent.

        ```python ./src/lib/agent.ts wrap lines highlight={3,13} theme={null}
        from datetime import datetime
        from llama_index.agent.openai import OpenAIAgent
        from src.lib.tools.list_channels import list_slack_channels_tool

        system_prompt = f"""You are an assistant designed to answer random user's questions.
        **Additional Guidelines**:
        - Today’s date for reference: {datetime.now().isoformat()}
        """

        agent = OpenAIAgent.from_tools(
            tools=[
                # a tool with Token Vault access
                list_slack_channels_tool
                # ... other tools
            ],
            model="gpt-4o",
            system_prompt=system_prompt
            verbose=True,
        )
        ```

        ### 3. Handle authentication redirects

        Interrupts are a way for the system to pause execution and prompt the user to take an action —such as authenticating or granting API access— before resuming the interaction. This ensures that any required access is granted dynamically and securely during the chat experience. In this context, Auth0-AI SDK manages such authentication redirects integrated with the LLamaIndex SDK.

        #### Server side

        On the server side of your Flask application you will need to set up a route to handle the Chat API requests. This route will be responsible for forwarding the requests to the OpenAI API utilizing LlamaIndex's SDK, that has been initialized with Auth0 AI's protection enhancements for tools.

        When `TokenVaultInterrupt` error occurs, the server side will signal the front-end about the level access restrictions, and the front-end should prompt the user to trigger a new authorization (or login) request with the necessary permissions.

        ```python ./src/app.py wrap lines highlight={3-5,19-20} theme={null}
        from dotenv import load_dotenv
        from flask import Flask, request, jsonify, session
        from auth0_ai_llamaindex.auth0_ai import Auth0AI
        from auth0_ai_llamaindex.token_vault import TokenVaultInterrupt
        from src.lib.agent import agent

        load_dotenv()
        app = Flask(__name__)

        @app.route("/chat", methods=["POST"])
        async def chat():
            if "user" not in session:
                return jsonify({"error": "unauthorized"}), 401

            try:
                message = request.json.get("message")
                response = agent.achat(message)
                return jsonify({"response": str(response)})
            except TokenVaultInterrupt as e:
                return jsonify({"error": str(e.to_json())}), 403
            except Exception as e:
                return jsonify({"error": str(e)}), 500
        ```
      </Tab>

      <Tab title="CrewAI" icon="https://mintlify-assets.b-cdn.net/auth0/crew_ai.svg">
        comming soon!
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Account Linking

If you're integrating with Google, but users in your app or agent can sign in using other methods (e.g., a username and password or another social provider), you'll need to link these identities into a single user account. Auth0 refers to this process as [Account Linking](https://auth0.com/docs/manage-users/user-accounts/user-account-linking).

**Account Linking** logic and handling will vary depending on your app or agent. You can find an example of how to implement it in a Next.js chatbot app [here](https://github.com/auth0-lab/market0/blob/main/app/api/auth/%5Bauth0%5D/route.ts#L43). If you have questions or are looking for best practices, [join our Discord](http://discord.gg/XbQpZSF2Ys) and ask in the `#auth0-for-gen-ai` channel.


# How-Tos
Source: https://auth0.com/ai/docs/how-tos/overview

Explore How-Tos of common Auth0 for AI Agents use cases.

## JavaScript & Python

<CardGroup>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google">
    Learn how to use Auth0 for AI Agents SDKs to check your Google Calendar availability.
  </Card>

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github">
    Use OpenAI, NextJS, and the Auth0 SDKs to list your GitHub repositories.
  </Card>

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack">
    Use OpenAI, NextJS, and the Auth0-AI SDKs to list your Slack channels.
  </Card>

  <Card title="Get Salesforce opportunities" href="/how-tos/get-salesforce-opportunities" icon="salesforce">
    Integrate with the Vercel AI SDK, OpenAI, and Auth0 to get a list of Salesforce opportunities.
  </Card>
</CardGroup>


# Amazon
Source: https://auth0.com/ai/docs/integrations/amazon

Connect your AI agents to Amazon to manage inventory, update product listings, and track sales performance.

Connect your AI agents to Amazon to help sellers manage inventory, update product listings, and track sales performance, or help buyers track product prices and availability.

## Connect Amazon to Auth0

<Steps>
  <Step title="Amazon setup">
    1. Visit the [Amazon Developer account](https://developer.amazon.com/) page and sign up.
    2. Create a new Security Profile in the Amazon Developer Console.
    3. Complete the Consent Screen Information form.
    4. Select the Show Client ID and Client Secret link.
    5. Copy the Client ID and Client Secret.
    6. Select your new Security Profile, then open Web Settings from the dropdown.
    7. Click Edit and configure Allowed Origins and Allowed Return URLs.
    8. Use these values:

       * Allowed Origins: `https://YOUR_AUTH0_DOMAIN`
       * Allowed Return URLs: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    9. Click Save.

    To learn more about setting up Amazon, read the [Login with Amazon documentation](https://developer.amazon.com/docs/login-with-amazon/documentation-overview.html).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Amazon connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Basecamp
Source: https://auth0.com/ai/docs/integrations/basecamp

Connect your AI agent to a user's Basecamp account to create projects, add to-do items, post messages, and upload files.

Connect your AI agent to a user's Basecamp account to create new projects, add to-do items, post messages, and upload files based on external triggers.

## Connect Basecamp to Auth0

<Steps>
  <Step title="Basecamp setup">
    1. Sign up for a [Basecamp account](https://basecamp.com/) if you don't already have one.
    2. Visit the [37signals Launchpad integrations page](https://launchpad.37signals.com/integrations) and sign in.
    3. Click **Register a new application**.
    4. Fill in the application details:

       * **Name**: Enter a descriptive name for your integration
       * **Website URL**: `https://YOUR_AUTH0_DOMAIN`
       * **Redirect URI**: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    5. Complete the registration and note your **Client ID** and **Client Secret**.

    To learn more about Basecamp OAuth setup, read the [Basecamp API Authentication documentation](https://github.com/basecamp/api/blob/master/sections/authentication.md).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Basecamp connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Bitbucket
Source: https://auth0.com/ai/docs/integrations/bitbucket

Connect your AI agent to Bitbucket to manage repositories and automate pull request creation and management.

Connect your AI agent to Bitbucket to manage repositories, automate pull request creation and management, and integrate with CI/CD pipelines to report build statuses.

## Connect Bitbucket to Auth0

<Steps>
  <Step title="Bitbucket setup">
    1. Visit the [Bitbucket Developer account](https://bitbucket.org/) page and sign up.
    2. Navigate to workspace settings.
    3. Add a new OAuth 2.0 consumer.
    4. Fill in the required details.
    5. Configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    6. Set permissions/scopes.
    7. Click Save.
    8. Toggle the consumer name to see the generated Key and Secret value for your consumer.
    9. Copy the Consumer Key and Consumer Secret.

    To learn more about setting up Bitbucket, read the [Login with Bitbucket documentation](https://developer.atlassian.com/cloud/bitbucket/rest/intro/#oauth-2-0).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Bitbucket connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Box
Source: https://auth0.com/ai/docs/integrations/box

Connect your AI Agents to Box for file management and collaboration.

Connect your AI Agents to Box for file management and collaboration.

## Connect Box to Auth0

<Steps>
  <Step title="Box Setup">
    1. Sign up for a [Box Developer account](https://developers.box.com/)
    2. Set up an app using Box's [Custom Apps: Setup with OAuth 2.0](https://developer.box.com/guides/applications/custom-apps/oauth2-setup/) documentation
    3. Note your **Client ID** and **Client Secret**
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Box connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# DigitalOcean
Source: https://auth0.com/ai/docs/integrations/digitalocean

Connect your AI agent to a user's DigitalOcean account to automate the creation and management of servers and storage volumes.

Connect your AI agent to a user's DigitalOcean account to automate the creation and management of servers (Droplets), configure networking, and manage storage volumes.

## Connect DigitalOcean to Auth0

<Steps>
  <Step title="DigitalOcean setup">
    1. Sign up for a [DigitalOcean account](https://cloud.digitalocean.com/registrations/new) if you don't already have one.
    2. Visit the [OAuth Applications page](https://cloud.digitalocean.com/account/api/applications) in your DigitalOcean control panel.
    3. Click **Register OAuth Application** to create a new OAuth application.
    4. Fill in the application details:

       * **Name**: Enter a descriptive name for your integration
       * **Homepage URL**: `https://YOUR_AUTH0_DOMAIN`
       * **Application description**: Brief description of your application
       * **Callback URL**: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    5. Click **Register OAuth Application** and note your **Client ID** and **Client Secret**.

    To learn more about DigitalOcean OAuth setup, read the [DigitalOcean OAuth API documentation](https://docs.digitalocean.com/reference/api/oauth/).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your DigitalOcean connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Discord
Source: https://auth0.com/ai/docs/integrations/discord

Connect your AI agent to a Discord server to welcome new members, play music, manage user roles, and integrate with other services.

Connect your AI agent to a Discord server to welcome new members, play music, manage user roles, and integrate with other services to post notifications.

## Connect Discord to Auth0

<Steps>
  <Step title="Discord setup">
    1. Visit the [Discord Developer account](https://discord.com/developers/applications) page and sign up.
    2. Create a new application in the Discord Developer Portal
    3. Navigate to the OAuth2 section and configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    4. Note your **Client ID** and **Client Secret**
    5. Set permissions/scopes you need:
       * For basic login, the **identify** scope is generally required to get basic user information
    6. Save changes

    To learn more about setting up Discord, read the [Login with Discord documentation](https://discord.com/developers/docs/topics/oauth2).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Discord connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Dropbox
Source: https://auth0.com/ai/docs/integrations/dropbox

Connect your AI agent to a user's Dropbox account to automatically organize files into folders and manage shared links.

Connect your AI agent to a user's Dropbox account to automatically organize files into folders, create and manage shared links, and initiate file requests.

## Connect Dropbox to Auth0

<Steps>
  <Step title="Dropbox setup">
    1. Visit the [Dropbox Developer account](https://www.dropbox.com/developers) page and sign up.
    2. Create a new app in the [Dropbox App Console](https://www.dropbox.com/developers/apps).
    3. On create an app choose "Scoped access".
    4. Choose the type of access you need.
    5. Give your app a unique name.
    6. Click Create app.
    7. Select the Show App Secret link to reveal the app secret.
    8. Copy the App Key and App Secret.
    9. Configure OAuth redirect URI:

       * Redirect URI: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    10. Click the Add button to save the redirect URI.
    11. Configure the permissions your app needs.
    12. Save changes.

    To learn more about setting up Dropbox, read the [Developer guide for Dropbox documentation](https://www.dropbox.com/developers/documentation/http/documentation).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Dropbox connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Figma
Source: https://auth0.com/ai/docs/integrations/figma

Connect your AI agent to a user's Figma account to export assets and apply changes to design files programmatically.

Connect your AI agent to a user's Figma account to export assets, apply changes to design files programmatically, and comment on prototypes to automate design feedback loops.

## Connect Figma to Auth0

<Steps>
  <Step title="Figma setup">
    1. Visit the [Figma Developer account](https://www.figma.com/developers/api) page and sign up.
    2. Create a new app in the Figma Developer Dashboard.
    3. Provide a name for your app and select a team or organization to associate it with.
    4. Copy and securely store the **Client ID** and **Client Secret** that Figma provides.
    5. Configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    6. Select the necessary scopes that your application needs to access (current\_user:read, file\_content:read, file\_comments:write, etc.).
    7. Publish it.

    To learn more about setting up Figma, read the [Login with Figma documentation](https://developers.figma.com/docs/rest-api/authentication/).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Figma connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Fitbit
Source: https://auth0.com/ai/docs/integrations/fitbit

Connect your AI agent to a user's Fitbit account to track fitness data and set new fitness goals.

Connect your AI agent to a user's Fitbit account to track fitness data, log activities or food intake, and set new fitness goals.

## Connect Fitbit to Auth0

<Steps>
  <Step title="Fitbit setup">
    1. Visit the [Fitbit Developer account](https://dev.fitbit.com/) page and sign up.
    2. Create a new application in the Fitbit Developer Console.
    3. Complete the application details form.
    4. Select the OAuth 2.0 Application Type.
    5. Configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    6. Default Access Type: Select Read-Only or Read and Write.
    7. Click Save.
    8. After creation you'll be shown the client ID and client secret.
    9. Copy the Client ID and Client Secret.

    To learn more about setting up Fitbit, read the [Developer guide for Fitbit documentation](https://dev.fitbit.com/build/reference/web-api/oauth2/).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Fitbit connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Freshbooks
Source: https://auth0.com/ai/docs/integrations/freshbooks

Connect your AI agent to a user's FreshBooks account to create invoices, track expenses, and manage client information.

Connect your AI agent to a user's FreshBooks account to create and send invoices, track expenses from receipts, and manage client information.

## Connect Freshbooks to Auth0

<Steps>
  <Step title="Freshbooks setup">
    1. Visit the [Freshbooks Developer account](https://www.freshbooks.com/developers) page and sign up.
    2. Create a new app in the [Freshbooks Developer Center](https://my.freshbooks.com/#/developer)
    3. Configure the app details:

       * Set an Application Name.
       * Set the Redirect URI: `https://YOUR_AUTH0_DOMAIN/login/callback`
       * Note: FreshBooks requires HTTPS for redirect URIs (except for local development).

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    4. Select the necessary Scopes (e.g., user:profile:read, user:clients:read, user:invoices:read, etc.)
    5. Save and copy the **Client ID** and **Client Secret**

    To learn more about setting up Freshbooks, read the [Login with Freshbooks documentation](https://www.freshbooks.com/api/authentication).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your FreshBooks connection, you can use the following code snippet in your application:

<Tabs>
  <Tab title="JavaScript" icon="js">
    ```tsx wrap lines theme={null}
    const auth0AI = new Auth0AI();

    export const withFreshbooksConnection = auth0AI.withTokenVault({
      connection: "freshbooks",
      scopes: [
          // required scopes for Token Vault
          "user:profile:read",
          // optional scopes specific to your app
          ...
      ],
      refreshToken: getAuth0RefreshToken(),
      authorizationParams: {
        prompt: "login",
      },
    });
    ```
  </Tab>

  <Tab title="Python" icon="python">
    ```python wrap lines theme={null}
    auth0_ai = Auth0AI()

    with_freshbooks_connection = auth0_ai.with_token_vault(
        connection="freshbooks",
        scopes=[
            # required scopes for Token Vault
            "user:profile:read",
            # optional scopes specific to your app
            ...
        ],
        refresh_token=get_auth0_refresh_token,
        authorization_params={
            "prompt": "login",
        },
    )
    ```
  </Tab>
</Tabs>

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# GitHub
Source: https://auth0.com/ai/docs/integrations/github

Connect your AI Agents to GitHub for repository access, issue management, and developer workflows.

Connect your AI Agents to GitHub for repository access, issue management, and developer workflows.

## Connect GitHub to Auth0

<Warning>
  <strong>GitHub app permissions</strong>

  GitHub apps [use fine grained permissions](https://docs.github.com/en/enterprise-server@3.17/apps/oauth-apps/building-oauth-apps/differences-between-github-apps-and-oauth-apps#requesting-permission-levels-for-resources) and hence requesting permissions when configuring Token Vault is not supported. Instead, you should set the required permissions when creating the GitHub app in the GitHub developer settings.
</Warning>

<Steps>
  <Step title="GitHub Setup">
    <ol>
      <li>
        Sign up for a [GitHub Developer account](https://github.com/signup)
      </li>

      <li>
        Set up a new GitHub app via [GitHub Developer Settings > GitHub
        Apps](https://github.com/settings/apps/new)
      </li>

      <li>
        Use the following settings when configuring your GitHub app:

        <ul>
          <li>Homepage URL: `https://YOUR_AUTH0_DOMAIN`</li>
          <li>Callback URL: `https://YOUR_AUTH0_DOMAIN/login/callback`</li>
          <li>Webhook Active: Disabled</li>
          <li>Permissions: Select the appropriate permissions for your app</li>
        </ul>

        <Info>
          You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

          You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

          If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
        </Info>
      </li>

      <li>
        Create the app and generate a new client secret in the app settings page
        that appears.
      </li>

      <li>Note your **Client ID** and **Client Secret**</li>
    </ol>
  </Step>

  <Step title="Configure the GitHub Social Connection in Auth0">
    <ol>
      <li>
        In the [Auth0 Dashboard](https://manage.auth0.com/), navigate to
        **Authentication > Social**. Select **Create Connection** and then
        **GitHub**. Click **Continue**.
      </li>

      <li>
        In **General**, enter the **Client ID** and **Client Secret** from the
        GitHub OAuth app you created.
      </li>

      <li>
        In **Purpose**, toggle on **Connected Accounts for Token Vault**. This allows the
        connection to retrieve and securely store access tokens for external APIs. To learn more, read [Connected Accounts for Token
        Vault](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault).
      </li>

      <li>Click **Create**.</li>

      <li>
        After saving, go the **Applications** tab and select the applications
        that should use this connection.
      </li>
    </ol>
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration Example

To configure the Token Vault for your GitHub connection, you can use the following code snippet in your application:

<Tabs>
  <Tab title="JavaScript" icon="js">
    ```tsx wrap lines theme={null}
    const auth0AI = new Auth0AI();

    export const withGitHubConnection = auth0AI.withTokenVault({
      connection: "github",
      // scopes are not supported for GitHub yet. Set required scopes when creating the accompanying GitHub app
      scopes: [],
      refreshToken: getAuth0RefreshToken(),
    });
    ```
  </Tab>

  <Tab title="Python" icon="python">
    ```python wrap lines theme={null}
    auth0_ai = Auth0AI()

    with_github_connection = auth0_ai.with_token_vault(
        connection="github",
        # scopes are not supported for GitHub yet. Set required scopes when creating the accompanying GitHub app
        scopes=[],
        refresh_token=get_auth0_refresh_token,
    )
    ```
  </Tab>
</Tabs>

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Google
Source: https://auth0.com/ai/docs/integrations/google

Connect your AI Agents to Google services including Gmail, Google Calendar, Drive, and more.

The Google integration allows users to log in to your AI Agents using their Google profile. To complete the [Call other's APIs on user's behalf quickstart](/get-started/call-others-apis-on-users-behalf), you need to set up a Google social connection.

To set up a Google social connection, you must:

* Create Google OAuth credentials with the Google Auth Platform.
* Configure and test a Google social connection with the Auth0 Dashboard.

## Prerequisites

1. [Sign up for a Google Developer account](https://console.developers.google.com/).
2. [Create a Google project](https://support.google.com/googleapi/answer/6251787?ref_topic=7014522).

## Google Auth Platform

The Google Auth Platform helps you manage your applications and OAuth credentials for logging in and calling Google APIs. To learn more, read [Get started with the Google Auth Platform](https://support.google.com/cloud/answer/15544987?hl=en).

Use the Google Auth Platform to:

* [Configure Google consent screen](#configure-google-consent-screen)
* [Create Google OAuth Client](#create-google-oauth-client)
* [Enable Google APIs](#enable-google-apis)

### Configure Google consent screen

<Note>
  **Note:** If your application requests sensitive OAuth scopes or uses a custom
  image, [Google limits it to 100 logins until the OAuth consent screen is
  verified](https://developers.google.com/apps-script/guides/client-verification).
  Consent screen verification may take up to several days.
</Note>

When you use OAuth 2.0 for authorization, your application requests authorization for one or more scopes of access from a Google Account. Google displays a consent screen to the user, including a summary of your project, its policies, and the requested access scopes.

Before creating an OAuth client ID, you must first configure the OAuth consent screen with information about your application.

In the Google Cloud Console, [configure your Google OAuth consent screen](https://developers.google.com/workspace/guides/configure-oauth-consent):

<Steps>
  <Step title="Configure Authorized domains">
    Navigate to **Google Auth Platform > Branding**. For Authorized domains,
    enter `auth0.com`. If you're using a [custom
    domain](https://auth0.com/docs/customize/custom-domains), enter your custom
    domain instead.
  </Step>

  <Step title="Configure Audience">
    Navigate to **Google Auth Platform > Audience**. For **User type**, select
    **Make External**. In **Test Users**, you can add the email addresses you
    want to use for testing.
  </Step>

  <Step title="Configure Data Access">
    Navigate to **Google Auth Platform > Data Access** to add or remove scopes.
    To learn more, read [OAuth 2.0 Scopes for Google
    APIs](https://developers.google.com/identity/protocols/oauth2/scopes).
  </Step>

  <Step title="Configure Consent screen">
    Follow the rest of the instructions to finish [configuring your Google OAuth
    consent
    screen](https://developers.google.com/workspace/guides/configure-oauth-consent).
  </Step>

  <Step title="Save Changes">Select **Save Changes**.</Step>
</Steps>

### Create Google OAuth Client

In the Google Cloud Console, [create a new OAuth 2.0 Client](https://console.cloud.google.com/auth/clients/create):

<Steps>
  <Step title="Create Client">
    Navigate to **Google Auth Platform > Clients**. Then, select **New Client**.
  </Step>

  <Step title="Select Application type">
    For the **Application type**, select **Web application**.
  </Step>

  <Step title="Configure Client credentials">
    Enter the following information for your OAuth 2.0 Client:

    <ul>
      <li>**Name**: The name of your OAuth 2.0 Client.</li>
      <li>**Authorized JavaScript origins**: `https://{YOUR_AUTH0_DOMAIN}`</li>

      <li>
        **Authorized redirect URIs**: `https://{YOUR_AUTH0_DOMAIN}/login/callback`
      </li>
    </ul>

    <Info>
      You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

      You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

      If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
    </Info>
  </Step>

  <Step title="Complete">Select **Create**.</Step>
</Steps>

### Enable Google APIs

Enable Google APIs for your OAuth 2.0 Client:

<Steps>
  <Step title="Search the Google API Library">
    Navigate to the [Google API Library](https://console.cloud.google.com/apis/library). Then, search for your Google API and select it from the results.
  </Step>

  <Step title="Enable Google API">
    For each Google API you want to enable, select **Enable**.
  </Step>
</Steps>

## Auth0 Dashboard

Use the Auth0 Dashboard to create and configure a Google social connection with the proper OAuth credentials.

### Create Google social connection

Use the [Auth0 Dashboard](https://manage.auth0.com/) to create a new Google social connection.

<Steps>
  <Step title="Create Connection">
    Navigate to **Authentication > Social**. Select **Create Connection** and
    then **Google/Gmail**.
  </Step>

  <Step title="Configure Client credentials">
    In **General**, enter the client credentials from the Google OAuth 2.0
    Client you created:

    <ul>
      <li>**Client ID**: The unique identifier for your application.</li>

      <li>
        **Client Secret**: The secret used by the application to authenticate
        with Auth0. To learn more, read [Client secret
        authentication](https://auth0.com/docs/secure/application-credentials#client-secret-authentication).
      </li>
    </ul>
  </Step>

  <Step title="Enable Connected Accounts for Token Vault">
    In **Purpose**, toggle on **Connected Accounts for Token Vault**. This allows the connection
    to retrieve and securely store access tokens for external APIs. To learn
    more, read [Connected Accounts for Token Vault](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault).
  </Step>

  <Step title="Select Permissions">
    In **Permissions**, select <strong>Offline Access</strong>, allowing your client application to obtain a refresh token from the external provider. When you get an access token for the Google social connection, it will contain the appropriate
    scopes so you can use it to call the required Google APIs.
  </Step>

  <Step title="Enable Applications">
    After saving, go the **Applications** tab and select the applications that
    should use this connection.
  </Step>
</Steps>

### Test connection

Once you have created your Google social connection, [test your connection](https://auth0.com/docs/dashboard/guides/connections/test-connections-social).

## Token Vault configuration Example

To configure the Token Vault for your Google connection, you can use the following code snippet in your application:

<Tabs>
  <Tab title="JavaScript" icon="js">
    ```tsx wrap lines theme={null}
    const auth0AI = new Auth0AI();

    export const withGoogleConnection = auth0AI.withTokenVault({
      connection: "google-oauth2",
      scopes: ["openid", "https://www.googleapis.com/auth/calendar.freebusy", ...],
      refreshToken: getAuth0RefreshToken(),
    });
    ```
  </Tab>

  <Tab title="Python" icon="python">
    ```python wrap lines theme={null}
    auth0_ai = Auth0AI()

    with_google_connection = auth0_ai.with_token_vault(
        connection="google-oauth2",
        scopes=["openid", "https://www.googleapis.com/auth/calendar.freebusy", ...],
        refresh_token=get_auth0_refresh_token,
    )
    ```
  </Tab>
</Tabs>

## Learn more

* Auth0 stores the access and refresh tokens for each connected account in the [Token Vault](https://auth0.com/docs/secure/tokens/token-vault). Applications can then access the Token Vault to retrieve access tokens to call external APIs. To learn more, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* Learn how to get an access token to make a tool call by completing the [Call other's APIs on user's behalf quickstart](/get-started/call-others-apis-on-users-behalf).


# Google Workspace
Source: https://auth0.com/ai/docs/integrations/google-workspace

Connect your AI agents to Google Workspace services including Gmail, Calendar, Sheets, Drive, and more.

The Google Workspace integration allows users to authenticate with your AI agents using their Google Workspace identity. This integration provides access to Google's ecosystem of applications and services and is essential for B2B scenarios where users need to access their work data and collaborate through Google services.

## Connect Google Workspace with Auth0

To set up a Google Workspace connection with Auth0, follow the [Connect Your App to Google Workspace](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/google-apps) detailed guide.

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Google Workspace connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Hugging Face
Source: https://auth0.com/ai/docs/integrations/hugging-face

Connect your AI agent to a user's Hugging Face account to manage and upload models and datasets.

Connect your AI agent to a user's Hugging Face account to manage and upload models and datasets to the Hub, and interact with Spaces.

## Connect Hugging Face to Auth0

<Steps>
  <Step title="Hugging Face setup">
    1. Visit the [Hugging Face Developer account](https://huggingface.co/) page and sign up.
    2. Navigate to the connected apps section under settings.
    3. Create a new OAuth application in the Hugging Face Developer Console.
    4. Complete the application form.
    5. Configure scopes:
       * Add the necessary scopes for your application.
    6. Configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    7. Click Create Application.
    8. After creation you'll be shown the client ID and client secret.
    9. Copy the Client ID and Client Secret.

    To learn more about setting up Hugging Face, read the [Developer guide for Hugging Face documentation](https://huggingface.co/docs/hub/oauth).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Hugging Face connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Microsoft
Source: https://auth0.com/ai/docs/integrations/microsoft

Connect your AI Agents to Microsoft services including Outlook, Teams, OneDrive, and more.

Connect your AI Agents to Microsoft services including Outlook, Teams, OneDrive, and more.

## Configuration

<Steps>
  <Step title="Azure Setup">
    1. [Sign up for an account on the Azure
       portal](https://azure.microsoft.com/en-us/free/?ref=microsoft.com\&utm_source=microsoft.com\&utm_medium=docs\&utm_campaign=visualstudio)
    2. [Create an Azure AD
       Tenant](https://learn.microsoft.com/en-us/entra/external-id/customers/quickstart-tenant-setup)
  </Step>

  <Step title="Microsoft Setup">
    1. Register an app in Azure using Microsoft's [Quickstart: Register an
       application with the Microsoft identity
       platform](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app)
       documentation.
    2. During this process, Microsoft will generate an
       **Application (client) ID** and a **Client Secret** for your application;
       make note of these.
  </Step>

  <Step title="Auth0 Setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Microsoft connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Microsoft Entra (Azure AD)
Source: https://auth0.com/ai/docs/integrations/microsoft-azure

Connect your AI agents to Microsoft Entra services including Outlook, Teams, OneDrive, and more.

The Microsoft Entra integration allows users to authenticate with your AI agents using their Microsoft Entra identity. This integration provides access to Microsoft's ecosystem of applications and services and is essential for B2B scenarios where users need to access their work data and collaborate through Microsoft services.

## Connect Microsoft Entra with Auth0

To set up a Microsoft Entra connection with Auth0, follow the [Connect Your App to Microsoft Entra](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/azure-active-directory/v2) detailed guide.

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Microsoft Entra connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# OAuth2
Source: https://auth0.com/ai/docs/integrations/oauth2

Build a custom social connection for any OAuth2 compliant authorization server.

The custom OAuth2 connection allows you to create integrations with any OAuth2 compliant service that isn't available as a built-in integration type.

## Overview

If a specific identity provider or service isn't available out of the box, Auth0 allows you to create custom social connections. This is particularly useful for integrating with proprietary systems, regional services, or specialized OAuth2 providers.

To learn more and configure a custom OAuth2 connection with Auth0, see our [Connect Apps to Generic OAuth2 Authorization Servers documentation](https://auth0.com/docs/authenticate/identity-providers/social-identity-providers/oauth2).

## Configure Connected Accounts for Token Vault

After creating the connection, in the **Purpose** section, toggle on **Connected Accounts for Token Vault**. This allows your connection to retrieve and securely store access tokens for external APIs. To learn more, read [Connected Accounts for Token Vault](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault).

## Learn more

* Auth0 stores the access and refresh tokens for each connected account in the [Token Vault](https://auth0.com/docs/secure/tokens/token-vault). Applications can then access the Token Vault to retrieve access tokens to call external APIs. To learn more, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* Learn how to get an access token to make a tool call by completing the [Call other's APIs on user's behalf quickstart](/get-started/call-others-apis-on-users-behalf).


# OpenID Connect (OIDC)
Source: https://auth0.com/ai/docs/integrations/oidc

Configure a custom OIDC connection to integrate with any OpenID Connect compliant identity provider.

The OpenID Connect (OIDC) connection allows you to integrate with any identity provider that supports the OpenID Connect standard, providing flexibility for custom integrations.

## Overview

OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows your application to verify the identity of users and obtain basic profile information in an interoperable and REST-like manner.

To learn more and configure a custom OIDC connection with Auth0, see our [Connect to OpenID Connect Identity Provider documentation](https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers/oidc).

## Configure Token Vault

After creating the connection, at the bottom of the connection settings in the **Advanced** section enable the **Enable Token Vault** toggle. This will allow your connection to retrieve and store access tokens for third-party APIs.

## Learn more

* Auth0 stores the access and refresh tokens for each connected account in the [Token Vault](https://auth0.com/docs/secure/tokens/token-vault). Applications can then access the Token Vault to retrieve access tokens to call external APIs. To learn more, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* Learn how to get an access token to make a tool call by completing the [Call other's APIs on user's behalf quickstart](/get-started/call-others-apis-on-users-behalf).


# Integrations
Source: https://auth0.com/ai/docs/integrations/overview

The following integrations are available for use with your AI Agents through Auth0.

Allow your AI Agents to interact with these applications by setting up an Auth0 Connection. Users can log in to your application using these identities or give access to share their data with your AI Agents.

<SearchAndFilterGrid />

<Info>
  **Can't find what you're looking for?**

  You can build a custom integration for any OAuth2-compliant service using our [Custom OAuth2 Connection](/integrations/oauth2) guide, or contact our team to request a new integration.
</Info>

## Getting Started

Ready to start using integrations in your application?

<Columns>
  <Card title="Call an API Using Your Integration" href="/get-started/call-others-apis-on-users-behalf" icon="key" />
</Columns>


# PayPal
Source: https://auth0.com/ai/docs/integrations/paypal

Connect your AI agent to a user's PayPal account to automate invoice sending and process payments.

Connect your AI agent to a user's PayPal account to automate the sending of invoices, process payments, and manage recurring subscription billing.

## Connect PayPal to Auth0

<Steps>
  <Step title="PayPal setup">
    1. Visit the [PayPal Developer account](https://developer.paypal.com/) page and sign up.
    2. Create a new App in the PayPal Developer Console.
    3. Give the app a name and choose whether it's for test (Sandbox) or live.
    4. Click Create App to see the app detail page.
    5. Copy the Client ID and Client Secret.
    6. Enable the appropriate the features.
    7. Click Advanced Settings and configure the Return URL.

       * Return URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    8. Select scope attributes for OpenID connect (OAuth2) protocol.
    9. Click Save to save changes.

    To learn more about setting up PayPal, read the [PayPal Developer documentation](https://developer.paypal.com/docs/api/overview/).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your PayPal connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Salesforce
Source: https://auth0.com/ai/docs/integrations/salesforce

Connect your AI agent to a user's Salesforce account to create or update leads, manage contacts, and automate case management.

Connect your AI agent to a user's Salesforce account to create or update leads and contacts, log call and email activities, generate reports, and automate case management.

## Connect Salesforce to Auth0

<Steps>
  <Step title="Salesforce setup">
    1. Sign up for a [Salesforce Developer account](https://developer.salesforce.com/signup) or use your existing Salesforce org.
    2. In your Salesforce org, navigate to **Setup** → **Platform Tools** →  **Apps** → **App Manager**.
    3. Click **New External Client App**.
    4. Fill in the basic information:
       * **Connected App Name**: Enter a descriptive name for your integration
       * **API Name**: This will be auto-generated based on the app name
       * **Contact Email**: Your email address
    5. In the **API (Enable OAuth Settings)** section:

       * Check **Enable OAuth Settings**
       * **Callback URL**: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>

       * **Selected OAuth Scopes**: Add the following scopes:
         * `api` - Access and manage your data (api)
         * `refresh_token` - Perform requests on your behalf at any time (refresh\_token, offline\_access)
         * `openid` - Access your identity URL service
    6. **Important Token Configuration** (for optimal Token Vault compatibility):
       * **Require Secret for Web Server Flow**: Check this option for enhanced security
       * **Require Secret for Refresh Token Flow**: Check this option to secure token refresh operations
       * **Enable Refresh Token Rotation**: Check this option to enable rotation on each refresh
       * **Issue JSON Web Token (JWT)-based access tokens for named users**: check this option, it provides longer token validity and better performance
    7. Click **Create** and wait for the app to be created.
    8. After creation, note your **Consumer Key** (Client ID) and **Consumer Secret** (Client Secret).

    <Warning>
      **Token Configuration Important Notes**:

      * If you select **opaque** tokens instead of JWT, Token Vault will default the expiry time to 10 minutes, which may cause frequent token refreshes.
      * Ensure the `refresh_token` scope is enabled in your Connected App settings, not just requested in Auth0. Without this scope enabled on the Salesforce side, Auth0 cannot request refresh tokens.
      * Consider enabling refresh token rotation for better security practices.
    </Warning>

    To learn more about Salesforce Connected App setup, read the [Create a Connected App documentation](https://help.salesforce.com/s/articleView?id=sf.connected_app_create.htm).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />

    <Warning>
      **Required Scopes**: Make sure to include the following scopes in your Auth0 connection configuration:

      * `openid` - Access your identity URL service
      * `api` - Access and manage your data
      * `refresh_token` - Perform requests on your behalf at any time
      * `offline_access` - Maintain access when you're not present

      These scopes must also be enabled in your Salesforce Connected App configuration.
    </Warning>
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Salesforce connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Troubleshooting

### Invalid Grant Errors

If you encounter `invalid_grant` errors with expired access/refresh tokens:

1. **Check token configuration**: Ensure your Connected App uses JWT tokens instead of opaque tokens.
2. **Verify refresh token policy**: Set the refresh token policy to "valid until revoked" in your Connected App.
3. **Scope configuration**: Confirm that the `refresh_token` and `offline_access` scopes are enabled in both your Salesforce Connected App and Auth0 connection.
4. **Token rotation**: If using refresh token rotation, ensure your application handles the new refresh token returned with each refresh request.

### Common Issues

* **Scope errors**: Ensure all required scopes are enabled in your Salesforce Connected App settings, not just requested in Auth0.
* **Token expiry**: JWT tokens have longer expiry times than opaque tokens. If using opaque tokens, expect frequent token refreshes.
* **Multiple authorizations**: Avoid authorizing the same user multiple times rapidly, as this may cause token invalidation issues.

For additional troubleshooting resources, refer to Salesforce's OAuth troubleshooting documentation and error code references.

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Slack
Source: https://auth0.com/ai/docs/integrations/slack

Connect your AI Agents to Slack for team communication and workflow automation.

Connect your AI Agents to Slack for team communication and workflow automation.

## Connect Slack to Auth0

<Steps>
  <Step title="Slack Setup">
    <ol>
      <li>
        Sign up for a [Slack Developer account](https://slack.com/signin).
      </li>

      <li>
        If you haven't already, create a [Slack
        App](https://api.slack.com/apps?new_app=1). Choose the **From scratch**
        option, give it a name and choose a workspace.
      </li>

      <li>
        Once your app is created, copy the **Client ID** and **Client Secret**.
      </li>

      <li>
        In the **OAuth & Permissions** section on the left side navigation, do
        the following:

        <ol>
          <li>
            Under **OAuth Tokens**, opt in for token rotation so that the app
            supports refresh tokens.
          </li>

          <li>
            Under **Redirect URLs**, add
            `https://YOUR_AUTH0_DOMAIN/login/callback` as a new Redirect URL.

            <Info>
              You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

              You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

              If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
            </Info>
          </li>

          <li>
            Under **Scopes**, add the necessary OAuth scopes your app needs to
            function.
          </li>
        </ol>
      </li>
    </ol>
  </Step>

  <Step title="Configure the Slack Social Connection in Auth0">
    <ol>
      <li>
        In the [Auth0 Dashboard](https://manage.auth0.com/), navigate to
        **Authentication > Social**. Select **Create Connection** and then
        **Sign in with Slack**. Click **Continue**.
      </li>

      <li>
        In **General**, enter the **Client ID** and **Client Secret** from the
        Slack OAuth app you created.
      </li>

      <li>
        In **Purpose**, toggle on **Connected Accounts for Token Vault**. This allows the
        connection to retrieve and securely store access tokens for external APIs
        . To learn more, read [Configure Connected Accounts for Token Vault](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault).
      </li>

      <li>Click **Create**.</li>

      <li>
        After saving, go the **Applications** tab and select the applications
        that should use this connection.
      </li>
    </ol>
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration Example

To configure the Token Vault for your GitHub connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Snapchat
Source: https://auth0.com/ai/docs/integrations/snapchat

Connect your AI agent to a user's Snapchat account to share content like photos, videos, and links.

Connect your AI agent to a user's Snapchat account to share content like photos, videos, and links.

## Connect Snapchat to Auth0

<Steps>
  <Step title="Snapchat setup">
    1. Visit the [Snapchat Developer account](https://developers.snapchat.com/) page and sign up.
    2. Navigate to the [Snap Kit Portal](https://developers.snap.com/snap-kit/home) and create a new app in the Snapchat Developer Portal.
    3. You will need to pick the libraries you plan to use: Login Kit is required at the minimum. Ensure **Login Kit** is enabled for your app.
    4. Generate a Confidential OAuth 2.0 Client ID and Client Secret and note:
       * **Client ID**  (OAuth client\_id)
       * **Client Secret** (OAuth client\_secret)
    5. Configure Redirect URIs:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`
       * Snapchat requires HTTPS for redirect URIs.

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    6. Choose the Login Kit scopes:
       * `https://auth.snapchat.com/oauth2/api/user.display_name` - For user's display name
       * `https://auth.snapchat.com/oauth2/api/user.external_id` - For a unique user ID
       * `https://auth.snapchat.com/oauth2/api/user.bitmoji.avatar`- Optional, for Bitmoji
    7. In the left hand panel, navigate to Versions > \[Your App Name], scroll to the Login Kit section and add the redirect URIs.

    To learn more about setting up Snapchat, read the [Login with Snapchat documentation](https://developers.snap.com/snap-kit/login-kit/overview).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Snapchat connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Spotify
Source: https://auth0.com/ai/docs/integrations/spotify

Connect your AI agent to a user's Spotify account to create and modify playlists.

Connect your AI agent to a user's Spotify account to create and modify playlists or add songs to their library.

## Connect Spotify to Auth0

<Steps>
  <Step title="Spotify setup">
    1. Sign up for a [Spotify Developer account](https://developer.spotify.com/).
    2. Create a new app in the Spotify Developer Dashboard.
    3. Make sure to select the API/SDKs you plan to use for your application.
    4. Configure Redirect URIs:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    5. When you click **Save** you will be redirected to the configuration page for the application you just created. You will see **Client ID** and can select *View Client Secret* to see your **Client Secret**. Make sure to note them down for the next steps:
       * **Client ID**  (OAuth client\_id)
       * **Client Secret** (OAuth client\_secret)

    To learn more about setting up Spotify, read the [Login with Spotify documentation](https://developer.spotify.com/documentation/web-api/concepts/authorization).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Spotify connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Stripe Connect
Source: https://auth0.com/ai/docs/integrations/stripe-connect

Connect your AI agent to Stripe to manage account setup, review payments, and create reports.

Connect your AI agent to Stripe to manage your account setup, review payments, or create reports.

## Connect Stripe to Auth0

<Steps>
  <Step title="Set up app in Stripe">
    1. Sign up for a [Stripe account](https://stripe.com/)
    2. Setup your account and complete any necessary verification steps to work with [Stripe Connect](https://dashboard.stripe.com/connect).
    3. Navigate to the Onboarding options for your Stripe Connect account and select [OAuth](https://dashboard.stripe.com/settings/connect/onboarding-options/oauth).
    4. Toggle **Enable OAuth** then fill in the Redirect URI and note your **Client ID** for later.

       * Redirect URI: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    5. Navigate to the [API Keys Page](https://dashboard.stripe.com/apikeys) and copy the **Client Secret**.
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Stripe connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Tumblr
Source: https://auth0.com/ai/docs/integrations/tumblr

Connect your AI agent to a user's Tumblr blog to create and schedule new posts and reblog content.

Connect your AI agent to a user's Tumblr blog to create and schedule new posts, reblog content, or review comments.

## Connect Tumblr to Auth0

<Steps>
  <Step title="Set up app in Tumblr">
    1. Sign up for a [Tumblr Developer account](https://api.tumblr.com/console)
    2. Create a new application in the Tumblr Developer Console if you don't have one already by select **Or register a new application**.
    3. You should be able to see your app in the list of [applications](https://www.tumblr.com/oauth/apps)
    4. Make sure to fill the *Default callback URL* and *OAuth2 redirect URLs* with your Tenant's callback URL

       * Redirect URI: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    5. Note your **OAuth consumer key** and **OAuth consumer secret**
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Tumblr connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Twitch
Source: https://auth0.com/ai/docs/integrations/twitch

Connect your AI agent to a user's Twitch channel to create stream markers and manage channel polls.

Connect your AI agent to a user's Twitch channel to create stream markers, manage channel polls and predictions, and create clips from a live stream.

## Connect Twitch to Auth0

<Steps>
  <Step title="Twitch setup">
    1. Visit the [Twitch Developer account](https://dev.twitch.tv/) page and sign up.
    2. Enable 2FA as Twitch requires it before you can register an application.
    3. Create a new application in the [Twitch Developer Console](https://dev.twitch.tv/console/apps).
    4. Complete the application registration form.
    5. Configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    6. Select a category from the dropdown.
    7. Select Confidential client type from the radio button group.
    8. Click Create button.
    9. Back in the Applications tab, locate your app under Developer Applications, and click Manage.
    10. After creating, Twitch shows your Client Id and let you create your Client Secret by clicking a button.
    11. Copy the Client ID and Client Secret.
    12. Click Save.

    To learn more about setting up Twitch, read the [Login with Twitch documentation](https://dev.twitch.tv/docs/authentication/register-app/).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your Twitch connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# X (Twitter)
Source: https://auth0.com/ai/docs/integrations/twitter

Connect your AI agent to a user's Twitter account to monitor keywords, automatically reply to tweets, and schedule content.

Connect your AI agent to a user's Twitter account to monitor for specific keywords or mentions, automatically reply to certain types of tweets, and schedule new content for posting.

## Connect X to Auth0

<Steps>
  <Step title="X setup">
    1. Visit the [X Developer account](https://developer.x.com/) page and sign up.
    2. Follow the onscreen instructions to create a new App in the X Developer Console.
    3. Complete the Consent Screen Information form.
    4. Navigate to Project and Apps and click on your app and go to settings.
    5. Go to User authentication settings and click on edit.
    6. Configure your permissions.
    7. Select type of App to enable OAuth2.0 Authentication.
    8. Configure OAuth redirect URL:

       * Redirect URL: `https://YOUR_AUTH0_DOMAIN/login/callback`

       <Info>
         You can find the **Auth0 domain** in the [Auth0 Dashboard](https://manage.auth0.com/).

         You can find this under **Applications > \[Your Application] > Settings > Basic Information > Domain**.

         If you are using the [custom domains](https://auth0.com/docs/custom-domains) feature, your Auth0 domain is the custom domain. You can find this under **Branding > Custom Domains**.
       </Info>
    9. Click Save.
    10. Still on the App settings page, click keys and tokens tab.
    11. Copy the Client ID and Client Secret.

    To learn more about setting up X, read the [X developer documentation](https://docs.x.com/fundamentals/developer-apps).
  </Step>

  <Step title="Auth0 setup">
    <Auth0SetupBlock />
  </Step>
</Steps>

<IntegrationInfoBlock />

## Token Vault configuration example

To configure the Token Vault for your X connection, you can use the following code snippet in your application:

<TokenVaultConfigBlock />

## Next steps

* To learn how to configure applications to access Token Vault, read [Configure Token Vault](https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault).
* To learn how to get an access token to make a tool call, complete the [Call other's APIs on user's behalf Quickstart](https://auth0.com/ai/docs/get-started/call-others-apis-on-users-behalf).


# Asynchronous Authorization
Source: https://auth0.com/ai/docs/intro/asynchronous-authorization

Asynchronous Authorization provides a secure "human-in-the-loop" mechanism, allowing agents to work autonomously in the background and seek user consent for sensitive or critical actions only when necessary.

This process relies on a decoupled authentication flow where the user provides consent on a trusted device, such as their mobile phone, separate from the device where the agent was initially engaged.

<Frame>
  <iframe title="Asynchronous authorization with Auth0 for AI Agents" />
</Frame>

## Use cases for asynchronous authorization

AI agents often need to perform actions that are long-running, are executed at a later time, or involve sensitive operations. For example:

* **Transactional approvals:** An agent arranging a business trip might find a flight and hotel, but needs the user's final approval to complete the purchase.
* **Accessing sensitive data:** An agent might need to access a protected user's health records to answer a query.
* **Executing high-privilege tasks:** A DevOps agent might need permission to deploy a new version of an application to a production environment.

In these scenarios, the agent needs the user to approve an action at a later time. Asynchronous authorization allows the agent to initiate this request and let the user approve it at their convenience, creating a more seamless and secure user experience.

This decoupled mechanism is also ideal for human-in-the-loop interactions, such as approving a stock purchase through a chatbot or completing a financial transaction with a banking agent.

## Client-Initiated Backchannel Authentication and Rich Authorization Requests

Auth0 implements asynchronous authorization using the **Client-Initiated Backchannel Authentication (CIBA)** standard, enhanced with **Rich Authorization Requests (RAR)**.

* [**CIBA**](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html) is an OpenID Foundation specification that defines a decoupled flow where a client application (the AI agent's backend, for example) can initiate an authentication request without direct interaction from the user on the same device. The user then approves or denies the request on a separate, trusted authentication device (like a mobile phone), typically via a push notification to an authenticator app or via SMS or email.
* [**RAR**](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-rar) is an OAuth 2.0 extension that allows client applications to request more complex permissions beyond standard OAuth 2.0 scopes in an authorization request. It allows the agent to send a detailed, structured payload describing the exact transaction. This provides the user with specific, verifiable context such as “Approve payment of \$50.00 to ExampleCorp”, instead of a generic prompt, which is critical for establishing user trust and security. Using RAR is optional for a CIBA flow.

The flow generally proceeds as follows:

<Steps>
  <Step title="Initiation">
    The agent's backend identifies a need for user approval and sends a CIBA
    request to the Auth0 `/bc-authorize` endpoint. This request includes a user
    identifier and the optional RAR payload in the (`authorization_details`)
    parameter.
  </Step>

  <Step title="Acknowledgment">
    Auth0 immediately acknowledges the request by returning a unique
    `auth_req_id`.
  </Step>

  <Step title="Polling">
    The agent's backend uses `auth_req_id` to begin polling the Auth0 `/token`
    endpoint to check for completion.
  </Step>

  <Step title="User consent">
    In parallel, Auth0 sends a notification (e.g., push, SMS, or email) to the
    user's authentication device, displaying the rich context from the RAR
    payload. The user approves or denies the request.
  </Step>

  <Step title="Token issuance">
    Once the user approves, the next polling request from the agent's backend to
    the `/token` endpoint will succeed. Auth0 returns the required access and ID
    tokens, allowing the agent to complete the authorized action.
  </Step>
</Steps>

## User consent and notification channel selection

When Auth0 receives a backchannel request, it must decide which notification channel to use when requesting user approval. These are the currently available options (in order of preference):

1. **Auth0 Guardian mobile push notification**: Sends a mobile push notification to the user's enrolled mobile device. Authentication and authorization happen in the device that received the notification.
2. **Email**: Sends an email to the user's verified address. The email contains a link and, when clicked, authentication & authorization happen in the browser.

By default, Auth0 uses and recommends Guardian push notifications for CIBA flows. Guardian push notifications are more secure than other channels, such as email, which can be vulnerable to phishing attacks. You have to explicitly enable email notifications for CIBA flows.

<Note>
  **Email:** Email notifications for asynchronous authorization is a paid add-on feature, and is now available for all Essentials, Professional, and Enterprise plans. Please see our [pricing](https://auth0.com/pricing) page for more details.
</Note>

The notification channel Auth0 uses may also be influenced by the following factors:

* The **Auth0 client's notification channel**: within the Auth0 application details screen, you can enable or disable notification channels for asynchronous authorization requests. These will configure the client's `async_approval_notification_channels` array setting. Currently available options are `guardian-push` and `email`.
* **Requested expiry**: when the agent's backend specifies a *requested expiry* greater than five minutes, MFA Push notification becomes a non-eligible option.
* **MFA configuration at the tenant level**: To enable the MFA push notification channel for a client application, you must configure MFA push notifications for the tenant. To learn more about configuring your tenant to use Auth0 Guardian with push notifications, read [Enroll in push notifications](https://auth0.com/docs/secure/multi-factor-authentication/auth0-guardian#enroll-in-push-notifications). ***Note***: Only the Auth0 Guardian push factor is supported at this time.
* **User's enrolled authenticators**: if the user is not enrolled to use an MFA push authenticator, Auth0 falls back to email, if configured, instead of rejecting the CIBA request.
* **User's email verification status**: if the user's email is not verified, Auth0 rejects the CIBA request.

You can read more about the notification channel selection in the [Configure Client-Initiated Backchannel Authentication](https://auth0.com/docs/get-started/applications/configure-client-initiated-backchannel-authentication) documentation.

## Get started

To begin using Asynchronous Authorization in your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Asynchronous Authorization" href="/get-started/asynchronous-authorization" icon="key" />
</Columns>

### Guides

<Columns>
  <Card title="Configure Rich Authorization Requests (RAR)" href="https://auth0.com/docs/get-started/apis/configure-rich-authorization-requests" icon="gear" />
</Columns>

### Sample Apps

<Columns>
  <Card
    title="Assistant0: Next.js + Vercel AI SDK"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/vercel.svg"
    alt="Vercel AI"
  />
}
  />

  <Card
    title="Assistant0: Next.js + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: FastAPI + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: Next.js + LlamaIndex"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
  />

  <Card title="Auth0 AI SDK TypeScript samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples/async-authorization" icon="code" />

  <Card title="Auth0 AI SDK Python samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples/async-authorization" icon="python" />
</Columns>

### Learn more

<Columns>
  <Card title="Client-Initiated Backchannel Authentication Flow" href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow" icon="gear" />

  <Card title="User Authorization with CIBA" href="https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow/user-authorization-with-ciba" icon="gear" />
</Columns>


# Authorization for RAG
Source: https://auth0.com/ai/docs/intro/authorization-for-rag

Authorization for Retrieval-Augmented Generation (RAG) ensures that when an AI agent retrieves and uses your company's internal data to answer user questions, it only accesses information that the specific user is permitted to see. This prevents the AI model from inadvertently [exposing sensitive or confidential data](https://genai.owasp.org/llmrisk/llm022025-sensitive-information-disclosure/) to unauthorized individuals.

<Frame>
  <iframe title="Authorization for RAG using Auth0 FGA" />
</Frame>

## The challenge: Securing data in RAG pipelines

Retrieval-Augmented Generation (RAG) is a powerful technique that enhances Large Language Models (LLMs) by providing them with relevant, up-to-date information from external data sources, such as a company's internal knowledge base or document repository.

However, without proper access controls, a RAG pipeline could retrieve documents containing sensitive information (e.g., financial reports, HR documents, strategic plans) and use them to generate a response for a user who should not have access to that data. This could lead to serious data breaches and compliance violations. Simply filtering based on user roles is often insufficient for managing the complex, relationship-based permissions found in real-world applications.

## The solution: Auth0 Fine-Grained Authorization (FGA)

To solve this challenge, Auth0 for AI Agents uses [**Auth0 Fine-Grained Authorization (FGA)**](https://auth0.com/fine-grained-authorization). Auth0 FGA is a flexible, high-performance authorization service for applications that require a sophisticated permissions system. It implements Relationship-Based Access Control (ReBAC) to manage permissions at large-scale. Auth0 FGA is built on top of [OpenFGA](https://openfga.dev/), created by Auth0, which is a [CNCF](https://cncf.io/) sandbox project.

Auth0 FGA allows you to decouple your authorization logic from your application code. Instead of embedding complex permission rules directly into your application, you define an authorization model and store relationship data in Auth0 FGA. Your application can then query Auth0 FGA at runtime to make real-time access decisions.

### How it works with RAG

Integrating Auth0 FGA into your RAG pipeline ensures that every document is checked against the user's permissions before it's passed to the LLM.

<Frame>
  <img alt="Authorization for RAG" />

  <img alt="Authorization for RAG" />
</Frame>

The process works as follows:

<Steps>
  <Step title="Authorization model">
    First, you define your authorization model in Auth0 FGA. This model
    specifies the types of objects (e.g., `document`), the possible
    relationships between users and objects (e.g., `owner`, `editor`, `viewer`),
    and the rules that govern access.
  </Step>

  <Step title="Store relationships">
    You store permissions as 'tuples' in Auth0 FGA. A tuple is the core data
    element, representing a specific relationship in the format of `(user,
            relation, object)`. For example, `user:anne` is a `viewer` of
    `document:2024-financials`.
  </Step>

  <Step title="Fetch and filter">
    When a user submits a query to your AI agent, your backend first
    fetches relevant documents from a vector database and then makes a
    permission check call to Auth0 FGA. This call asks, "Is this user allowed to
    view these documents?". Our AI framework SDKs abstract this and make it as
    easy as plugging in a filter in your retriever tool.
  </Step>

  <Step title="Secure retrieval">
    Auth0 FGA determines if the user is authorized to access the documents. Your
    application backend uses this data to filter the results from the vector
    database and only sends the authorized documents to the LLM.
  </Step>
</Steps>

## Get started

To begin using Auth0 FGA in your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Authorization for RAG" href="/get-started/authorization-for-rag" icon="key" />

  <Card title="Auth0 FGA Getting Started" href="https://docs.fga.dev/getting-started" icon="gear" />
</Columns>

### Sample Apps

<Columns>
  <Card
    title="Assistant0: Next.js + Vercel AI SDK"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/vercel.svg"
    alt="Vercel AI"
  />
}
  />

  <Card
    title="Assistant0: Next.js + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: FastAPI + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: Next.js + LlamaIndex"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
  />

  <Card title="SmartHR Assistant: Next.js + LangChain" href="https://github.com/auth0-samples/auth0-ai-smart-hr-assistant" icon="github" />

  <Card title="AI Samples: Multiple frameworks" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/authorization-for-rag" icon="github" />

  <Card title="Auth0 AI SDK TypeScript samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples/authorization-for-rag" icon="code" />

  <Card title="Auth0 AI SDK Python samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples/authorization-for-rag" icon="python" />
</Columns>

### Learn more

<Columns>
  <Card title="Auth0 FGA Documentation" href="https://docs.fga.dev/" icon="gear" />

  <Card title="OpenFGA Documentation" href="https://openfga.dev/" icon="book" />
</Columns>


# Call Other's APIs on User's Behalf
Source: https://auth0.com/ai/docs/intro/call-others-apis-on-users-behalf

[Token Vault](/intro/token-vault) lets your AI agent call external APIs on the user's behalf. We provide SDKs for Python, JavaScript, and popular AI frameworks like LangChain, LlamaIndex, Genkit, and Vercel AI, making it easy and straightforward to get access tokens for external applications.

## Applications with refresh tokens

In a typical scenario, a user interacts with a frontend application (e.g., a chatbot interface). This frontend communicates with a secure backend service, often a Backend for Frontend (BFF) or an agent, which is responsible for calling the external API. Such applications can use refresh tokens for long-lived sessions and use the same refresh tokens to securely call external APIs on the user's behalf via Token Vault.

<Frame>
  <img alt="Token Vault using Refresh Tokens" />

  <img alt="Token Vault using Refresh Tokens" />
</Frame>

By modeling your agent's backend as a secure application, it can obtain the necessary tokens from Token Vault to interact with external APIs while maintaining the user's context and permissions.

## Applications without refresh tokens

In scenarios where refresh tokens cannot be used, such as single-page applications (SPAs) or headless agents and CLIs, you can still call external APIs on the user's behalf via Token Vault using Auth0 access tokens. To do so, use the Auth0 Dashboard to configure the following:

* [An API in Auth0](https://auth0.com/docs/get-started/auth0-overview/set-up-apis): You need to register an API in the Auth0 Dashboard with the appropriate settings.
* A Custom API Client in Auth0: The Custom API Client allows your API server to perform token exchanges using access tokens instead of refresh tokens. This client enables Token Vault to exchange an access token for an external API access token (e.g., Google Calendar API).

<Frame>
  <img alt="Token Vault using Access Tokens" />

  <img alt="Token Vault using Access Tokens" />
</Frame>

Check out this [guide](/get-started/call-others-apis-on-users-behalf#vercel-ai-%2B-react-spa) for an example.

## Get started

To begin using Auth0 Token Vault with your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Call Other's APIs on User's Behalf" href="/get-started/call-others-apis-on-users-behalf" icon="key" />
</Columns>

### Guides

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="calendar" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />

  <Card title="Get Salesforce Opportunities" href="/how-tos/get-salesforce-opportunities" icon="salesforce" />
</Columns>

### Sample Apps

<Columns>
  <Card
    title="Assistant0: Next.js + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: Next.js + Vercel AI SDK"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/vercel.svg"
    alt="Vercel AI"
  />
}
  />

  <Card
    title="Assistant0: FastAPI + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: Next.js + LlamaIndex"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
  />

  <Card title="Auth0 AI SDK TypeScript samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples/calling-apis" icon="github" />

  <Card title="Auth0 AI SDK Python samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples/calling-apis" icon="github" />
</Columns>

### Learn more

<Columns>
  <Card title="Configure Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault" icon="gear" />

  <Card title="Refresh Token Exchange with Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/refresh-token-exchange-with-token-vault" icon="key" />

  <Card title="Access Token Exchange with Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/access-token-exchange-with-token-vault" icon="key" />
</Columns>


# Call Your APIs on User's Behalf
Source: https://auth0.com/ai/docs/intro/call-your-apis-on-users-behalf

Once Auth0 is set up for User Authentication, you can enable your AI applications and AI agents to securely call your own APIs (first-party APIs) on behalf of authenticated users. This capability allows AI agents to access user-specific data or perform actions with explicit user consent and scope.

## Delegated authorization

The process relies on **delegated authorization**, where the user grants your AI application or AI agent permission to access protected resources without sharing their credentials directly. This is achieved through **access tokens:**. After a user authenticates, Auth0 issues an access token to your AI application. This token represents the user's consent and defines the scope of permissions granted.

<Frame>
  <img alt="Authorization Flow" />

  <img alt="Authorization Flow" />
</Frame>

### API on Auth0

An API is an entity that represents an external resource, capable of accepting and responding to protected resource requests made by applications. These APIs are configured to accept and validate access tokens. To protect an API, it must be [registered as an API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) using the Auth0 Dashboard.

### How it works for AI apps and agents

<Steps>
  <Step title="User authentication">
    A user logs into your AI application or agent interface (e.g., via Universal
    Login).
  </Step>

  <Step title="Access token issuance">
    Upon successful authentication, an access token is issued to your
    application.
  </Step>

  <Step title="AI agent makes a tool call">
    When the AI agent needs to access user-specific data or perform an action,
    it makes a tool call to an API endpoint.
  </Step>

  <Step title="Token forwarding">
    The access token obtained in step 2 is included in the API request
    (typically in the `Authorization` header).
  </Step>

  <Step title="API validation & response">
    The API validates the access token. If valid, it processes the request on
    behalf of the user and returns the response to the AI agent.
  </Step>

  <Step title="AI agent receives and processes the information">
    The AI agent then uses this response to fulfill the user's request.
  </Step>
</Steps>

## Get started

To begin Calling your APIs with your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Call Your APIs On User's Behalf" icon="key" href="/get-started/call-your-apis-on-users-behalf" />
</Columns>

### Sample Apps

<Columns>
  <Card title="Fullstack (Next.js, FastAPI)" icon="github" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/call-apis-on-users-behalf/your-api" />

  <Card title="Agent0 (React + Fastify + Vercel AI SDK)" icon="github" href="https://github.com/auth0-samples/agent0" />

  <Card title="Assistant0 (Next.js, FastAPI)" href="https://github.com/auth0-samples/auth0-assistant0" icon="github" />
</Columns>

### Learn more

<Columns>
  <Card title="Auth0 Docs for APIs" icon="book" href="https://auth0.com/docs/get-started/apis" />
</Columns>


# Integrations
Source: https://auth0.com/ai/docs/intro/integrations

An integration, or Auth0 Connection, is a relationship between Auth0 and a source of users, such as third-party applications (like Slack or Salesforce) or external Identity Providers (like Google or Microsoft).

These Connections allow users to log in to your application using those identities (such as log in with Google), and share their data from that application to your application. Auth0 standardizes the authentication process from various sources to simplify the integration of different identity providers.

For AI agents that utilize Token Vault, Connections are essential. They allow your AI agents to securely access external APIs, such as Google Calendar or Microsoft 365, on behalf of the user. This is achieved by the user granting your application consent to access their data through these Connections.

<Frame>
  <img alt="App Connections" />

  <img alt="App Connections" />
</Frame>

Within the Auth0 Dashboard, Connections are grouped into two categories: Social Connections allow users to log in to your application using their credentials from popular social media and consumer platforms. This provides a frictionless login experience and can enrich user profiles with additional information.

Enterprise Connections are used to authenticate users against a federated corporate directory or identity provider. This is crucial for B2B applications where users need to log in with their company credentials or use single sign-on (SSO).

## Supported Connections

Auth0 provides a large number of Connection types for use with your AI Agents, including:

* [Google](/integrations/google) and [Google Workspace](/integrations/google-workspace)
* [Microsoft](/integrations/microsoft) and [Microsoft Azure AD](/integrations/microsoft-azure)
* [GitHub](/integrations/github)
* [Slack](/integrations/slack)
* [OpenID Connect (OIDC)](/integrations/oidc)
* [Custom Social Connections](/integrations/oauth2)

<Card title="View All Integrations" href="/integrations/overview" icon="share-nodes" />

## Configuring Connections for Token Vault

To enable your AI agents to call APIs on a user’s behalf, you will need to:

<Steps>
  <Step title="Obtain client credentials">
    To enable your application to call APIs on a user’s behalf, you will need to
    obtain the **Client ID** and **Client Secret** from the Connection you want
    to use.
  </Step>

  <Step title="Create and configure the Connection">
    In the Auth0 Dashboard, navigate to **Authentication** and select the
    desired **Social** or **Enterprise** Connection type, and configure using
    the obtained **Client ID** and **Client Secret**.
  </Step>

  <Step title="Request the necessary scopes">
    When configuring the Connection, you need to specify the default scopes
    (permissions) your application requires to access the user's data from the
    third-party API.<br /><br />Make sure to select the following scopes in the Auth0 Dashboard:

    <ul>
      <li>**User Profile**: Requests basic profile information. Exact name depends on the connection.</li>
      <li>**Offline Access**: Requests an Auth0 refresh token. Exact name depends on the connection.</li>
    </ul>
  </Step>

  <Step title="Enable Connected Accounts for Token Vault for the Connection">
    In the **Purpose** section, toggle on
    **Use for Connected Accounts for Token Vault** and save the Connection. To learn more, read [Connected Accounts for Token Vault](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault).
  </Step>

  <Step title="Enable the Connection for your application">
    Ensure that the newly configured Connection is enabled for the Auth0
    application that represents your AI agent under **Applications** >
    **Applications** > **\[your Auth0 app]** > **Connections.**
  </Step>
</Steps>

## Get started

To begin using Auth0 Token Vault with your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Call Other's APIs on User's Behalf" href="/get-started/call-others-apis-on-users-behalf" icon="key" />
</Columns>

### Guides

<Columns>
  <Card title="Configure Google Social Connection" href="/integrations/google" icon="google" />
</Columns>

### Learn more

<Columns>
  <Card title="Social Identity Providers" href="https://auth0.com/docs/authenticate/identity-providers/social-identity-providers" icon="user" />

  <Card title="Enterprise Identity Providers" href="https://auth0.com/docs/authenticate/identity-providers/enterprise-identity-providers" icon="user" />

  <Card title="Configure Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault" icon="gear" />

  <Card title="Auth0 Marketplace for Social Connections" href="https://marketplace.auth0.com/features/social-connections" icon="users" />
</Columns>


# Auth0 for AI Agents
Source: https://auth0.com/ai/docs/intro/overview

Secure your AI agents with robust user authentication, secure API access, human-in-the-loop controls, and fine-grained authorization.

<Card title="Secure your AI Agents with robust user authentication, secure API access, human-in-the-loop controls, and fine-grained authorization for your data." icon="sparkles" />

<Frame>
  <img alt="Universal login screen" />
</Frame>

### User authentication

Securely authenticate users in your AI agents using Auth0's [Universal Login](https://auth0.com/docs/authenticate/login/auth0-universal-login) with support for social, enterprise, and custom identity providers. This allows you to leverage robust standards like OAuth 2.0 and OpenID Connect to secure both interactive and headless AI agents. [Learn More](./user-authentication).

### Call your APIs on a user's behalf

Enable AI agents to securely call your application's own APIs (first-party APIs) on behalf of a user using OAuth 2.0. This pattern ensures that the user's context is maintained, preventing agents from having broad, unrestricted access to all user data. [Learn More](./call-your-apis-on-users-behalf).

### Call other's APIs on a user's behalf using Token Vault

Securely connect AI agents to external tools and services like Google, Slack, or GitHub. Our Token Vault feature manages the complexities of obtaining, storing, and refreshing API tokens, allowing your agents to interact with third-party APIs without handling sensitive credentials or API keys directly. [Learn More](./token-vault).

### Asynchronous authorization

Implement "human-in-the-loop" workflows for actions that are long-running or require user consent. Using standards like [CIBA (Client-Initiated Backchannel Authentication)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow), agents can request approval for sensitive operations via push notifications, SMS, or email, even when the user is not actively using the application. [Learn More](./asynchronous-authorization).

### Authorization for RAG

Enforce fine-grained, document-level access control within your Retrieval Augmented Generation (RAG) pipelines using [Auth0 FGA](https://auth0.com/fine-grained-authorization). This ensures that when a Large Language Model (LLM) generates a response, it only uses data that the current user is authorized to see, preventing [sensitive data leakage](https://genai.owasp.org/llmrisk/llm022025-sensitive-information-disclosure/) and ensuring compliance. [Learn More](./authorization-for-rag).

## Get started

Follow our [quickstart guides](/get-started/overview) for a step-by-step tutorial on implementing authentication and authorization in your AI agents.

## Sample applications

Explore our sample applications and templates

<Columns>
  <Card href="https://github.com/auth0-samples/auth0-assistant0" title="Assistant0">
    A fullstack AI personal assistant with pre-configured tools that
    demonstrates different Auth0 for AI Agents features like User Authentication,
    calling APIs (Gmail, Google Calendar, etc.) securely using Token Vault,
    Human-in-the-loop interactions using Asynchronous Authorization, and using
    Auth0 FGA for securing RAG tools.

    `NEXT.JS` `FASTAPI` `VERCEL AI` `LANGCHAIN` `LLAMAINDEX`
  </Card>

  <Card title="SmartHR Assistant" href="https://github.com/auth0-samples/auth0-ai-smart-hr-assistant">
    An AI HR assistant that provides secure access to HR documents based on
    complex authorization rules. This demonstrates the use of Auth0 FGA to
    secure RAG applications with relationship-based access control (Fine-Grained
    Authorization).

    `NEXT.JS` `LLAMAINDEX`
  </Card>

  <Card href="https://github.com/auth0-samples/auth0-ai-samples" title="AI Samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.

    `LANGCHAIN` `FASTAPI` `VERCEL AI` `LLAMAINDEX`
  </Card>
</Columns>

## Frameworks & SDKs

Explore samples and SDKs for the different frameworks supported by Auth0 for AI Agents.

<Columns>
  <Card href="/sdks/javascript-sdk" icon="js" title="JavaScript" />

  <Card href="/sdks/python-sdk" icon="python" title="Python" />

  <Card
    href="/sdks/langchain-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
    title="LangChain"
  />

  <Card
    href="/sdks/llamaindex-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
    title="LlamaIndex"
  />

  <Card
    href="/sdks/vercel-ai-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/vercel.svg"
    alt="Vercel AI"
  />
}
    title="Vercel AI"
  />

  <Card
    href="/sdks/cloudflare-sdk"
    title="Cloudflare"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/cloudflare.svg"
    alt="Cloudflare"
    height={48}
    width={48}
  />
}
  />

  <Card
    href="/sdks/genkit-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/genkit.svg"
    alt="Genkit"
  />
}
    title="Genkit"
  />
</Columns>


# Calling APIs with Token Vault
Source: https://auth0.com/ai/docs/intro/token-vault

AI agents can use Token Vault to connect accounts and access external APIs to fulfill user requests.

For example, a sales assistant AI agent might need to:

* Read a user's calendar to schedule a meeting.
* Access a user's documents to summarize them.
* Connect to a CRM like Salesforce to retrieve customer information.

You can securely access external APIs on the user's behalf using Auth0's **Token Vault**. Once an AI agent has authenticated a user with a supported external provider, the user is prompted to authorize the connection and connect their external account. With the user's consent, the AI agent can initiate a [Connect Account flow](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault#how-it-works), linking the user profile to external services like Google, GitHub, Slack, and more.

Once the external account has been successfully connected, the AI agent can fetch the stored credentials in Token Vault to access external APIs on the user's behalf. For example, the user can provide consent for your AI agent to access their Google Calendar to view their schedule or set up meetings, or their Salesforce account to retrieve customer information.

<Frame>
  <iframe title="Calling APIs with Token Vault" />
</Frame>

## What is Connected Accounts for Token Vault

[Connected Accounts for Token Vault](https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault) creates and manages a unified Auth0 user profile linked to multiple external accounts, enabling seamless authorization. Your application then fetches the stored credentials in Token Vault to interact with external APIs on the user’s behalf.

Once a user successfully connects and authorizes access to a supported external provider, Auth0:

* Associates the account with the user as a connected account.
* Stores the external provider’s access and refresh tokens for the connected account in the Token Vault.

The AI Agent then fetches the stored credentials in Token Vault to interact with external APIs on the user’s behalf.

## What is Token Vault

Auth0's Token Vault is a secure service for storing and managing tokens for external services. Your AI agents can use the access tokens from Token Vault to call external APIs on behalf of your users. This capability is essential for building trustworthy AI agents that can securely interact with services from external providers, such as Google, Microsoft, Salesforce, or any other API provider that uses OAuth 2.0.

Token Vault is built on top of [OAuth 2.0 Token Exchange (RFC 8693)](https://www.rfc-editor.org/rfc/rfc8693.html) and supports social and enterprise connections to other Identity Providers (IdPs). There is no need to manage refresh tokens or build custom integrations per provider because Auth0 handles it all for you. You gain access to a wide range of external providers' APIs and services, all through a single Auth0 integration.

### Why Is Calling APIs with Token Vault Important for AI agents

Hardcoding API keys or asking users to constantly re-authenticate with these external services is insecure and provides a poor user experience. Token Vault solves this by providing a secure mechanism to store and use the user's credentials (in the form of tokens) for these services.

By using Token Vault, you can:

* **Securely store and manage tokens**: Offload the complexity and risk of storing sensitive user credentials.
* **Maintain user context**: Enable agents to act on behalf of a specific user, ensuring that the agent only has the permissions that the user has granted.
* **Provide a seamless user experience**: Avoid repeatedly prompting users for authentication with external services.
* **Enhance security**: Prevent the exposure of tokens to the frontend or to the end-user.

## How it works

The process of using Token Vault involves the following key steps:

1. **User authentication and consent:** The AI agent triggers the Connected Accounts flow, which redirects the user to authenticate with an external Identity Provider (e.g., Google. The user then grants your application permission to access their data by approving the requested OAuth scopes.  Upon completion, the external account is added to the user profile.
2. **Secure token storage:** Auth0 receives access and refresh tokens from the external provider and stores them securely within Token Vault.
3. **Token exchange:** Your application can then exchange a valid Auth0 refresh token or access token for an external provider's access token from Token Vault. This allows your application to obtain the necessary credentials to call external APIs without the user having to re-authenticate. It also means your application does not need to store or manage any credentials.
4. **API call:** With the external provider's access token, your AI agent can make authorized calls to the external API on the user's behalf.

## Supported integrations

Token Vault supports a variety of social and enterprise identity providers, including:

* [Google](/integrations/google) and [Google Workspace](/integrations/google-workspace)
* [Microsoft](/integrations/microsoft) and [Microsoft Azure AD](/integrations/microsoft-azure)
* [GitHub](/integrations/github)
* [Slack](/integrations/slack)
* [OpenID Connect (OIDC)](/integrations/oidc)
* [Custom Social Connections](/integrations/oauth2)
* [...and more!](/integrations/overview)

<Card title="View All Integrations" href="/integrations/overview" icon="share-nodes" />

## Using Token Vault

To begin using Token Vault to call external APIs on behalf of your users, you will need to:

<Columns>
  <Card title="Configure connections" href="/intro/integrations" icon="square-1">
    Set up connections to the external service (e.g., Google, Microsoft) in your
    Auth0 Dashboard.
  </Card>

  <Card title="Configure Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault" icon="square-2">
    Configure Token Vault to enable AI agents to securely store and retrieve tokens from the Token Vault.
  </Card>

  <Card title="Call other's APIs on user's behalf" href="/intro/call-others-apis-on-users-behalf" icon="square-3">
    Use our SDKs for your preferred frameworks to easily obtain access tokens
    for the connections.
  </Card>
</Columns>

By leveraging Auth0's Token Vault, you can build powerful and trustworthy AI agents that securely and seamlessly integrate with the broader ecosystem of APIs and services.

## Get started

To begin using Auth0 Token Vault with your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Call Other's APIs on User's Behalf" href="/get-started/call-others-apis-on-users-behalf" icon="key" />
</Columns>

### Guides

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />

  <Card title="Get Salesforce Opportunities" href="/how-tos/get-salesforce-opportunities" icon="salesforce" />
</Columns>

### Sample Apps

<Columns>
  <Card
    title="Assistant0: Next.js + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="Vercel AI"
  />
}
  />

  <Card
    title="Assistant0: FastAPI + LangGraph"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
  />

  <Card
    title="Assistant0: Next.js + Vercel AI SDK"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/vercel.svg"
    alt="Vercel AI"
  />
}
  />

  <Card
    title="Assistant0: Next.js + LlamaIndex"
    href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
  />

  <Card title="Auth0 AI SDK TypeScript samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples/calling-apis" icon="github" />

  <Card title="Auth0 AI SDK Python samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples/calling-apis" icon="python" />
</Columns>

### Learn more

<Columns>
  <Card title="Configure Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/configure-token-vault" icon="gear" />

  <Card title="Connected Accounts for Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/connected-accounts-for-token-vault" icon="key" />

  <Card title="Refresh Token Exchange with Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/refresh-token-exchange-with-token-vault" icon="key" />

  <Card title="Access Token Exchange with Token Vault" href="https://auth0.com/docs/secure/tokens/token-vault/access-token-exchange-with-token-vault" icon="key" />
</Columns>


# User Authentication for AI agents
Source: https://auth0.com/ai/docs/intro/user-authentication

Robust user authentication for AI agents. It ensures security, protects data, and controls access to features.

<Frame>
  <iframe title="User authentication for AI agents using Auth0" />
</Frame>

## Why authentication matters for AI agents

* **Secure and controlled access:** Safeguards user data, manages who can use your AI agents and what they can do, and establishes a clear audit trail for both user and AI agent activities.
* **Agent identity & delegation:** Establishes an AI agent's identity and its authorization to act on behalf of a user.
* **Auditability:** Provides a record of user activities for auditing and compliance.
* **Personalization:** Enables tailored AI experiences by maintaining user preferences and conversational history.

## Authentication for users of AI agents

Auth0 is a flexible, drop-in solution to add authentication and authorization services to your applications. With Auth0, your users can log in with:

* Username and password
* [Passwordless and Passkeys](https://auth0.com/docs/authenticate/passwordless)
* [Social Login (Google, Meta, Microsoft, GitHub, etc.)](https://auth0.com/docs/authenticate/passwordless#social-login)
* [Corporate credentials and Single Sign On (SSO)](https://auth0.com/docs/authenticate/single-sign-on) for B2B AI applications
* And more.

<Frame>
  <img alt="Auth0 Authentication Flow" />

  <img alt="Auth0 Authentication Flow" />
</Frame>

Auth0 also provides the following features for enhanced security and scalability:

* [Multi-factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication)
* [Attack Protection](https://auth0.com/docs/secure/attack-protection): Detect attacks and stop malicious attempts to access your application, such as blocking traffic from certain IPs and displaying CAPTCHA. This includes Bot Detection, Suspicious IP Throttling, Brute Force Protection, and Breached Password Detection.
* [Highly Regulated Identity](https://auth0.com/docs/secure/highly-regulated-identity)
* UI and login flow customizations via [Actions](https://auth0.com/docs/customize/actions) and [Forms](https://auth0.com/docs/customize/forms)

## User login flows for AI agents

Choosing a login flow impacts security and user experience. Auth0 offers two ways to implement login authentication for your applications.

1. [**Universal Login (Recommended)**](https://auth0.com/docs/authenticate/login/auth0-universal-login)**:** Users are redirected to a secure, hosted login page provided by Auth0.
   * **Enhanced security:** Your AI application never handles user credentials directly.
   * **Reduced development:** Simplifies implementation of secure login, password policies, and MFA.
   * **Centralized identity:** Manages user profiles and integrates various identity providers efficiently.
   * **Advanced customizations**: Allows you to build custom, client-rendered versions of Universal Login screens, giving you control over every pixel of your Universal Login experience.
   * **Use case:** Ideal for most AI agents requiring secure, frictionless user access.

<Frame>
  <img alt="Universal login screen" />
</Frame>

2. [**Embedded Login**](https://auth0.com/docs/authenticate/login/embedded-login)**:** The login interface is integrated directly within your AI application's UI.
   * **Additional UI control:** Allows for highly customized branding.
   * **Increased responsibility:** Requires your team to manage sensitive data inputs and secure communication within your app.
   * **Complexity:** More challenging to implement and maintain advanced features.
   * **Use Case:** Suitable for highly specialized internal AI tools in tightly controlled environments.

## Authentication for AI agents and API access

With Auth0, it is possible to extend authentication to AI agents accessing services on their own:

* **Machine-to-Machine authentication:** For AI agents or backend services, use secure **OAuth 2.0 Client Credentials Flow** with **Client Secret**, **mutual TLS (mTLS)**, or **Private Key JWT** to authenticate directly with AI service APIs.
* **Delegated authorization:** When an AI agent acts on behalf of a human, the **[Client-Initiated Backchannel Authentication (CIBA)](https://auth0.com/docs/get-started/authentication-and-authorization-flow/client-initiated-backchannel-authentication-flow/user-authentication-with-ciba)** and **[Device Authorization](https://auth0.com/docs/get-started/authentication-and-authorization-flow/device-authorization-flow)** flow allow the user to grant specific permissions to the agent without sharing their credentials.

## Call your APIs on a user's behalf

You can use Auth0 to authorize calls to your own APIs on behalf of logged-in users. The Auth0 SDKs make this easy. [Learn more](/intro/call-your-apis-on-users-behalf).

## Get started

To begin using Auth0 authentication in your AI agents, refer to the following resources:

### Quickstarts

<Columns>
  <Card href="/get-started/user-authentication#next-js" title="User Authentication for Next.js" icon="js" />

  <Card href="/get-started/user-authentication#fastapi" title="User Authentication for FastAPI" icon="python" />

  <Card href="https://auth0.com/docs/quickstarts" title="Other official quickstarts" icon="rocket-launch" />
</Columns>

### Sample Apps

<Columns>
  <Card title="Fullstack (Next.js, FastAPI)" icon="github" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/authenticate-users" />

  <Card title="Agent0 (React + Fastify + Vercel AI SDK)" icon="github" href="https://github.com/auth0-samples/agent0" />

  <Card title="Assistant0 (Next.js, FastAPI)" href="https://github.com/auth0-samples/auth0-assistant0" icon="github" />
</Columns>

### Learn more

<Columns>
  <Card title="Auth0 Docs" icon="book" href="https://auth0.com/docs/articles" />

  <Card title="Authentication API" icon="key" href="https://auth0.com/docs/api/authentication" />

  <Card title="SDKs" icon="code" href="https://auth0.com/docs/libraries" />
</Columns>


# Authorization for Your MCP Server
Source: https://auth0.com/ai/docs/mcp/get-started/authorization-for-your-mcp-server

Learn how to protect your MCP server by requiring access tokens from authorized clients.

Authorization controls access to your MCP server so that only trusted clients can use its resources. In this quickstart, you'll learn how to secure your MCP server by requiring and validating client access tokens.

When an MCP client makes a request on behalf of a user, it must include a valid access token issued by Auth0. Your MCP server verifies this token and determines which tools and resources the client can access based on the user's permissions.

By the end of this quickstart, you will have an MCP server that:

* Requires access tokens for all incoming requests
* Validates OAuth 2.0 access tokens from authorized clients
* Enforces role-based access control to manage tool permissions

## Prerequisites

<Note>
  Auth for MCP is currently available in Early Access. To join the Early Access program, please complete [this form](https://forms.gle/hvJ1ZRLmHr9YjV2a9). We'll reach out to you when your request is processed.
</Note>

<AccordionGroup>
  <Accordion title="1. Create or log in to your Auth0 account">
    To continue with this quickstart, you need to have an [Auth0 account](https://auth0.com/signup).
  </Accordion>

  <Accordion title="2. Enable your tenant to use the Resource Parameter Compatibility Profile">
    To use the `resource` parameter in your access tokens, you need to enable the compatibility profile.

    The quickest way to enable it is through the [Auth0 Dashboard](https://manage.auth0.com/dashboard/):

    1. Navigate to **Settings** on the left sidebar.
    2. Click on [**Advanced**](https://manage.auth0.com/dashboard/#/tenant/advanced) in the top right corner.
    3. Scroll down to the Settings section, find and enable the **Resource Parameter Compatibility Profile** toggle.
  </Accordion>

  <Accordion title="3. Install the Auth0 CLI">
    This guide uses [Auth0 CLI](https://auth0.github.io/auth0-cli/) to configure an Auth0 tenant for secure MCP tool access.

    1. Follow the [Auth0 CLI installation instructions](https://auth0.github.io/auth0-cli/).
    2. Log in to your account with the Auth0 CLI:

    ```shell wrap lines theme={null}
    auth0 login --scopes "read:client_grants,create:client_grants,delete:client_grants,read:clients,create:clients,update:clients,read:resource_servers,create:resource_servers,update:resource_servers,read:roles,create:roles,update:roles,update:tenant_settings,read:connections,update:connections"
    ```

    Confirm you are in the correct tenant by double-checking the tenant domain in the terminal, or run the command below:

    ```shell theme={null}
    auth0 tenants list
    ```

    If more than one tenant is configured, the default tenant will be indicated by an arrow.
  </Accordion>

  <Accordion title="4. Install jq">
    To simplify the process of interacting with the Auth0 CLI, we recommend installing [jq](https://jqlang.org/download/). This will allow you to easily parse JSON responses from the CLI.

    <Tabs>
      <Tab title="macOS">
        <CodeBlock>brew install jq</CodeBlock>
      </Tab>

      <Tab title="Linux">
        <CodeBlock>sudo apt-get install jq</CodeBlock>
      </Tab>

      <Tab title="Windows">
        <CodeBlock>choco install jq</CodeBlock>
      </Tab>
    </Tabs>
  </Accordion>
</AccordionGroup>

## Configure tenant settings

<AccordionGroup>
  <Accordion title="1. Promote the connection to a domain-level connection">
    To allow third-party clients like MCP Inspector to use a connection such as a username-and-password database or a social connection, you need to promote the connection to a domain-level connection. [Learn more about enabling third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).

    <Steps>
      <Step title="List Your Connection">
        List your connections to get their IDs

        ```shell theme={null}
        auth0 api get connections
        ```
      </Step>

      <Step title="Choose Your Connections">
        From the list, identify which connections you want to use for the MCP server and copy the ID.

        * For the username-and-password database, look for the connection with the strategy `auth0`.
        * For the Google social connection, look for the connection with the strategy `google-oauth2`.
      </Step>

      <Step title="Upgrade the Connection to Domain-Level">
        For each of those specific connection IDs, run the following command to mark it as a domain-level connection. Replace `YOUR_CONNECTION_ID` with the actual ID (e.g., `con_XXXXXXXXXXXXXXXX`).

        ```shell wrap lines theme={null}
        auth0 api patch connections/YOUR_CONNECTION_ID --data '{"is_domain_connection": true}'
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="2. Create roles (optional)">
    The sample application in this quickstart is prepared to show different tools depending on the role of a given user. For example, a Tool Administrator will have access to different tools than a Tool User.

    <Warning>If you decide to skip this step, you'll only have access to the tool `get_current_time`, which is the only tool in the sample apps that doesn't require any permissions.</Warning>

    If your application doesn't require that level of access, i.e., all users have access to available tools, this step is not required for your use case.

    Let's create roles that allow you to control which users can access which tools.

    For each role you need (e.g., "Tool Administrator", "Tool User"), run the create command as below.

    ```shell wrap lines theme={null}
    # Example for an admin role
    auth0 roles create --name "Tool Administrator" --description "Grants access to all MCP tools"

    # Example for a basic user role
    auth0 roles create --name "Tool User" --description "Grants access to basic MCP tools"
    ```

    Save the IDs from the output (they start with `rol_`), as you'll need them in a later step to assign permissions and users to these roles.
  </Accordion>

  <Accordion title="3. Assign roles to users (optional)">
    <Warning>If you skipped creating roles in the step above, you can skip this step as well.</Warning>

    Find users and assign them to the roles. You can search by their email address:

    ```shell wrap lines theme={null}
    auth0 users search --query "email:\"example@google.com\""
    ```

    Copy the user ID (`USERID`) from the last command's output, then assign the role to the user:

    ```shell wrap lines theme={null}
    auth0 users roles assign "USER_ID_HERE" --roles "YOUR_ROLE_ID_HERE"
    ```
  </Accordion>
</AccordionGroup>

## Create an API to represent your MCP server

An MCP server is treated just like any other [API](https://auth0.com/docs/get-started/apis) in your Auth0 tenant, which means you can use the same access control, scoping, and authorization features. The API (also known as a Resource Server) represents your protected MCP Server.

Run the following command to [create an API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) in Auth0:

```shell wrap lines theme={null}
auth0 api post resource-servers --data '{
  "identifier": "http://localhost:3001/",
  "name": "MCP Tools API",
  "signing_alg": "RS256",
  "token_dialect": "rfc9068_profile_authz",
  "enforce_policies": true,
  "scopes": [
    {"value": "tool:whoami", "description": "Access the WhoAmI tool"},
    {"value": "tool:greet", "description": "Access the Greeting tool"}
  ]
}'
```

Note that `rfc9068_profile_authz` is used as the [token dialect](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis#token-dialect-options) to include the `permissions` claim in the access token, which can be useful for the API to check user permissions without making additional calls.

For more details on protecting APIs with Auth0, check our [quickstarts](https://auth0.com/docs/quickstarts#backend%2Fapi).

<Accordion title="Assign permissions to roles (optional)">
  After creating the API and roles, assign the API permissions to the roles.

  <Warning>If you skipped creating roles in the "Configure tenant settings" section above, you can skip this step as well.</Warning>

  ```shell wrap lines theme={null}
  # Example for admin role (all scopes)
  auth0 roles permissions add YOUR_ADMIN_ROLE_ID --api-id "http://localhost:3001/" --permissions "tool:whoami,tool:greet"

  # Example for user role (one scope)
  auth0 roles permissions add YOUR_USER_ROLE_ID --api-id "http://localhost:3001/" --permissions "tool:whoami"
  ```

  Replace `YOUR_ADMIN_ROLE_ID` and `YOUR_USER_ROLE_ID` with the role IDs you saved when creating the roles.
</Accordion>

## Sample app

<Tabs>
  <Tab title="Javascript" icon="js">
    <Tabs>
      <Tab title="Use sample app (recommended)">
        Start by downloading the sample app for this quickstart. The sample includes a FastMCP MCP server with an Auth0 integration in JavaScript.

        <DownloadQuickstartButton />

        Once downloaded, extract the files and open the project in your preferred IDE.
      </Tab>

      <Tab title="Clone GitHub repository">
        Clone the repository and navigate to the sample app folder which includes a FastMCP MCP server with an Auth0 integration in JavaScript.

        ```shell wrap lines theme={null}
        git clone https://github.com/auth0-samples/auth0-ai-samples.git
        cd auth0-ai-samples/auth-for-mcp/fastmcp-mcp-js
        ```

        Once cloned, open the project in your preferred IDE.
      </Tab>
    </Tabs>

    ## Install packages

    Ensure you have npm installed or follow the instructions to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) in its documentation. In the `fastmcp-mcp-js` directory, install the required packages:

    ```shell theme={null}
    npm install
    ```

    ## Create your environment file

    In the `fastmcp-mcp-js` directory, run the following command to create a new `.env` file populated with all the required environment variables:

    ```shell wrap lines theme={null}
    DOMAIN=$(auth0 tenants list --json | jq -r '.[] | select(.active == true) | .name') \
    && touch .env \
    && echo "AUTH0_DOMAIN=${DOMAIN}" > .env \
    && echo "AUTH0_AUDIENCE=http://localhost:3001/" >> .env \
    && echo "PORT=3001" >> .env \
    && echo "MCP_SERVER_URL=http://localhost:3001/" >> .env \
    && echo ".env file created with your Auth0 details:" \
    && cat .env
    ```

    ## Run your MCP server

    Run this command to start your server:

    ```shell theme={null}
    npm run start
    ```
  </Tab>

  <Tab title="Python" icon="python">
    <Tabs>
      <Tab title="Use sample app (recommended)">
        Start by downloading the sample app for this quickstart. The sample includes a FastMCP MCP server with an Auth0 integration in Python.

        <DownloadQuickstartButton />

        Once downloaded, extract the files and open the project in your preferred IDE.
      </Tab>

      <Tab title="Clone GitHub repository">
        Clone the repository and navigate to the sample app folder which includes a FastMCP MCP server with an Auth0 integration in Python.

        ```shell wrap lines theme={null}
        git clone https://github.com/auth0-samples/auth0-ai-samples.git
        cd auth0-ai-samples/auth-for-mcp/fastmcp-mcp-python
        ```

        Once cloned, open the project in your preferred IDE.
      </Tab>
    </Tabs>

    ## Install packages

    Ensure you have poetry installed or follow the instructions to [install poetry](https://python-poetry.org/docs/) in its documentation. In the `fastmcp-mcp-python` directory, install the required packages:

    ```shell theme={null}
    poetry install
    ```

    ## Create your environment file

    In the `fastmcp-mcp-python` directory, run the following command to create a new `.env` file populated with all the required environment variables:

    ```shell wrap lines theme={null}
    DOMAIN=$(auth0 tenants list --json | jq -r '.[] | select(.active == true) | .name') \
    && touch .env \
    && echo "AUTH0_DOMAIN=${DOMAIN}" > .env \
    && echo "AUTH0_AUDIENCE=http://localhost:3001/" >> .env \
    && echo "PORT=3001" >> .env \
    && echo "MCP_SERVER_URL=http://localhost:3001/" >> .env \
    && echo ".env file created with your Auth0 details:" \
    && cat .env
    ```

    ## Run your MCP server

    Run this command to start your server:

    ```shell theme={null}
    poetry run python -m src.server
    ```
  </Tab>
</Tabs>

## Testing your MCP server

Now that your MCP server is up and running, you can test it by using tools like [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector).

<Card title="Learn how to test your Auth0-powered MCP server" href="/mcp/guides/test-your-mcp-server-with-mcp-inspector" icon="book" />

## Next steps

* To set up first-party tool calling, complete the [Call Your APIs on a User's Behalf](./call-your-apis-on-users-behalf) quickstart.


# Call Your API on a User's Behalf
Source: https://auth0.com/ai/docs/mcp/get-started/call-your-apis-on-users-behalf

Learn how to call an Auth0-protected API from your MCP server.

To call your APIs on behalf of your users, the MCP server needs to exchange the Auth0 access token it received from the MCP client (with the audience set to the MCP server itself) for a new Auth0 access token with the audience set to your API.

In Auth0, this is called Custom Token Exchange and uses [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html). This flow involves the MCP server acting as both a resource server (for the client) and a client (for the upstream API).

By the end of this quickstart, you should have an MCP server that can:

* Exchange an Auth0 access token for another Auth0 access token with a different audience using Custom Token Exchange
* Verify the access token using the `@auth0/auth0-api-js` library (which uses `jose` under the hood) or the `auth0-api-python` library for Python against your tenant JWKS, enforcing issuer, audience, and RS256

## Prerequisites

<Note>
  Auth for MCP is currently available in Early Access. To join the Early Access program, please complete [this form](https://forms.gle/hvJ1ZRLmHr9YjV2a9). We'll reach out to you when your request is processed.
</Note>

<AccordionGroup>
  <Accordion title="1. Create or log in to your Auth0 account">
    To continue with this quickstart, you need to have an [Auth0 account](https://auth0.com/signup).
  </Accordion>

  <Accordion title="2. Enable your tenant to use the Resource Parameter Compatibility Profile">
    To use the `resource` parameter in your access tokens, you need to enable the compatibility profile.

    The quickest way to enable it is through the [Auth0 Dashboard](https://manage.auth0.com/dashboard/):

    1. Navigate to **Settings** on the left sidebar.
    2. Click on [**Advanced**](https://manage.auth0.com/dashboard/#/tenant/advanced) in the top right corner.
    3. Scroll down to the Settings section, find and enable the **Resource Parameter Compatibility Profile** toggle.
  </Accordion>

  <Accordion title="3. Install the Auth0 CLI">
    This guide uses [Auth0 CLI](https://auth0.github.io/auth0-cli/) to configure an Auth0 tenant for secure MCP tool access.

    1. Follow the [Auth0 CLI installation instructions](https://auth0.github.io/auth0-cli/).
    2. Log in to your account with the Auth0 CLI:

    ```shell wrap lines theme={null}
    auth0 login --scopes "read:client_grants,create:client_grants,delete:client_grants,read:clients,create:clients,update:clients,read:resource_servers,create:resource_servers,update:resource_servers,read:roles,create:roles,update:roles,update:tenant_settings,read:connections,update:connections"
    ```

    Confirm you are in the correct tenant by double-checking the tenant domain in the terminal, or run the command below:

    ```shell theme={null}
    auth0 tenants list
    ```

    If more than one tenant is configured, the default tenant will be indicated by an arrow.
  </Accordion>

  <Accordion title="4. Install jq">
    To simplify the process of interacting with the Auth0 CLI, we recommend installing [jq](https://jqlang.org/download/). This will allow you to easily parse JSON responses from the CLI.

    <Tabs>
      <Tab title="macOS">
        <CodeBlock>brew install jq</CodeBlock>
      </Tab>

      <Tab title="Linux">
        <CodeBlock>sudo apt-get install jq</CodeBlock>
      </Tab>

      <Tab title="Windows">
        <CodeBlock>choco install jq</CodeBlock>
      </Tab>
    </Tabs>
  </Accordion>
</AccordionGroup>

## Configure tenant settings

<AccordionGroup>
  <Accordion title="1. Promote the connection to a domain-level connection">
    To allow third-party clients like MCP Inspector to use a connection such as a username-and-password database or a social connection, you need to promote the connection to a domain-level connection. [Learn more about enabling third-party applications](https://auth0.com/docs/get-started/applications/confidential-and-public-applications/enable-third-party-applications).

    <Steps>
      <Step title="List Your Connection">
        List your connections to get their IDs

        ```shell theme={null}
        auth0 api get connections
        ```
      </Step>

      <Step title="Choose Your Connections">
        From the list, identify which connections you want to use for the MCP server and copy the ID.

        * For the username-and-password database, look for the connection with the strategy `auth0`.
        * For the Google social connection, look for the connection with the strategy `google-oauth2`.
      </Step>

      <Step title="Upgrade the Connection to Domain-Level">
        For each of those specific connection IDs, run the following command to mark it as a domain-level connection. Replace `YOUR_CONNECTION_ID` with the actual ID (e.g., `con_XXXXXXXXXXXXXXXX`).

        ```shell wrap lines theme={null}
        auth0 api patch connections/YOUR_CONNECTION_ID --data '{"is_domain_connection": true}'
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="2. Create roles (optional)">
    The sample application in this quickstart is prepared to show different tools depending on the role of a given user. For example, a Tool Administrator will have access to different tools than a Tool User.

    <Warning>If you decide to skip this step, you'll only have access to the tool `get_current_time`, which is the only tool in the sample apps that doesn't require any permissions.</Warning>

    If your application doesn't require that level of access, i.e., all users have access to available tools, this step is not required for your use case.

    Let's create roles that allow you to control which users can access which tools.

    For each role you need (e.g., "Tool Administrator", "Tool User"), run the create command as below.

    ```shell wrap lines theme={null}
    # Example for an admin role
    auth0 roles create --name "Tool Administrator" --description "Grants access to all MCP tools"

    # Example for a basic user role
    auth0 roles create --name "Tool User" --description "Grants access to basic MCP tools"
    ```

    Save the IDs from the output (they start with `rol_`), as you'll need them in a later step to assign permissions and users to these roles.
  </Accordion>

  <Accordion title="3. Assign roles to users (optional)">
    <Warning>If you skipped creating roles in the step above, you can skip this step as well.</Warning>

    Find users and assign them to the roles. You can search by their email address:

    ```shell wrap lines theme={null}
    auth0 users search --query "email:\"example@google.com\""
    ```

    Copy the user ID (`USERID`) from the last command's output, then assign the role to the user:

    ```shell wrap lines theme={null}
    auth0 users roles assign "USER_ID_HERE" --roles "YOUR_ROLE_ID_HERE"
    ```
  </Accordion>
</AccordionGroup>

## Set up the Auth0 Applications and APIs

When an MCP server needs to call underlying APIs, it needs to perform a Custom Token Exchange to obtain an access token with the audience set to the API rather than the MCP server itself. Because of this architecture, the MCP server acts in a dual role.

1. To the MCP client (e.g., an IDE, an AI assistant), the MCP server acts as a **Resource Server** (an API).
2. To the underlying API (e.g., your own API), the MCP server acts as a **Client**.

Because of this, you will set up the MCP server twice on your Auth0 tenant, both as an API and as a Client.

### Create an API to represent your MCP server

An MCP server is treated just like any other [API](https://auth0.com/docs/get-started/apis) in your Auth0 tenant, which means you can use the same access control, scoping, and authorization features. The API (also known as a Resource Server) represents your protected MCP Server.

Run the following command to [create an API](https://auth0.com/docs/get-started/auth0-overview/set-up-apis) in Auth0:

```shell wrap lines theme={null}
auth0 api post resource-servers --data '{
  "identifier": "http://localhost:3001/",
  "name": "MCP Tools API",
  "signing_alg": "RS256",
  "token_dialect": "rfc9068_profile_authz",
  "enforce_policies": true,
  "scopes": [
    {"value": "tool:whoami", "description": "Access the WhoAmI tool"},
    {"value": "tool:greet", "description": "Access the Greeting tool"}
  ]
}'
```

Note that `rfc9068_profile_authz` is used as the [token dialect](https://auth0.com/docs/get-started/apis/enable-role-based-access-control-for-apis#token-dialect-options) to include the `permissions` claim in the access token, which can be useful for the API to check user permissions without making additional calls.

For more details on protecting APIs with Auth0, check our [quickstarts](https://auth0.com/docs/quickstarts#backend%2Fapi).

<Accordion title="Assign permissions to roles (optional)">
  After creating the API and roles, assign the API permissions to the roles.

  <Warning>If you skipped creating roles in the "Configure tenant settings" section above, you can skip this step as well.</Warning>

  ```shell wrap lines theme={null}
  # Example for admin role (all scopes)
  auth0 roles permissions add YOUR_ADMIN_ROLE_ID --api-id "http://localhost:3001/" --permissions "tool:whoami,tool:greet"

  # Example for user role (one scope)
  auth0 roles permissions add YOUR_USER_ROLE_ID --api-id "http://localhost:3001/" --permissions "tool:whoami"
  ```

  Replace `YOUR_ADMIN_ROLE_ID` and `YOUR_USER_ROLE_ID` with the role IDs you saved when creating the roles.
</Accordion>

### Create an Application for your MCP server

In the custom token exchange scenario, the MCP server acts as a client in order to obtain an Auth0 access token with custom token exchange:

```shell wrap lines theme={null}
auth0 api post clients --data '{
  "name": "MCP Server Client",
  "app_type": "resource_server",
  "oidc_conformant": true,
  "resource_server_identifier": "http://localhost:3001/",
  "token_exchange": {
    "allow_any_profile_of_type": ["custom_authentication"]
  }
}' | jq -c '{client_id, client_secret}' > auth0-app-details.json
```

The output of the command will be a JSON object with the `client_id` and `client_secret` of the newly created client, which will be used in the next steps to configure the MCP server environment.

And finally, because you need an API to call to, let's create one.

### Create a first-party API to call from the MCP server

Since your objective is to have the MCP server make a tool call that calls a protected first-party API you need to configure an API in Auth0, this will be your upstream API:

```shell theme={null}
auth0 api post resource-servers --data '{
  "identifier": "http://localhost:8787/",
  "name": "Protected First Party API",
  "signing_alg": "RS256",
  "enforce_policies": true,
  "scopes": [
    {"value": "read:private", "description": "Private scope"}
  ]
}' | jq -r '"Audience: " + .identifier'
```

Save the `Audience` from the command output; you'll need it in a later step.

## Sample app

<Tabs>
  <Tab title="Javascript" icon="js">
    <Tabs>
      <Tab title="Use sample app (recommended)">
        Start by downloading the sample app for this quickstart. The sample includes a FastMCP MCP server with an Auth0 integration and a protected API built with
        [Fastify](https://fastify.dev/).

        <DownloadQuickstartButton />

        Once downloaded, extract the files and open the project in your preferred IDE.
      </Tab>

      <Tab title="Clone GitHub repository">
        Clone the repository and navigate to the sample app folder which includes a FastMCP MCP server with an Auth0 integration and a protected API built with
        [Fastify](https://fastify.dev/).

        ```shell wrap lines theme={null}
        git clone https://github.com/auth0-samples/auth0-ai-samples.git
        cd auth0-ai-samples/auth-for-mcp/fastmcp-mcp-customtokenexchange-js
        ```

        Once cloned, open the project in your preferred IDE.
      </Tab>
    </Tabs>

    The sample app demonstrates custom token exchange with a `greet` tool that calls your protected API on behalf of the authenticated user.

    ## Install packages

    Ensure you have npm installed or follow the instructions to [install npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) in its documentation. In the `fastmcp-mcp-customtokenexchange-js` directory, install the required packages:

    ```shell theme={null}
    npm install
    ```

    ## Create your environment file

    From the root of your sample app directory, run the following command to create a new `.env` file populated with all the required environment variables:

    ```shell wrap lines expandable theme={null}
    CLIENT_ID=$(jq -r '.client_id' auth0-app-details.json) \
    && CLIENT_SECRET=$(jq -r '.client_secret' auth0-app-details.json) \
    && DOMAIN=$(auth0 tenants list --json | jq -r '.[] | select(.active == true) | .name') \
    && touch .env \
    && echo "AUTH0_DOMAIN=${DOMAIN}" > .env \
    && echo "AUTH0_AUDIENCE=http://localhost:3001/" >> .env \
    && echo "PORT=3001" >> .env \
    && echo "MCP_SERVER_URL=http://localhost:3001/" >> .env \
    && echo "MCP_AUTH0_CLIENT_ID=${CLIENT_ID}" >> .env \
    && echo "MCP_AUTH0_CLIENT_SECRET=${CLIENT_SECRET}" >> .env \
    && echo "MCP_AUTH0_SUBJECT_TOKEN_TYPE=urn:fastmcp:mcp" >> .env \
    && echo "MCP_AUTH0_EXCHANGE_SCOPE=openid offline_access read:private" >> .env \
    && echo "API_AUTH0_AUDIENCE=http://localhost:8787/" >> .env \
    && echo "API_BASE_URL=http://localhost:8787/" >> .env \
    && rm auth0-app-details.json \
    && echo ".env file created with your Auth0 details:" \
    && cat .env
    ```

    ## Use Custom Token Exchange Action

    This Action is the server-side logic Auth0 executes to perform the token exchange. It is necessary because the MCP server receives an access token from the client (with the MCP server as its audience) and must exchange it for a new token (with the upstream API as the audience). This Action validates the original token and mints the new one.

    The Custom Token Exchange Action is available as part of Custom Token Exchange Early Access. Navigate to [the On-behalf-of token exchange for first-party apps template available here](https://manage.auth0.com/#/actions/library/templates/templates/daeda4e8-8da2-4abb-afb5-ac09df0ebb2a) and click on **Use This Template**.

    <Frame>
      <img alt="Action On-behalf-of token exchange for first-party apps template page" />
    </Frame>

    This will open a modal for you to name the action:

    <Frame>
      <img alt="Action creation modal" />
    </Frame>

    Once the action is created, you can **Deploy** it. When you deploy the Action, Auth0 assigns it an Action ID. You still need to add your custom logic to the Action, but first, get the Action ID to create the Custom Token Exchange Profile.

    ## Set up the token exchange profile

    To enable Custom Token Exchange, you need to create a Token Exchange Profile that links your Custom Token Exchange Action to a unique subject token type identifier.

    <AccordionGroup>
      <Accordion title="1. Get Your Action ID">
        You need the ID of the Custom Token Exchange Action you deployed earlier.

        Run the following command to list all actions in your tenant:

        ```shell theme={null}
        auth0 actions list
        ```

        From the output, find the action that matches the name you used when creating your Custom Token Exchange Action. Copy the Action ID (it starts with `act_`).

        Example output:

        ```
        ID                          NAME                                     TYPE
        act_aBc123XyZ456            On-behalf-of token exchange             custom-token-exchange
        ```

        Save this Action ID - you'll use it in the next step.
      </Accordion>

      <Accordion title="2. Create the Token Exchange Profile">
        Now use the Auth0 CLI to create your Custom Token Exchange Profile.

        Replace the placeholder values in the command below:

        * `<your-action-id>` - The Action ID from Step 1
        * `<YOUR_PROFILE_NAME>` - A descriptive name for your profile (e.g., `MCP Custom Token Exchange`)

        ```shell wrap lines theme={null}
        auth0 token-exchange create \
          --name "<YOUR_PROFILE_NAME>" \
          --subject-token-type "urn:fastmcp:mcp" \
          --action-id "<your-action-id>" \
          --type "custom_authentication"
        ```

        <Info>
          The `subject_token_type` must be a unique URI identifier. In this example, we use `urn:fastmcp:mcp` which is specific to FastMCP implementations. You cannot use reserved namespaces like `urn:auth0`, `urn:okta`, or `urn:ietf`.
        </Info>

        A successful response will return the profile details including the profile ID and creation timestamp.

        For more information on managing token exchange profiles, see [Custom Token Exchange documentation](https://auth0.com/docs/authenticate/custom-token-exchange#manage-custom-token-exchange-profile).
      </Accordion>
    </AccordionGroup>

    ## Run the MCP server and the API

    Run this command to start your server:

    ```shell theme={null}
    npm run start
    ```

    And in a separate window run this command to start the API:

    ```shell theme={null}
    npm run start:api
    ```

    ## Exchange your access token

    To call your APIs on behalf of your users, the MCP server needs to exchange the Auth0 access token it received from the MCP client (with the audience set to the MCP server itself) for a new Auth0 access token with the audience set to your API. In Auth0, this is called Custom Token Exchange and uses [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html).

    ### The Orchestrator: `bearerForUpstream`

    The process begins with the `bearerForUpstream` function. Its main job is to take the initial token (the `subjectToken`), manage the exchange process, and handle any potential errors gracefully.

    This function serves as a safe wrapper around our exchange logic.

    ```javascript wrap lines highlight={5} theme={null}
    async function bearerForUpstream(subjectToken: string) {
      if (!subjectToken) return { token: null, scopes: null };

      try {
        const result = await exchangeCustomToken(subjectToken);
        return {
          token: result.accessToken,
          scopes: result.scope,
        }
      } catch (err) {
        console.error('Error during token exchange:', err);
        throw err;
      }
    }
    ```

    As you can see, it calls `exchangeCustomToken` and, on a successful exchange, returns the new `accessToken` and its associated scope. If the exchange fails, it logs the error and re-throws it to be handled upstream.

    ### The core logic: `exchangeCustomToken`

    This function, located in `src/auth0.ts`, contains the actual token exchange logic. It uses the `ApiClient` from the `auth0-api-js` SDK to simplify the interaction with Auth0's `/oauth/token` endpoint.

    First, we initialize the `ApiClient` with the credentials of the application performing the exchange:

    ```javascript wrap lines theme={null}
     const exchangeClient = new ApiClient({
      domain: AUTH0_DOMAIN,
      audience: API_AUTH0_AUDIENCE,
      clientId: MCP_AUTH0_CLIENT_ID,
      clientSecret: MCP_AUTH0_CLIENT_SECRET,
    });
    ```

    With the client configured, the `exchangeCustomToken` function uses the client's `getTokenByExchangeProfile` method to perform the token exchange. This method implements the [Custom Token Exchange](https://auth0.com/docs/authenticate/custom-token-exchange) flow.

    ```javascript wrap lines theme={null}
    export async function exchangeCustomToken(subjectToken: string) {
        return await exchangeClient.getTokenByExchangeProfile(subjectToken, {
          subjectTokenType: MCP_AUTH0_SUBJECT_TOKEN_TYPE,
          audience: API_AUTH0_AUDIENCE,
          ...(MCP_AUTH0_EXCHANGE_SCOPE && { scope: MCP_AUTH0_EXCHANGE_SCOPE }),
        });
    }
    ```
  </Tab>

  <Tab title="Python" icon="python">
    <Tabs>
      <Tab title="Use sample app (recommended)">
        Start by downloading the sample app for this quickstart. The sample includes a FastMCP MCP server with an Auth0 integration and a protected Starlette-based API.

        <DownloadQuickstartButton />

        Once downloaded, extract the files and open the project in your preferred IDE.
      </Tab>

      <Tab title="Clone GitHub repository">
        Clone the repository and navigate to the sample app folder which includes a FastMCP MCP server with an Auth0 integration and a protected Starlette-based API.

        ```shell wrap lines theme={null}
        git clone https://github.com/auth0-samples/auth0-ai-samples.git
        cd auth0-ai-samples/auth-for-mcp/fastmcp-mcp-customtokenexchange-python
        ```

        Once cloned, open the project in your preferred IDE.
      </Tab>
    </Tabs>

    The sample app demonstrates custom token exchange with a `greet` tool that calls your protected API on behalf of the authenticated user.

    ## Install packages

    Ensure you have poetry installed or follow the instructions to [install poetry](https://python-poetry.org/docs/) in its documentation. In the `fastmcp-mcp-customtokenexchange-python` directory, install the required packages:

    ```shell theme={null}
    poetry install
    ```

    ## Create your environment file

    From the root of your sample app directory, run the following command to create a new `.env` file populated with all the required environment variables:

    ```shell wrap lines expandable theme={null}
    CLIENT_ID=$(jq -r '.client_id' auth0-app-details.json) \
    && CLIENT_SECRET=$(jq -r '.client_secret' auth0-app-details.json) \
    && DOMAIN=$(auth0 tenants list --json | jq -r '.[] | select(.active == true) | .name') \
    && touch .env \
    && echo "AUTH0_DOMAIN=${DOMAIN}" > .env \
    && echo "AUTH0_AUDIENCE=http://localhost:3001/" >> .env \
    && echo "PORT=3001" >> .env \
    && echo "MCP_SERVER_URL=http://localhost:3001/" >> .env \
    && echo "MCP_AUTH0_CLIENT_ID=${CLIENT_ID}" >> .env \
    && echo "MCP_AUTH0_CLIENT_SECRET=${CLIENT_SECRET}" >> .env \
    && echo "MCP_AUTH0_SUBJECT_TOKEN_TYPE=urn:fastmcp:mcp" >> .env \
    && echo "MCP_AUTH0_EXCHANGE_SCOPE=openid offline_access read:private" >> .env \
    && echo "API_AUTH0_AUDIENCE=http://localhost:8787/" >> .env \
    && echo "API_BASE_URL=http://localhost:8787/" >> .env \
    && rm auth0-app-details.json \
    && echo ".env file created with your Auth0 details:" \
    && cat .env
    ```

    ## Use Custom Token Exchange Action

    This Action is the server-side logic Auth0 executes to perform the token exchange. It is necessary because the MCP server receives an access token from the client (with the MCP server as its audience) and must exchange it for a new token (with the upstream API as the audience). This Action validates the original token and mints the new one.

    The Custom Token Exchange Action is available as part of Custom Token Exchange Early Access. Navigate to [the On-behalf-of token exchange for first-party apps template available here](https://manage.auth0.com/#/actions/library/templates/templates/daeda4e8-8da2-4abb-afb5-ac09df0ebb2a) and click on **Use This Template**.

    <Frame>
      <img alt="Action On-behalf-of token exchange for first-party apps template page" />
    </Frame>

    This will open a modal for you to name the action:

    <Frame>
      <img alt="Action creation modal" />
    </Frame>

    Once the action is created, you can **Deploy** it. When you deploy the Action, Auth0 assigns it an Action ID. You still need to add your custom logic to the Action, but first, get the Action ID to create the Custom Token Exchange Profile.

    ## Set up the token exchange profile

    To enable Custom Token Exchange, you need to create a Token Exchange Profile that links your Custom Token Exchange Action to a unique subject token type identifier.

    <AccordionGroup>
      <Accordion title="1. Get Your Action ID">
        You need the ID of the Custom Token Exchange Action you deployed earlier.

        Run the following command to list all actions in your tenant:

        ```shell theme={null}
        auth0 actions list
        ```

        From the output, find the action that matches the name you used when creating your Custom Token Exchange Action. Copy the Action ID (it starts with `act_`).

        Example output:

        ```
        ID                          NAME                                     TYPE
        act_aBc123XyZ456            On-behalf-of token exchange             custom-token-exchange
        ```

        Save this Action ID - you'll use it in the next step.
      </Accordion>

      <Accordion title="2. Create the Token Exchange Profile">
        Now use the Auth0 CLI to create your Custom Token Exchange Profile.

        Replace the placeholder values in the command below:

        * `<your-action-id>` - The Action ID from Step 1
        * `<YOUR_PROFILE_NAME>` - A descriptive name for your profile (e.g., `MCP Custom Token Exchange`)

        ```shell wrap lines theme={null}
        auth0 token-exchange create \
          --name "<YOUR_PROFILE_NAME>" \
          --subject-token-type "urn:fastmcp:mcp" \
          --action-id "<your-action-id>" \
          --type "custom_authentication"
        ```

        <Info>
          The `subject_token_type` must be a unique URI identifier. In this example, we use `urn:fastmcp:mcp` which is specific to FastMCP implementations. You cannot use reserved namespaces like `urn:auth0`, `urn:okta`, or `urn:ietf`.
        </Info>

        A successful response will return the profile details including the profile ID and creation timestamp.

        For more information on managing token exchange profiles, see [Custom Token Exchange documentation](https://auth0.com/docs/authenticate/custom-token-exchange#manage-custom-token-exchange-profile).
      </Accordion>
    </AccordionGroup>

    ## Run the MCP server and the API

    Run this command to start your server:

    ```shell theme={null}
    poetry run python -m src.server
    ```

    And in a separate window run this command to start the API:

    ```shell theme={null}
    poetry run python -m src.api.server
    ```

    ## Exchange your access token

    To call your APIs on behalf of your users, the MCP server needs to exchange the Auth0 access token it received from the MCP client (with the audience set to the MCP server itself) for a new Auth0 access token with the audience set to your API. In Auth0, this is called Custom Token Exchange and uses [RFC 8693](https://www.rfc-editor.org/rfc/rfc8693.html).

    ### How tools use token exchange

    Here's how the `greet` tool performs token exchange and calls the upstream API:

    ```python wrap lines highlight={10,11,12,13,14,19} theme={null}
    @mcp.tool(name="greet")
    @require_scopes(["tool:greet"])
    async def greet(name: str, ctx: Context) -> str:
        user_name = name.strip() if name else "there"
        auth_info = ctx.request_context.request.state.auth
        user_id = auth_info.get("extra", {}).get("sub")

        logger.info(f"Greet tool invoked for user: {user_id}")

        # Exchange token and call upstream API
        exchange_result = await exchange_custom_token(
            ctx.request_context.request.state.api_client,
            auth_info["token"]
        )

        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{config.api_base_url}/api/private-scope",
                headers={"authorization": f"Bearer {exchange_result['token']}"}
            )
            upstream_result = response.json()

        return f"Hello, {user_name} ({user_id})!\nUpstream API Response: {json.dumps(upstream_result, indent=2)}"
    ```

    ### The core logic: `exchange_custom_token`

    The Python implementation uses the `exchange_custom_token` function that handles the token exchange process.

    ```python wrap lines highlight={3,4,5,6,7,8} theme={null}
    async def exchange_custom_token(api_client, subject_token: str) -> dict:
        """Exchange subject token for access token via Custom Token Exchange."""
        result = await api_client.get_token_by_exchange_profile(
            subject_token=subject_token,
            subject_token_type=config.mcp_auth0_subject_token_type,
            audience=config.api_auth0_audience,
            scope=config.mcp_auth0_exchange_scope or None
        )
        return {"token": result["access_token"], "scopes": result.get("scope", "")}
    ```

    This function uses the `get_token_by_exchange_profile` method of `ApiClient` from the `auth0-api-python` SDK and, on a successful exchange, returns the new access token and its associated scopes. This method implements the [Custom Token Exchange](https://auth0.com/docs/authenticate/custom-token-exchange) flow.

    ### Client Configuration

    The `ApiClient` is initialized in the `Auth0Middleware` (located in `src/auth0/middleware.py`) with the credentials of the application performing the exchange:

    ```python src/auth0/middleware.py wrap lines theme={null}
    self.client = ApiClient(ApiClientOptions(
        domain=domain, # AUTH0_DOMAIN env var
        audience=audience, # API_AUTH0_AUDIENCE env var
        client_id=client_id, # MCP_AUTH0_CLIENT_ID env var
        client_secret=client_secret # MCP_AUTH0_CLIENT_SECRET env var
    ))
    ```

    The configured client is then attached to the request context during middleware processing, making it available to all tools:

    ```python src/auth0/middleware.py wrap lines theme={null}
    # In the Auth0Middleware dispatch method
    request.state.api_client = self.client
    ```
  </Tab>
</Tabs>

## Testing your MCP server

Now that your MCP server is up and running, you can test it by using tools like [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector).

<Card title="Learn how to test your Auth0-powered MCP server" href="/mcp/guides/test-your-mcp-server-with-mcp-inspector" icon="book" />

## Next steps

* To set up MCP server authorization, complete the [Authorization for Your MCP Server](./authorization-for-your-mcp-server) quickstart.


# Get Started
Source: https://auth0.com/ai/docs/mcp/get-started/overview

Start building with Auth for MCP quickstarts.

## Quickstarts

Secure your MCP servers, enable API access, and implement standards-based client registration.

<Columns>
  <Card title="Authorization for Your MCP Server" icon="user" href="./authorization-for-your-mcp-server">
    Secure your MCP server by requiring and validating access tokens from authorized clients
  </Card>

  <Card title="Call Your APIs on User's Behalf" icon="shapes" href="./call-your-apis-on-users-behalf">
    Enable your MCP servers to make calls to your protected first-party APIs
  </Card>
</Columns>


# Secure MCP Servers with Auth0 and Cloudflare
Source: https://auth0.com/ai/docs/mcp/guides/cloudflare-mcp

Learn how to use Auth0 and Cloudflare to secure MCP servers.

Auth0 has collaborated with Cloudflare to help developers secure remote MCP servers powered by [Cloudflare Workers](https://developers.cloudflare.com/workers/). With the pace of MCP adoption rapidly increasing, Cloudflare has [added features to its platform](https://blog.cloudflare.com/remote-model-context-protocol-servers-mcp/) that handle the hard parts of building remote MCP servers, like `workers-oauth-provider`, an OAuth Provider that makes authorization easy. By securing your MCP server with Auth0, AI applications can now interact with an external API by connecting through the remote MCP server and make API calls on behalf of an authenticated user.

## Sample App for Securing an MCP Server and API

Learn how to set up and use an AI application to connect with a sample Todos API using an MCP server secured by Auth0. The server and API are Cloudflare Workers projects and will use Auth0 to request and receive access and refresh tokens.

<Frame>
  <img alt="Auth0 Authentication Flow" />

  <img alt="Auth0 Authentication Flow" />
</Frame>

<Card href="https://auth0.com/blog/secure-and-deploy-remote-mcp-servers-with-auth0-and-cloudflare/" title="See all the steps and the full details in this blog post" icon="link" />


# Register your MCP Client Application
Source: https://auth0.com/ai/docs/mcp/guides/registering-your-mcp-client-application

Register MCP clients so AI Agents can safely connect to your resources using OAuth 2.1.

Before your MCP client application can interact with a protected MCP server, it must be registered with an authorization server like Auth0. This registration process provides the client with a unique `client_id` and credentials, establishing a trusted identity for the OAuth 2.1 flow.

You can register your client in two ways: statically or dynamically. For most scenarios, especially in production, we strongly recommend static client registration for its superior security and control.

<Note>In the upcoming authorization specification from MCP, [Client ID Metadata Documents (CIMD)](https://modelcontextprotocol.io/specification/draft/basic/authorization#client-id-metadata-documents) will be introduced as the recommended method for client registration. Support for this new approach in Auth0 is planned and will be available soon.</Note>

## Static client registration (recommended for production)

**Static client registration** is a deliberate, manual process where you register your client application directly in the Auth0 Dashboard or via the Management API before your application is deployed. This approach gives you complete control over which clients can connect to your resources.

This method is recommended because it offers several key advantages:

* **Enhanced Security**: You explicitly approve every client, preventing unauthorized or malicious applications from registering themselves and accessing your system.
* **Predictable Configuration**: The `client_id` and other settings are known in advance, simplifying deployment and configuration management.
* **Clear Auditing**: There is a clear, auditable trail for every client created, linking it to a specific developer or team.
* **Principle of Least Privilege**: You can precisely configure the exact permissions (scopes) and settings for each client from the outset.

You can perform static registration by creating an application in the Auth0 Dashboard or by using the Auth0 Management API, as shown below:

```shell wrap lines theme={null}
auth0 api post clients --data '{
  "name": "MCP Inspector",
  "app_type": "regular_web",
  "is_first_party": false,
  "callbacks": ["http://localhost:6274/oauth/callback"],
  "grant_types": ["authorization_code"],
  "token_endpoint_auth_method": "client_secret_post",
  "oidc_conformant": true,
  "jwt_configuration": { "alg": "RS256" },
  "logo_uri": "https://avatars.githubusercontent.com/u/182288589"
}'
```

## Dynamic Client Registration (DCR)

**Dynamic Client Registration (DCR)** allows client applications to register themselves automatically by making an API request to a registration endpoint. While this offers flexibility for certain highly dynamic architectures, it introduces significant security risks if not properly secured.

### The Dangers of an Open DCR Endpoint

Auth0 supports an open DCR endpoint, which means that if you enable this feature without additional protections, **anyone on the internet can create applications in your tenant**. This exposes you to several threats:

* **Resource Exhaustion**: A malicious actor could run a script to register millions of applications, potentially causing a denial-of-service by filling up your tenant's application limit.
* **Unauthorized Access Attempts**: Attackers can register their own clients to probe your system for vulnerabilities or attempt to gain unauthorized access.
* **Tenant Misconfiguration**: Unvetted, automated registrations can lead to clients being created with insecure settings, creating weak points in your security posture.
* **Lack of Oversight**: Without strict monitoring, it becomes difficult to track who is registering clients and for what purpose.

## Securing an Open DCR Endpoint

Open Dynamic Client Registration (Open DCR) enables flexible MCP integrations but exposes your tenant to potential abuse if left unauthenticated. Without security controls, anyone can create applications in your tenant, potentially leading to resource exhaustion, unauthorized access attempts, or tenant misconfiguration.

<Callout icon="file-lines">
  These security options are available to Enterprise customers only. To upgrade your plan, contact [Auth0 Sales](https://auth0.com/get-started).
</Callout>

There are two approaches you can implement to mitigate these risks:

### Tenant Access Control List (Recommended)

Restrict which IP address ranges or domains can access your tenant's DCR endpoints through Auth0's built-in [Tenant Access Control List (ACL)](https://auth0.com/docs/secure/tenant-access-control-list) feature. This approach protects both your custom domain and canonical Auth0 hostname (e.g., `tenant.auth0.com`), providing comprehensive protection.

It's ideal when you know the IP ranges of legitimate clients (such as your internal network or specific cloud providers) and want to enforce network-based access control without managing additional infrastructure.

### Reverse Proxy

Place a [reverse proxy](https://auth0.com/docs/customize/custom-domains/self-managed-certificates/configure-cloudflare-for-use-as-reverse-proxy) (such as Cloudflare) in front of your custom domain to rate-limit, filter, and authenticate requests before they reach the DCR endpoint. This approach allows you to control request volume, implement custom authentication logic, and monitor traffic patterns.

However, note that even with a reverse proxy on your custom domain, the DCR endpoint remains accessible via your canonical Auth0 hostname (e.g., `tenant.auth0.com`), which can bypass the proxy. For comprehensive protection, use this approach in combination with Tenant ACL.

### Defense in Depth

Both approaches can be used together for defense-in-depth security. Regardless of which approach you choose, monitor your [tenant logs](https://auth0.com/docs/deploy-monitor/logs) to detect suspicious registration patterns.

### Monitoring DCR Activity

Regularly review your tenant logs to identify suspicious patterns such as rapid application creation or registrations from unexpected sources.

**To monitor client registrations:**

1. Navigate to **Monitoring > Logs** in your Auth0 Dashboard

2. Use the search query: `type:sapi AND description:"Dynamic client registration"`

   This filters for successful Management API operations (`sapi`) specifically related to Dynamic Client Registration events.

3. Review the log entries for:
   * **Unusual volume**: Multiple clients created in a short time span
   * **Unexpected sources**: Registrations from unfamiliar IP addresses or locations
   * **Suspicious patterns**: Similar client names, callback URLs pointing to unexpected domains, or clients created outside business hours

**Retrieve logs using the Auth0 CLI:**

You can also retrieve DCR logs programmatically using the Auth0 CLI:

```shell wrap lines theme={null}
# Get recent Dynamic Client Registration events
auth0 logs list --filter "type:sapi AND description:\"Dynamic client registration\"" --number 100
```

Consider setting up [log streams](https://auth0.com/docs/customize/log-streams) to forward DCR events to your SIEM or monitoring platform for automated alerting on suspicious registration activity.

## Authentication and Authorization for MCP Servers

When an MCP server is exposed to the internet, it must be secured. The MCP specification recommends using [OAuth 2.1](https://oauth.net/2.1/) to secure these interactions. This allows an MCP server to delegate authentication to a dedicated authorization server and manage access control for different clients, users, and actions using scopes.

### Mandatory Server Configuration

For a client to interact with your server, the MCP specification requires you to announce your authorization configuration and use standard HTTP responses.

1. **Use the `WWW-Authenticate` Header for 401 Errors**

   When a client makes a request without a valid token, your server must return a `401 Unauthorized` status. Crucially, this response must include the `WWW-Authenticate` header, pointing to the metadata URL you configured above. This signals to the client that authentication is required and tells it exactly where to obtain the authorization metadata.

2. **Announce Your Auth Server with Protected Resource Metadata ([RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728))**

   Your MCP server must tell clients where to get authorized. To do this, you must expose a metadata endpoint. Create a `.well-known/oauth-protected-resource` endpoint on your server that returns a JSON object pointing to your Auth0 tenant. This allows MCP clients to automatically discover your authorization endpoints without manual configuration.


# Enable Resource Parameter Compatibility Profile
Source: https://auth0.com/ai/docs/mcp/guides/resource-param-compatibility-profile

Learn how to enable the resource parameter in Auth0.

The Model Context Protocol (MCP) specification requires the use of the standards-compliant `resource` parameter as defined in [RFC 8707](https://www.rfc-editor.org/rfc/rfc8707.html). Auth0's Authentication API has historically used the `audience` parameter to specify a target resource server (API). This document outlines the new `resource` parameter and provides instructions for enabling the new compatibility profile.

## Enabling Resource Parameter Compatibility Profile

To use the `resource` parameter in your access tokens, you need to enable the compatibility profile.

The quickest way to enable it is through the [Auth0 Dashboard](https://manage.auth0.com/dashboard/):

1. Navigate to **Settings** on the left sidebar.
2. Click on [**Advanced**](https://manage.auth0.com/dashboard/#/tenant/advanced) in the top right corner.
3. Scroll down to the Settings section, find and enable the **Resource Parameter Compatibility Profile** toggle.

## How it works

When disabled, the **Resource Parameter Compatibility Profile** will keep the experience as is and only use the `audience` parameter in the Auth0 access token.

<Frame>
  <img alt="Audience in the access token" />

  <img alt="Audience in the access token" />
</Frame>

Once the **Resource Parameter Compatibility Profile** is enabled, Auth0 will use the `resource` parameter if it is available to define the token's audience.

<Frame>
  <img alt="Resource in the access token" />

  <img alt="Resource in the access token" />
</Frame>

If both the `resource` and `audience` are available, the `audience` will still be used. Auth0 will not forward the `resource` to upstream Identity Providers (IdPs). [Learn more](./resource-param-compatibility-profile#resource-parameter-forwarding-to-upstream-identity-provider-idp).

*RFC 8707 requires the `resource` parameter to [be an absolute URI](https://www.rfc-editor.org/rfc/rfc8707.html#name-resource-parameter), to conform with RFC 8707, we recommend defining your resource server identifiers (API identifiers) in [URI format](https://datatracker.ietf.org/doc/html/rfc3986). Using an absolute URI as the identifier of your MCP Server is also a requirement from the MCP Authorization specification.*

## Supported flows

The `resource` parameter is supported in the following flows:

* Standard Authorization Flow (`/authorize`)
* Pushed Authorization Requests (PAR)
* JWT-Secured Authorization Requests (JAR)
* Client-Initiated Backchannel Authentication (CIBA)
* Refresh Token Grant Type

## Resource Parameter Forwarding to Upstream Identity Provider (IdP)

When federating to an upstream IdP, Auth0 provides a way for initiating clients to [forward parameters](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps). In the documentation, notice that `resource` is one of the parameters [available for forwarding to upstream IdPs](https://auth0.com/docs/authenticate/identity-providers/pass-parameters-to-idps#available-fields).

RFC 8707 requires the `resource` parameter to be an absolute URI. To conform with RFC 8707, we recommend defining your resource server identifiers (API identifiers) in URI format. To avoid leaking access token details, Auth0 will not forward the resource parameter to upstream IdPs while the Resource Parameter Compatibility Profile is enabled.

* Resource Parameter Compatibility **disabled** (default behavior):
  * `resource` is available as an upstream IdP parameter.
* Resource Parameter Compatibility **enabled**:

  * `resource` is not available as an upstream IdP parameter, and will not be forwarded.

  <Note>If passing the resource parameter to an upstream IdP, the Resource Parameter Compatibility Profile should not be enabled.</Note>


# Test your MCP Server with MCP Inspector
Source: https://auth0.com/ai/docs/mcp/guides/test-your-mcp-server-with-mcp-inspector

Learn how to test your MCP server with MCP Inspector.

When you're developing your MCP server locally, you have several ways to test it. You could connect it to a standard AI client, but that often hides the underlying protocol details, making it difficult to debug specific requests. Alternatively, you could use command-line tools like curl, but this can be cumbersome, especially when dealing with complex authentication flows and manually crafting JSON payloads.

This is where [MCP Inspector](https://modelcontextprotocol.io/docs/tools/inspector) shines. It's a purpose-built graphical tool that provides the best of both worlds. It gives you a clear, interactive interface to see your server's available tools, handles complex authentication for you, and allows you to directly execute tools with specific inputs, no natural language prompting required. This direct approach makes it an invaluable asset for efficient debugging and development.

## Launching MCP Inspector

First, make sure your MCP server is running in a separate terminal. Then, open a new terminal window and run the following command to launch the MCP Inspector:

```shell theme={null}
npx @modelcontextprotocol/inspector@latest
```

This will open the MCP Inspector interface in your default browser.

<Frame>
  <img alt="MCP Inspector page after running it" />
</Frame>

## Connect to your MCP server

Once the Inspector is open, you need to configure it to connect to your local MCP server.

1. Set the **Transport Type** to `Streamable HTTP`.
2. Enter your server's URL, which is typically `http://localhost:3001/mcp`.

In order for the MCP Inspector to connect to your MCP server you can either do static client registration (recommended) or Dynamic Client Registration (DCR). Pick your preferred method below and follow the instructions.

<Tabs>
  <Tab title="Static Client Registration">
    ## Create an Application to Represent Your MCP Client

    Run this command to create the client:

    ```shell wrap lines theme={null}
    auth0 api post clients --data '{
      "name": "MCP Inspector",
      "app_type": "regular_web",
      "is_first_party": false,
      "callbacks": ["http://localhost:6274/oauth/callback"],
      "grant_types": ["authorization_code"],
      "token_endpoint_auth_method": "client_secret_post",
      "oidc_conformant": true,
      "jwt_configuration": { "alg": "RS256" },
      "logo_uri": "https://avatars.githubusercontent.com/u/182288589"
    }' | jq -r '"\nClient ID:     " + .client_id + "\nClient Secret: " +  .client_secret'
    ```

    Save the `Client ID` and `Client Secret` from the command output.

    In the left navigation menu, click on **Authentication** and enter the **Client ID** and **Client Secret** you obtained when you registered your application.
  </Tab>

  <Tab title="Dynamic Client Registration">
    ## Enable Dynamic Client Registration (DCR)

    Set the tenant-level flag required for Dynamic Client Registration (DCR):

    ```shell wrap lines theme={null}
    auth0 tenant-settings update set flags.enable_dynamic_client_registration
    ```

    Enabling `enable_dynamic_client_registration` allows MCP tools to register themselves as applications automatically through Dynamic Client Registration (DCR).

    <Warning>Auth0 supports Open Dynamic Registration, which means that if you enable this feature, anyone will be able to create applications in your tenant without a token. Read [Securing an Open DCR Endpoint](/mcp/guides/registering-your-mcp-client-application#securing-an-open-dcr-endpoint) to learn strategies to mitigate risks with Open DCR.</Warning>
  </Tab>
</Tabs>

Your MCP server is now ready to use!

3. Click **Connect**.

You'll be redirected to a login and consent screen. Sign in with a user account that has been granted the necessary permissions for the tools.

When you connect to the server for the first time, you will be guided through the authentication process using the [Auth0 Universal Login](https://auth0.com/features/universal-login). You'll see the consent screen where you can check the tools you have access to:

<Frame>
  <img alt="Consent modal while authenticating" />
</Frame>

After you click **Accept** to grant the requested permissions, you'll be redirected back to MCP Inspector. The interface will now show your server is connected and display the list of tools available to you:

<Frame>
  <img alt="MCP Inspector page after running it" />
</Frame>

## Run your tools

After authenticating, you can run the tools the MCP server exposes for your user. These tools may be different per user depending on your server configuration.

<Frame>
  <img alt="List of tools for a user with the Tool Administrator role" />
</Frame>

To run a tool, click on it in the list and then click **Run Tool**.

<Frame>
  <img alt="WhoAmI tool call response in MCP Inspector" />
</Frame>

## Troubleshooting common issues

If you run into problems, here are a few things to check first:

### Connection failed:

* Ensure your MCP server is running in a separate terminal.
* Double-check that the URL ([http://localhost:3001/mcp](http://localhost:3001/mcp)) in the Inspector matches the port and endpoint your server is configured to use.

### Authentication errors:

* Verify that the Client ID and Client Secret you entered in the Inspector are correct and have no extra spaces.
* Make sure you're logging in with a user account that exists in your authentication provider (e.g., Auth0).

### No tools appear after login:

* This usually means the user you logged in with doesn't have the required roles or permissions.
* Check your authentication provider to ensure the user has been assigned the correct roles (e.g., "Tool User" or "Tool Administrator").
* Confirm that the scopes defined in your server's OAuth configuration match the permissions required by the tools.

## Conclusion

You've now walked through the complete process, from launching the MCP Inspector to connecting to a secure server and running your first tool. By integrating the Inspector into your development workflow, you gain a direct and powerful way to test your implementation, verify security rules, and debug tool logic without the overhead of a full AI client. Keep this essential utility in your toolbox as you continue to build and scale your MCP-powered applications with confidence.


# Auth for MCP
Source: https://auth0.com/ai/docs/mcp/intro/overview

Secure MCP clients and servers with Auth0 using OAuth 2.1 and OpenID Connect for user authentication, controlled API access, and scoped token exchange.

<Card title="Secure MCP clients and servers using OAuth 2.1 and OpenID Connect, with user authentication, controlled API access, standards-based client registration, and scoped token exchange." icon="sparkles" />

The [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) is an open standard for connecting AI applications to external data sources, tools, and workflows through a consistent interface. It lets agents use your SaaS apps and internal APIs, run organization-specific workflows, and reuse integrations instead of building one-offs.

<Frame>
  <img alt="MCP Diagram" />

  <img alt="MCP Diagram" />
</Frame>

Auth0's **Auth for MCP** lets developers securely and easily implement the authorization parts of the MCP spec with OAuth 2.1 and OpenID Connect. It provides sign in, standards based discovery and client registration, resource scoped tokens, and token exchange so you can control which agents connect, which resources they can access, and which actions they can perform.

### Accessing a Protected MCP Server

When an MCP server is protected with Auth0, clients and AI agents must first obtain an OAuth 2.0 access token to access it. Auth0 manages the authorization flow, ensuring the user authenticates with their chosen identity provider such as Okta, Entra ID, Ping, or Google Workspace, and delegates limited permissions to the agent.

The MCP client then uses the issued token to call the server. Auth0 handles authentication, token issuance and delegation of permissions. The MCP server then validates the token and enforces the authorization decisions represented in it.

<Card title="Learn more about the benefits of using Auth for MCP" href="/mcp/intro/why-auth-for-mcp" icon="book" />

### Metadata Discovery and Client Registration for MCP

Register MCP clients and servers using standards-aligned discovery and registration so agents connect only to approved resources. Auth0 validates client metadata, issues client credentials, and exposes the necessary discovery endpoints. This lets MCP clients find the right authorization server and request tokens without manual configuration.

<Card title="Learn how to register your MCP client application" href="/mcp/guides/registering-your-mcp-client-application" icon="book" />

### Call your APIs on a user's behalf

When an **AI agent** connects to your **MCP server**, the server may need to call your internal APIs to read data or trigger workflows. Those APIs need tokens that reflect who the user is and what the server is allowed to do.

**Auth0 Custom Token Exchange** enables that delegation. The MCP server exchanges the token it received from the client for a new, short-lived access token scoped to the internal API. This lets **MCP servers** call internal APIs on behalf of users while **Auth0** issues and governs access centrally.

<Card title="Use this quickstart to call your APIs on a user's behalf from your MCP server" href="/mcp/get-started/call-your-apis-on-users-behalf" icon="book" />

### Call third-party APIs on a user's behalf

MCP Servers often connect AI Agents to third-party services such as Google, Microsoft, Jira, or Notion. Auth0’s **Token Vault** handles these integrations by managing token issuance, storage, rotation, and revocation for external APIs. Token Vault eliminates manual credential handling and makes it easy to extend MCP connectivity across the modern SaaS ecosystem.

## Get started

To begin using Auth for MCP in your MCP server, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Authorization for Your MCP Server" href="/mcp/get-started/authorization-for-your-mcp-server" icon="user" />

  <Card title="Call your APIs on a User's Behalf" href="/mcp/get-started/call-your-apis-on-users-behalf" icon="shapes" />
</Columns>

### Guides

<Columns>
  <Card title="Registering your MCP Client Application" href="/mcp/guides/registering-your-mcp-client-application" icon="book" />

  <Card title="Resource Parameter Compatibility Profile" href="/mcp/guides/resource-param-compatibility-profile" icon="book" />

  <Card title="Test your MCP Server with MCP Inspector" href="/mcp/guides/test-your-mcp-server-with-mcp-inspector" icon="book" />

  <Card title="Cloudflare MCP" href="/mcp/guides/cloudflare-mcp" icon="book" />
</Columns>

### Sample apps

<Columns>
  <Card title="Task Vantage" href="https://github.com/auth0-samples/auth0-task-vantage" icon="github" />

  <Card title="MCP with Token Vault" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp/xmcp-mcp-tokenvault-js" icon="github" />

  <Card title="MCP with Custom Token Exchange" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp/fastmcp-mcp-customtokenexchange-js" icon="github" />

  <Card title="MCP Samples" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp" icon="github" />
</Columns>

### SDKs

<Columns>
  <Card title="JS SDK" href="https://github.com/auth0/auth0-auth-js" icon="github" />

  <Card title="Python SDK" href="https://github.com/auth0/auth0-api-python" icon="github" />
</Columns>

## Early access

Auth for MCP delivers a more secure and scalable authentication and authorization for MCP servers using Auth0. It offers OAuth-compliant solutions for developers building applications that integrate AI agents.

<Card icon="file-lines" title="Early Access Program" href="https://forms.gle/hvJ1ZRLmHr9YjV2a9">
  Auth for MCP is currently available in Early Access. To join the Early Access program, please complete this form, and we'll reach out to you when your request is processed.
</Card>


# Why use Auth for MCP
Source: https://auth0.com/ai/docs/mcp/intro/why-auth-for-mcp

Benefits of using Auth0 to authenticate users before they or their AI Agents connect to MCP Servers.

<Note>
  Auth for MCP is currently available in Early Access. To join the Early Access program, please complete [this form](https://forms.gle/hvJ1ZRLmHr9YjV2a9). We'll reach out to you when your request is processed.
</Note>

Auth for MCP supports Auth0’s Universal Login, which allows users to sign in using social, enterprise, or custom identity providers. Every access token issued through Auth0 carries verified identity context, ensuring all MCP interactions start from a trusted source.

## Why authentication matters for MCP

* Secure and controlled access: Safeguards user data, manages who can use your MCP server and what they can do, and establishes a clear audit trail for activities performed through MCP servers and clients.
* Auditability: Provides a record of user activities for auditing and compliance.

## Why use Auth for MCP?

MCP offers practical advantages, such as standardized interfaces for LLMs to interact with tools and LLM-facing tools with rich context and metadata.

<Frame>
  <img alt="MCP Diagram" />

  <img alt="MCP Diagram" />
</Frame>

Auth0 allows your users to securely interact with trusted agents without worrying about LLMs gaining access to sensitive information like access tokens: Auth0 enforces scoped, identity-bound, least-privilege access for AI agents, both first-party and third-party APIs.

Auth0 manages consent flows and per-client permissions, secures credentials via Token Vault and Token Exchange while making it possible to audit logs and keep track of lifecycle events.

The MCP specification highlights several key OAuth 2.1 features that Auth0 provides:

* **Proof Key for Code Exchange (PKCE):** [PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) is a mandatory security feature that mitigates authorization code interception and is handled automatically in Auth0's SDKs.
* **Metadata Discovery:** This is mandatory per the MCP spec. Servers must advertise their OAuth endpoints. An Auth0 tenant provides [an authorization server discovery document](https://auth0.com/docs/get-started/applications/configure-applications-with-oidc-discovery#configure-applications-with-oauth-2-0-authorization-server-metadata) (`/.well-known/oauth-authorization-server`) so MCP clients can dynamically find the required endpoints for authorization, token exchange, etc., reducing manual client-side configuration.
* **Dynamic Client Registration (DCR):** DCR is crucial for scalability. It allows MCP clients (like a generic AI workbench) to programmatically register with your Auth0-secured MCP server via an API call. This avoids forcing users to manually create a client application in the Auth0 Dashboard for every new tool they want to connect.
* **Delegating Authentication to a Third-Party Identity Provider (IdP):** The specification supports delegating the user login process. You can configure your MCP server to use Auth0 as the trusted identity provider, centralizing user management and sign-on logic.

## Authentication for users of MCP Servers

Auth0 is a flexible, drop-in solution to add authentication and authorization services to your applications. With Auth0, your users can log in with:

* Username and password
* [Passwordless and Passkeys](https://auth0.com/docs/authenticate/passwordless)
* [Social Login (Google, Meta, Microsoft, GitHub, etc.)](https://auth0.com/docs/authenticate/passwordless#social-login)
* [Corporate credentials and Single Sign-On (SSO)](https://auth0.com/docs/authenticate/single-sign-on) for B2B AI applications
* And more.

Auth0 also provides the following features for enhanced security and scalability:

* [Multi-factor Authentication](https://auth0.com/docs/secure/multi-factor-authentication)
* [Attack Protection](https://auth0.com/docs/secure/attack-protection): Detect attacks and stop malicious attempts to access your application, such as blocking traffic from certain IPs and displaying CAPTCHA. This includes Bot Detection, Suspicious IP Throttling, Brute Force Protection, and Breached Password Detection.
* [Highly Regulated Identity](https://auth0.com/docs/secure/highly-regulated-identity)
* UI and login flow customizations via [Actions](https://auth0.com/docs/customize/actions) and [Forms](https://auth0.com/docs/customize/forms)

## MCP Authorization flow with Auth0

Here is the standard OAuth authorization code flow when an MCP server uses Auth0 as its authorization server:

<Steps>
  <Step>
    The MCP client sends a request to the protected MCP server and receives HTTP `401 Unauthorized` with a `WWW-Authenticate` header that indicates the protected resource metadata URL.
  </Step>

  <Step>
    The MCP client requests the [resource metadata](https://datatracker.ietf.org/doc/html/rfc9728/) from the MCP server at the `/.well-known/oauth-protected-resource` endpoint.
  </Step>

  <Step>
    The MCP client parses the metadata, selects an authorization server (Auth0) from the list, and then fetches its OAuth 2.0 Authorization Server Metadata from the `/.well-known/oauth-authorization-server` endpoint. [Dynamic Client Registration (DCR)](https://auth0.com/docs/get-started/applications/dynamic-client-registration#enable-dynamic-client-registration) can happen after receiving the metadata response.
  </Step>

  <Step>
    The client generates [PKCE](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow-with-pkce) parameters and builds the authorization request, then opens the browser to the authorization endpoint.
  </Step>

  <Step>
    The user then authenticates with Auth0 (using username/password, social login, or MFA). Auth0 redirects the browser to the MCP client’s registered redirect URI with an authorization code.
  </Step>

  <Step>
    The MCP client exchanges the code at the token endpoint and Auth0 returns the access token, completing the original OAuth flow.
  </Step>

  <Step>
    After receiving an access token (and refresh token), the MCP client will use the access token to make authenticated calls to the MCP server's tools.
  </Step>
</Steps>

<Frame>
  <img alt="Auth0 Authentication Flow" />

  <img alt="Auth0 Authentication Flow" />
</Frame>

## Enterprise Identity for MCP

For enterprise environments, you can use your organization's identity provider and Single Sign-On (SSO) to authenticate users to your MCP servers. Auth0 connects to Okta, Entra ID, Ping, Google Workspace, and other IdPs so employees can authenticate with existing credentials before any MCP connection begins.

This pattern provides:

* Unified workforce authentication and MFA for MCP Servers
* Centralized access policy enforcement and device posture checks
* Consistent session context across all agent interactions

Enterprise identity ensures that every request to an MCP Server originates from a verified employee identity governed by your enterprise security controls.

## Get started

To begin using Auth for MCP in your MCP server, refer to the following resources:

### Quickstarts

<Columns>
  <Card title="Authorization for Your MCP Server" href="/mcp/get-started/authorization-for-your-mcp-server" icon="user" />

  <Card title="Call your APIs on a User's Behalf" href="/mcp/get-started/call-your-apis-on-users-behalf" icon="shapes" />
</Columns>

### Sample Apps

<Columns>
  <Card title="Task Vantage" href="https://github.com/auth0-samples/auth0-task-vantage" icon="github" />

  <Card title="MCP with Token Vault" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp/xmcp-mcp-tokenvault-js" icon="github" />

  <Card title="MCP with Custom Token Exchange" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp/fastmcp-mcp-customtokenexchange-js" icon="github" />

  <Card title="MCP Samples" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp" icon="github" />
</Columns>


# Sample Apps
Source: https://auth0.com/ai/docs/mcp/sample-apps

Explore sample MCP apps built using Auth for MCP.

<Note>
  We value your feedback! To ask questions, report issues, or request new
  frameworks and providers, connect with us on
  [GitHub](https://github.com/auth0/auth-for-genai).
</Note>

<Columns>
  <Card title="Task Vantage" href="https://github.com/auth0-samples/auth0-task-vantage">
    Task Vantage is the refreshingly simple task management platform that brings clarity and accountability to your team's work. It has both a REST API and an MCP server, and it showcases how you can use a modern GenAI approach with Auth for MCP to provide a central place to organize, assign, and track tasks.
  </Card>

  <Card title="MCP with Token Vault" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp/xmcp-mcp-tokenvault-js">
    Learn how you can use [Auth0's Token Vault](https://auth0.com/ai/docs/intro/token-vault) to call an External MCP Service or API securely to use Google Calendar.
  </Card>

  <Card title="MCP with Custom Token Exchange" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp/fastmcp-mcp-customtokenexchange-js">
    Learn how you can leverage Custom Token Exchange on your Auth0 protected MCP server to exchange tokens for an Auth0 access token and call a protected first-party API.
  </Card>

  <Card title="MCP Samples" href="https://github.com/auth0-samples/auth0-ai-samples/tree/main/auth-for-mcp">
    Go further and explore our repository of standalone sample applications that showcase Auth0's authentication and authorization capabilities in MCP servers. Each sample demonstrates how to implement Auth for MCP in your MCP servers with different frameworks and different features that Auth0 offers.
  </Card>
</Columns>


# Sample Apps
Source: https://auth0.com/ai/docs/sample-apps

Explore sample apps built using Auth0 for AI Agents.

<Note>
  We value your feedback! To ask questions, report issues, or request new
  frameworks and providers, connect with us on
  [GitHub](https://github.com/auth0/auth-for-genai).
</Note>

<Columns>
  <Card title="Assistant0" href="https://github.com/auth0-samples/auth0-assistant0">
    A fullstack AI personal assistant with pre-configured tools that
    demonstrates different Auth0 for AI Agents features like User Authentication,
    calling APIs (Gmail, Google Calendar, etc.) securely using Token Vault,
    Human-in-the-loop interactions using Asynchronous Authorization, and using
    Auth0 FGA for securing RAG tools.

    <ul>
      <li>
        [LangGraph + Next.js
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain)
      </li>

      <li>
        [LangGraph + FastAPI
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain)
      </li>

      <li>
        [Vercel AI SDK + Next.js
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai)
      </li>

      <li>
        [LlamaIndex + Next.js
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex)
      </li>
    </ul>
  </Card>

  <Card title="SmartHR Assistant" href="https://github.com/auth0-samples/auth0-ai-smart-hr-assistant">
    An AI HR assistant that provides secure access to HR documents based on
    complex authorization rules. This demonstrates the use of Auth0 FGA to
    secure RAG applications with relationship-based access control (Fine-Grained
    Authorization). Implemented on a Next.js application with LlamaIndex.
  </Card>

  <Card title="Agent0" href="https://github.com/auth0-samples/agent0">
    A full-stack AI personal assistant, powered by React and Fastify, that
    invokes your APIs using tool calls on a logged-in user's behalf.
  </Card>

  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="Auth0 AI SDK TypeScript Samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples">
    Explore example applications that accompany Auth0's JavaScript AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>

  <Card title="Auth0 AI SDK Python Samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples">
    Explore example applications that accompany Auth0's Python AI SDKs. These
    demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>


# Cloudflare Agents SDKs & Samples
Source: https://auth0.com/ai/docs/sdks/cloudflare-sdk

Auth0 for AI Agents Cloudflare SDK makes it easy for developers to integrate with and secure AI agent workflows using Cloudflare Agents.

### [Auth0 AI for Cloudflare Agents](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-cloudflare)

This SDK provides building blocks for using Auth0 for AI Agents with the Cloudflare Agents API. It includes tools for implementing asynchronous user authentication, tools for getting access tokens for third-party connections, building blocks to handle interrupts, and [OpenFGA-based](https://openfga.dev/) tool authorizers. It supports:

* Tools for implementing asynchronous user authentication
* Tools for getting access tokens for third-party connections
* [OpenFGA-based](https://openfga.dev/) tool authorizers

```bash wrap lines theme={null}
npm install @auth0/ai-cloudflare
```

## Guides & Tutorials

Checkout our guides for Cloudflare Agents in TypeScript.

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />
</Columns>


# Genkit SDK
Source: https://auth0.com/ai/docs/sdks/genkit-sdk

Auth0 for AI Agents Genkit SDK makes it easy for developers to integrate with and secure AI agent workflows using Genkit.

### [Auth0 AI for Genkit](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-genkit)

This SDK provides building blocks for using Auth0 for AI Agents with [Genkit](https://firebase.google.com/docs/genkit). Includes a RAG Retriever for using OpenFGA, tools for implementing asynchronous user authentication, tools for getting access tokens for third-party connections, and [OpenFGA-based](https://openfga.dev/) tool authorizers. It supports:

* A RAG Retriever for using OpenFGA
* [OpenFGA-based](https://openfga.dev/) tool authorizer and re-ranker

```bash wrap lines theme={null}
npm install @auth0/ai-genkit
```

## Sample applications

Checkout our sample applications for Genkit.

<Columns>
  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="Auth0 AI SDK Samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples">
    Explore example applications that accompany Auth0's JavaScript AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>

## Guides & Tutorials

Checkout our guides for Genkit in TypeScript.

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />
</Columns>


# JavaScript SDKs & Samples
Source: https://auth0.com/ai/docs/sdks/javascript-sdk

Auth0 JavaScript SDKs make it easy for developers to integrate with and secure AI agent workflows.

## Auth0 SDKs

Updated Auth0 SDKs to secure AI agent workflows:

### [Next.js](https://github.com/auth0/nextjs-auth0)

This SDK streamlines integrating Auth0 authentication and authorization services into Next.js applications. It supports:

* User authentication
* Tools for getting access tokens for supported social and enterprise identity providers

```bash wrap lines theme={null}
npm install @auth0/nextjs-auth0
```

### [Node.js](https://github.com/auth0/node-auth0)

This library streamlines integrating Auth0's authentication and authorization services into Node.js applications. It supports:

* User authentication
* Tools for signing up users, managing user profiles, and securing API endpoints.

```bash wrap lines theme={null}
npm install auth0
```

### [Auth0 Fastify SDK](https://www.npmjs.com/package/@auth0/auth0-fastify)

This SDK streamlines integrating Auth0 authentication and authorization services into Fastify applications. It supports:

* User authentication
* Tools for getting access tokens to call first-party APIs

```bash wrap lines theme={null}
npm i @auth0/auth0-fastify
```

## Auth0 AI SDKs

Auth0 AI SDKs to streamline integrating your application with popular agentic frameworks:

### [Auth0 AI SDK](https://github.com/auth0/auth0-ai-js)

This SDK provides base abstractions for authentication and authorization in AI applications. It supports:

* Asynchronous user authentication using the [Client Initiated Backchannel Authentication (CIBA)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html) protocol
* [OpenFGA-based](https://openfga.dev/) filter for RAG

```bash wrap lines theme={null}
npm install @auth0/ai
```

### [Auth0 AI Components](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-components)

This library helps to set up the React components that can be used in AI applications using Auth0 for AI Agents. The components are styled using [Tailwind CSS](https://tailwindcss.com/). It supports:

* Tools for getting access tokens for supported social and enterprise identity providers

```bash wrap lines theme={null}
npx @auth0/ai-components add TokenVault
```

### [Redis Store for Auth0 AI](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-redis)

This SDK provides a secure Redis-based data store implementation for use with the Auth0 AI SDKs. It supports:

* Securely encrypting data before storing it in Redis
* Organizing keys using namespaces
* Setting expiration times for stored data

```bash wrap lines theme={null}
npm install @auth0/ai-redis
```

## Sample applications

Checkout our sample applications for JavaScript/TypeScript built with frameworks like LangGraph and Vercel AI.

<Columns>
  <Card title="Assistant0 (Next.js)" href="https://github.com/auth0-samples/auth0-assistant0">
    A fullstack AI personal assistant with pre-configured tools that demonstrate
    different Auth0 for AI Agents features like User Authentication, Calling APIs
    (Gmail, Google Calendar, etc) securely using Token Vault, Human-in-the-loop
    interactions using Asynchronous Authorization, and using Auth0 FGA for
    securing RAG tools.

    <ul>
      <li>
        [LangGraph
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain)
      </li>

      <li>
        [Vercel AI SDK
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai)
      </li>

      <li>
        [LlamaIndex
        version](https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex)
      </li>
    </ul>
  </Card>

  <Card title="SmartHR Assistant" href="https://github.com/auth0-samples/auth0-ai-smart-hr-assistant">
    An AI HR assistant that provides secure access to HR documents based on
    complex authorization rules. This demonstrates the use of Auth0 FGA to
    secure RAG applications with relationship-based access control (Fine-Grained
    Authorization). Implemented on a Next.js application with LlamaIndex.
  </Card>

  <Card title="Agent0" href="https://github.com/auth0-samples/agent0">
    A full-stack AI personal assistant, powered by React and Fastify, that
    invokes your APIs using tool calls on a logged-in user's behalf.
  </Card>

  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="Auth0 AI SDK TypeScript Samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples">
    Explore example applications that accompany Auth0's JavaScript AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>

## Guides & Tutorials

Checkout our guides for Next.js, LangChain, LlamaIndex, Vercel AI, and Genkit in JavaScript/TypeScript.

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />

  <Card title="Get Salesforce Opportunities" href="/how-tos/get-salesforce-opportunities" icon="salesforce" />
</Columns>


# LangChain SDKs & Samples
Source: https://auth0.com/ai/docs/sdks/langchain-sdk

Auth0 for AI Agents LangChain & LangGraph SDKs make it easy for developers to integrate with and secure AI agent workflows using LangChain and LangGraph.

## JavaScript & TypeScript

### [Auth0 AI for LangChain](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-langchain)

This SDK provides building blocks for using Auth0 for AI Agents with [LangChain](https://www.langchain.com/) and [LangGraph](https://www.langchain.com/langgraph). It supports:

* A RAG Retriever for using OpenFGA
* Tools for implementing asynchronous user authentication
* Tools for getting access tokens for third-party connections
* [OpenFGA-based](https://openfga.dev/) tool authorizers

```bash wrap lines theme={null}
npm install @auth0/ai-langchain
```

## Python

### [Auth0 AI for LangChain](https://github.com/auth0/auth0-ai-python/tree/main/packages/auth0-ai-langchain)

This SDK provides building blocks for using Auth0 for AI Agents with LangChain and LangGraph. Includes a RAG Retriever for using OpenFGA, tools for implementing asynchronous user authentication, tools for getting access tokens for third-party connections, and OpenFGA-based tool authorizers. It supports:

* A RAG Retriever for using OpenFGA,
* Tools for getting access tokens for third-party connections,
* OpenFGA-based tool authorizers.

```bash wrap lines theme={null}
pip install auth0-ai-langchain
```

## Sample applications

Checkout our sample applications built with LangChain and LangGraph.

<Columns>
  <Card title="Assistant0 (Next.js)" href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-langchain">
    A fullstack AI personal assistant with pre-configured tools that demonstrate different Auth0 for AI Agents features like User Authentication, Calling APIs (Gmail, Google Calendar, etc) securely using Token Vault, Human-in-the-loop interactions using Asynchronous Authorization, and using Auth0 FGA for securing RAG tools.
  </Card>

  <Card title="Assistant0 (FastAPI)" href="https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain">
    A fullstack AI personal assistant with pre-configured tools that demonstrate different Auth0 for AI Agents features like User Authentication, Calling APIs (Gmail, Google Calendar, etc) securely using Token Vault, Human-in-the-loop interactions using Asynchronous Authorization, and using Auth0 FGA for securing RAG tools.
  </Card>

  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="Auth0 AI SDK TypeScript Samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples">
    Explore example applications that accompany Auth0's JavaScript AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>

  <Card title="Auth0 AI SDK Python Samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples">
    Explore example applications that accompany Auth0's Python AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>

## Guides & Tutorials

Checkout our guides for LangChain and LangGraph in TypeScript and Python.

<Columns>
  <Card title="Build an AI Assistant with LangGraph, Vercel, and Next.js: Use Gmail as a Tool Securely" href="https://auth0.com/blog/genai-tool-calling-build-agent-that-calls-gmail-securely-with-langgraph-vercelai-nextjs/" icon="newspaper" />

  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />
</Columns>


# LlamaIndex SDK
Source: https://auth0.com/ai/docs/sdks/llamaindex-sdk

Auth0 for AI Agents LlamaIndex SDKs make it easy for developers to integrate with and secure AI agent workflows using LlamaIndex.

## JavaScript & TypeScript

### [Auth0 AI for LlamaIndex](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-llamaindex)

This SDK provides building blocks for using Auth0 for AI Agents with [LlamaIndex](https://www.llamaindex.ai/). Includes a RAG Retriever for using OpenFGA, tools for implementing asynchronous user authentication, tools for getting access tokens for third-party connections, and [OpenFGA-based](https://openfga.dev/) tool authorizers. It supports:

* A RAG Retriever for using OpenFGA
* Tools for implementing asynchronous user authentication
* Tools for getting access tokens for third-party connections
* OpenFGA-based tool authorizers

```bash wrap lines theme={null}
npm install @auth0/ai-llamaindex
```

## Python

### [Auth0 AI for LlamaIndex](https://github.com/auth0/auth0-ai-python/tree/main/packages/auth0-ai-llamaindex)

This SDK provides building blocks for using Auth0 for AI Agents with LlamaIndex. Includes a RAG Retriever for using OpenFGA, tools for implementing asynchronous user authentication, tools for getting access tokens for third-party connections, and OpenFGA-based tool authorizers. It supports:

* A RAG Retriever for using OpenFGA,
* Tools for getting access tokens for third-party connections,
* OpenFGA-based tool authorizers.

```bash wrap lines theme={null}
pip install auth0-ai-llamaindex
```

## Sample applications

Checkout our sample applications for LlamaIndex.

<Columns>
  <Card title="SmartHR Assistant" href="https://github.com/auth0-samples/auth0-ai-smart-hr-assistant">
    An AI HR assistant that provides secure access to HR documents based on
    complex authorization rules. This demonstrates the use of Auth0 FGA to
    secure RAG applications with relationship-based access control (Fine-Grained
    Authorization).
  </Card>

  <Card title="Assistant0 (Next.js)" href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-llamaindex">
    A fullstack AI personal assistant with pre-configured tools that
    demonstrates different Auth0 for AI Agents features like User Authentication,
    calling APIs (Gmail, Google Calendar, etc.) securely using Token Vault,
    Human-in-the-loop interactions using Asynchronous Authorization, and using
    Auth0 FGA for securing RAG tools.
  </Card>

  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="Auth0 AI SDK TypeScript Samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples">
    Explore example applications that accompany Auth0's JavaScript AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>

  <Card title="Auth0 AI SDK Python Samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples">
    Explore example applications that accompany Auth0's Python AI SDKs. These
    demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>

## Guides & Tutorials

Checkout our guides for LlamaIndex in TypeScript and Python.

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />
</Columns>


# Auth0 for AI Agents SDKs
Source: https://auth0.com/ai/docs/sdks/overview

Start building secure AI agents with the Auth0 AI SDKs.

These SDK make it quick and easy to integrate Auth0 with your AI agents using multiple popular frameworks. The SDKs provide:

* Tools for getting access tokens allowing your AI agent to access applications on behalf of your users
* Tools for implementing asynchronous user authentication allowing human-in-the-loop approval for critical actions
* OpenFGA-based tool authorizers for securing document access

<Columns>
  <Card href="/sdks/javascript-sdk" icon="js" title="JavaScript SDKs" />

  <Card href="/sdks/python-sdk" icon="python" title="Python SDKs" />

  <Card
    href="/sdks/langchain-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/langchain.svg"
    alt="LangChain"
  />
}
    title="LangChain SDKs"
  />

  <Card
    href="/sdks/llamaindex-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/llamadex.svg"
    alt="LlamaIndex"
  />
}
    title="LlamaIndex SDKs"
  />

  <Card
    href="/sdks/vercel-ai-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/vercel.svg"
    alt="Vercel AI"
  />
}
    title="Vercel AI SDKs"
  />

  <Card
    href="/sdks/genkit-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/genkit.svg"
    alt="Genkit"
  />
}
    title="Genkit SDKs"
  />

  <Card
    href="/sdks/cloudflare-sdk"
    icon={
  <img
    src="https://mintlify-assets.b-cdn.net/auth0/cloudflare.svg"
    alt="Cloudflare"
    height={48}
    width={48}
  />
}
    title="Cloudflare SDKs"
  />
</Columns>


# Python SDKs & Samples
Source: https://auth0.com/ai/docs/sdks/python-sdk

Auth0 Python SDKs make it easy for developers to integrate with and secure AI agent workflows.

## Auth0 SDKs

Updated Auth0 SDKs to secure AI agent workflows:

### [Auth0 Python Server SDK](https://github.com/auth0/auth0-server-python)

The Auth0 Server Python SDK is a library for implementing user authentication in Python applications.

```bash wrap lines theme={null}
pip install auth0-server-python
```

### [Auth0 Python API SDK](https://github.com/auth0/auth0-api-python)

The auth0-api-python library allows you to secure APIs running on Python, particularly for verifying Auth0-issued access tokens.

It’s intended as a foundation for building more framework-specific integrations (e.g., with FastAPI, Django, etc.), but you can also use it directly in any Python server-side environment.

```bash wrap lines theme={null}
pip install auth0-api-python
```

### [Auth0 FastAPI SDK](https://github.com/auth0/auth0-fastapi)

The Auth0 FastAPI SDK is a library for implementing user authentication in FastAPI web applications using Auth0.

```bash wrap lines theme={null}
pip install auth0-fastapi
```

### [Auth0 FastAPI API SDK](https://github.com/auth0/auth0-fastapi-api)

The Auth0 FastAPI API SDK library allows you to secure FastAPI APIs using bearer tokens from Auth0.

It exposes a simple `require_auth` dependency that checks if incoming requests have a valid JWT, then provides the token claims to your route handler.

```bash wrap lines theme={null}
pip install auth0-fastapi-api
```

## Auth0 AI SDKs

Auth0 AI SDKs to streamline integrating your application with popular agentic frameworks:

### [Auth0 AI SDK](https://github.com/auth0/auth0-ai-python)

This SDK provides base abstractions for authentication and authorization in AI applications, including tools for implementing asynchronous user authentication using the Client Initiated Backchannel Authentication (CIBA) protocol. It supports:

* A RAG Retriever for using OpenFGA
* Tools for implementing asynchronous user authentication,
* Tools for getting access tokens for third-party connections,
* OpenFGA-based tool authorizers.

```bash wrap lines theme={null}
pip install auth0-ai
```

## Sample applications

Checkout our sample applications for Python built with frameworks like LangGraph and LLamaIndex.

<Columns>
  <Card title="Assistant0 (LangGraph + FastAPI)" href="https://github.com/auth0-samples/auth0-assistant0/tree/main/py-langchain">
    A fullstack AI personal assistant with pre-configured tools that demonstrate different Auth0 for AI Agents features like User Authentication, Calling APIs (Gmail, Google Calendar, etc) securely using Token Vault, Human-in-the-loop interactions using Asynchronous Authorization, and using Auth0 FGA for securing RAG tools.
  </Card>

  <Card title="Auth0 AI SDK Samples" href="https://github.com/auth0/auth0-ai-python/tree/main/examples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore example applications that accompany Auth0's Python AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>

## Guides & Tutorials

Checkout our guides for LangChain and LlamaIndex in Python.

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />
</Columns>


# Vercel AI SDKs & Samples
Source: https://auth0.com/ai/docs/sdks/vercel-ai-sdk

Auth0 for AI Agents Vercel AI SDKs make it easy for developers to integrate with and secure AI agent workflows using Vercel AI.

### [Auth0 AI for Vercel AI SDK](https://github.com/auth0/auth0-ai-js/tree/main/packages/ai-vercel)

This SDK provides building blocks for using Auth0 for AI Agents with the Vercel AI SDK. It includes tools for implementing asynchronous user authentication, tools for getting access tokens for third-party connections, building blocks to handle interrupts, and [OpenFGA-based](https://openfga.dev/) tool authorizers. It supports:

* Tools for implementing asynchronous user authentication
* Tools for getting access tokens for third-party connections
* [OpenFGA-based](https://openfga.dev/) tool authorizers

```bash wrap lines theme={null}
npm install @auth0/ai-vercel
```

## Sample applications

Checkout our sample applications for JavaScript/TypeScript built with frameworks like LangGraph and Vercel AI.

<Columns>
  <Card title="Assistant0 (Next.js)" href="https://github.com/auth0-samples/auth0-assistant0/tree/main/ts-vercel-ai">
    A fullstack AI personal assistant with pre-configured tools that demonstrate different Auth0 for AI Agents features like User Authentication, Calling APIs (Gmail, Google Calendar, etc) securely using Token Vault, Human-in-the-loop interactions using Asynchronous Authorization, and using Auth0 FGA for securing RAG tools.
  </Card>

  <Card title="Agent0 (Fastify)" href="https://github.com/auth0-samples/agent0">
    A full-stack AI personal assistant, powered by React and Fastify, that
    invokes your APIs using tool calls on a logged-in user's behalf.
  </Card>

  <Card title="AI Samples" href="https://github.com/auth0-samples/auth0-ai-samples">
    Explore our repository of standalone sample applications that showcase
    Auth0's authentication and authorization capabilities in generative AI
    applications. Each sample demonstrates a specific Auth0 for AI Agents feature.
  </Card>

  <Card title="Auth0 AI SDK Samples" href="https://github.com/auth0/auth0-ai-js/tree/main/examples">
    Explore example applications that accompany Auth0's JavaScript AI SDKs.
    These demonstrate recommended implementation patterns for the SDKs.
  </Card>
</Columns>

## Guides & Tutorials

Checkout our guides for Vercel AI in TypeScript.

<Columns>
  <Card title="Check Google Calendar Availability" href="/how-tos/check-google-calendar-availability" icon="google" />

  <Card title="List GitHub Repositories" href="/how-tos/list-github-repositories" icon="github" />

  <Card title="List Slack Channels" href="/how-tos/list-slack-channels" icon="slack" />

  <Card title="Get Salesforce Opportunities" href="/how-tos/get-salesforce-opportunities" icon="salesforce" />
</Columns>


